{"version":3,"sources":["webpack://opensoql/webpack/universalModuleDefinition","webpack://opensoql/webpack/bootstrap","webpack://opensoql/./src/lib/util.ts","webpack://opensoql/./src/lib/condition.ts","webpack://opensoql/./src/lib/cache.ts","webpack://opensoql/./src/lib/call.ts","webpack://opensoql/./src/filters.ts","webpack://opensoql/./src/sort.ts","webpack://opensoql/./node_modules/fruitsconfits/src/lib/types.ts","webpack://opensoql/./node_modules/fruitsconfits/src/lib/parser.ts","webpack://opensoql/./node_modules/fruitsconfits/src/lib/string-parser.ts","webpack://opensoql/./node_modules/fruitsconfits/src/lib/object-parser.ts","webpack://opensoql/./src/lib/protection.ts","webpack://opensoql/./src/lib/parser.ts","webpack://opensoql/./src/lib/compiler.ts","webpack://opensoql/./src/lib/datetime-util.ts","webpack://opensoql/./src/lib/functions.ts","webpack://opensoql/./src/lib/prepare.ts","webpack://opensoql/./src/lib/run-query.ts","webpack://opensoql/./src/builder.ts","webpack://opensoql/./src/lib/run-dml.ts","webpack://opensoql/./src/lib/csv-parser.ts","webpack://opensoql/./src/resolvers.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","DatePattern","DateTimePattern","deepCloneObject","obj","Array","isArray","slice","map","x","Map","ent","from","entries","Set","values","k","keys","isEqualComplexName","a","b","length","toLowerCase","getFullQualifiedName","primaryResolverName","sliced","push","concat","getTrueCaseFieldName","record","ni","index","findIndex","getObjectValue","getObjectValueWithFieldNameMap","has","getTrueCasePathName","ret","getObjectTrueCasePathValue","getObjectPathValue","filterZeroLengthCondFn","cond","op","operands","pruneCondition","type","tmp","pruneConditionCheckFncall","arg","args","filter","filterCondOperands","flatConditions","dest","parentOp","recurse","Error","pushOperands","getParameterValueDenyArray","ctx","params","z","getParameterValueAllowArray","filterIndexFieldCondOperands","indexFieldNamesI","w","pruneNonIndexFieldConditions","includes","y","condOp1FnCache","WeakMap","condOp2ValueCache","nestedFnInfoCache","memoizedFnCache","callScalarFunction","field","fnInfo","fieldResultType","groupedRecs","Date","getTime","Number","argFnInfoTmp","argFnNameI","fn","functions","find","argFnInfo","callAggregateFunction","callImmediateScalarFunction","cached","hasNonImmediate","join","set","records","getGroupFieldTrueCaseName","groupFields","trueCaseName","isScalarFnCallable","getOp1Noop","fieldNameMap","cache","getOp1AggregateFnValue","op2FieldResultType","getOp1ScalarOnAggFnValue","getOp1ScalarOnNonAggFnValue","getOp1ImmediateScalarOnAggFnValue","getOp1ImmediateScalarOnNonAggFnValue","getOp1Value","isAggregation","v","op2","op2IsDateOrDatetime","isField","isDateOrDatetime","fnNameI","createOp1Cache","evalRecursiveCondition","evalCondition","EVAL","v1","v2","mapArrayItem","RegExp","pat0","replace","pattern","prev","convertPattern","split","getOp2Value","test","OUTER","v2Items","v1Items","q","matched","applyWhereConditions","conds","NEXTREC","applyHavingConditions","groupedRecsArray","firstRec","query","groupBy","getIndexFieldConditions","indexFieldNames","getSqlConditionString","dialect","getSqlConditionStringImpl","notSupported","getArrayValue","getEscapedParamValue","escapeString","toString","allowArray","String","fieldName","escapeSqlStringLiteral_Std","escapeSqlStringLiteral_MySql","sortRecords","orderBy","primaryPathLen","orderFields","direction","f","fieldAndFNames","fName","sort","LOOP","va","vb","nulls","ParseError","result","super","message","parserInput","src","context","start","end","templateArgs","templateArgsPos","formatErrorMessage","msg","Math","max","pos","ar","lineAndCol","line","col","getLineAndCol","JSON","stringify","e","zeroWidth","helper","input","succeeded","next","tokens","zeroWidthError","error","beginning","quantify","min","parser","first","parsers","last","or","reduce","transform","trans","ctxTrans","t2","lookAhead","lookBehind","applyProductionRules","lexer","lexerInput","lexResult","completed","check","maxApply","rules","rule","rtol","len","nextSrc","makeProgram","templateStringsParam","criteria","conv","argIdx","getStringParsers","seq","rawToToken","needle","startsWith","cls","needles","some","idx","charClass","notCls","codePointAt","fromCodePoint","charClassNot","clsFn","substring","charClassByNeedleFn","cat","concatTokens","once","repeat","qty","combine","erase","isAlpha","isUpper","isLower","isNumber","isNonZeroNumber","isBinNum","isOctNum","isHexNum","isAlNum","isSpace","isSpaceWithinSingleLine","isControl","isWord","isNewline","isAny","binSep","octSep","hexSep","decimalIntegerNumber","bigDecimalIntegerNumber","floatingPointNumber","classes","alpha","upper","lower","num","nonzero","bin","oct","hex","alnum","space","spaceWithinSingleLine","ctrl","newline","word","any","numbers","prefixes","int","bigint","float","isParam","err","ahead","behind","objSequence","comparator","objClass","objClassNot","dummyTargetObject","g","globalObj","objConstructor","funConstructor","Function","window","global","globalThis","constructor","isUnsafeVarNames","target","varName","con","__proto__","$s","rawToken","$o","getObjectParsers","seqI","toLocaleLowerCase","binaryOp","op1","isOperator","lineComment","blockComment","commentOrSpace","reservedKeywords","wordBoundary","notAheadReservedKeywords","trueValue","falseValue","nullValue","positiveInfinityValue","POSITIVE_INFINITY","negativeInfinityValue","NEGATIVE_INFINITY","nanValue","NaN","binaryIntegerValue","parseInt","octalIntegerValue","decimalIntegerValue","floatingPointNumberValue","parseFloat","numberValue","stringEscapeSeq","stringValue","dateValue","dateTimeValue","symbolStringValue","sym","symbolName","complexSymbolName","parameterizedValue","literalValue","selectFieldFunctionCall","subQuery","selectStatement","listValue","complexSelectFieldName","aliasName","selectFieldList","select","fromClause","conditionalOperator","conditionExpressionExprRule3","conditionExpressionExprRule2","conditionExpressionExprRule1","whereFieldExpression","whereConditionExpressionInnerRoot","whereConditionExpression","whereClause","where","groupByClause","havingFieldExpression","havingConditionExpressionInnerRoot","havingConditionExpression","havingClause","having","orderByDirection","orderByNulls","orderByClause","offsetClause","offset","limitClause","limit","forViewClause","for","forUpdateClause","program","findResolver","rn","registerFields","defaultResolver","resolver","add","recureseForEachConditionFieldsFncall","recureseForEachConditionFields","normalize","builder","parentName","parentAliases","resolverAliases","whereSubQueries","havingSubQueries","selectSubQueries","nameI","fieldAliasNames","normalizeTarget","normalizeSelectField","normalizeFnCall","opIndex","found","normalizeCondition","queryFields","queryFieldsMap","condFields","condAliasFields","havingCondFields","relationshipIdFields","registerQueryFields","rslv","registerCondFields","registerHavingCondFields","exprCount","collectFncallQueryFields","nested","resolverTmp","primaryResolverRootTrueCaseName","relationships","resolverTree","makeResolverTree","path","argResolverNameI","resolverName","argfieldOrRelNameI","fieldOrRelName","trueCaseArgResolverName","children","nextPath","lastFound","rt","j","resolvers","delete","sortFieldNames","childResolverName","childRelationshipInfo","childIdField","id","foreignIdFieldName","getUTCDayInYear","d0","UTC","getUTCFullYear","getUTCMonth","getUTCDate","getDayInYear","getFullYear","getMonth","getDate","fnInfo_cast_to_string","fnInfo_cast_to_number","fnInfo_cast_to_boolean","Boolean","fnInfo_concat","fnInfo_add","fnInfo_sub","fnInfo_mul","fnInfo_div","fnInfo_mod","fnInfo_count","fnInfo_count_distinct","size","fnInfo_sum","isNaN","fnInfo_avg","fnInfo_max","fnInfo_min","dateScalarFunctionGen","fnName","fnInfo_convertTimezone","dateStr","getTimezoneOffset","toISOString","fnInfo_calendar_month","fnInfo_calendar_month_lc","fnInfo_calendar_quarter","floor","fnInfo_calendar_quarter_lc","fnInfo_calendar_year","fnInfo_calendar_year_lc","fnInfo_day_in_month","fnInfo_day_in_month_lc","fnInfo_day_in_week","getUTCDay","fnInfo_day_in_week_lc","getDay","fnInfo_day_in_year","fnInfo_day_in_year_lc","fnInfo_day_only","fnInfo_day_only_lc","fnInfo_hour_in_day","getUTCHours","fnInfo_hour_in_day_lc","getHours","fnInfo_week_in_month","fnInfo_week_in_month_lc","builtinFunctions","builtinRules","idFieldName","masterResolverName","prepareQuery","strings","compile","joined","templateStringsParserInput","parse","execCondSubQueries","tr","trOptions","condTemplate","resolverData","condSubQueries","forEach","collectSubQueriesFromCondition","subQueries","condSubQueryResults","executeCompiledQuery","then","Promise","all","mapSelectFields","queryFieldsMapEntries","fnInfos","fnScaler","fnImmediateScaler","fnNoop","groupRecords","keystr","aggregateFields","fnAggregate","agg","fnImmediateScalar","fnScalar","getRemovingFields","removingFields","requestedFields","rec","getResolversInfo","resolverNames","parentType","parentKey","currentKey","parentResolverName","masterRelationshipInfo","foreignIdField","parentIdFieldName","currentIdFieldName","parent","parentQueriedRecords","parentResolverNames","parentResolverData","primaryRecords","primaryCapabilities","queriedRecords","normalizeLimitAndOffset","events","beginExecute","transactionData","transactionOptions","condWhereTemplate","condHavingTemplate","removingFieldsAndRecords","removingFieldsMap","parentRecords","hasAliasNameCond","sortFields","resolvingFields","condWhere","condHaving","ctxGen","graphPath","masterIdField","detailIdField","conditions","resolverCapabilities","filtering","sorting","filteredGrouped","beforeMasterSubQueries","parentFieldName","recs","afterMasterSubQueries","parentRemovingFields","promises","subQueryName","evtGen","beforeDetailSubQueries","afterDetailSubQueries","endExecute","Query","runCompiledQuery","build","preparedBI","insert","update","remove","prepareBuilderInfo","subscribers","Publisher","eventQueue","on","data","publish","queue","setTimeout","subscribe","unsubscribe","unsubscribeAllBySubscriber","createTransactionScope","scopeTr","scopeTrOptions","scopePublisher","isIsolated","scopePub","toPublishFn","withTransactionEvents","publisher","run","beginTransaction","endTransaction","fire","e2","runNotifyGen","resolve","soql","resolverInfo","evt","executeInsertDML","executeUpdateDML","executeRemoveDML","touch","notifyRemoved","transaction","callback","commands","_trOptions","_publish","quoted","nakidNum","nakid","trim","cell","row","rows","defaultStaticResolverConfig","noCache","noFiltering","noSorting","setDefaultStaticResolverConfig","conf","assign","jsonRecordsParser","csvRecordsParser","rawRecords","header","cur","passThroughParser","staticResolverBuilderGen","fetcher","config","fields","cachedRecords","fromCache","fetched","recordFields","parentId","every","filterAndSliceRecords","staticJsonResolverBuilder","staticCsvResolverBuilder","passThroughResolverBuilder"],"mappings":"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","file":"opensoql.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"opensoql\"] = factory();\n\telse\n\t\troot[\"opensoql\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\nexport const DatePattern = /^(\\d{4}-[01]\\d-[0-3]\\d)$/;\nexport const DateTimePattern =\n    /^((?:(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d))(?:[+-][0-2]\\d:[0-5]\\d|Z))$/;\nexport const DateTimeNoTzPattern =\n    /^((?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d))$/;\n\n\nexport function deepCloneObject<T>(obj: T): T {\n    switch (typeof obj) {\n    case 'object':\n        if (Array.isArray(obj)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return obj.slice().map(x => deepCloneObject(x)) as any;\n        } else if (obj === null) {\n            return obj;\n        } else {\n            if (obj instanceof Map) {\n                const ent: Array<[any, any]> =\n                    Array.from(obj.entries())\n                         .map(x => [deepCloneObject(x[0]), deepCloneObject(x[1])]);\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return new Map(ent) as any;\n            } else if (obj instanceof Set) {\n                const ent =\n                    Array.from(obj.values())\n                         // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                         .map(x => deepCloneObject(x));\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return new Set(ent) as any;\n            } else {\n                const r = {};\n                for (const k of Object.keys(obj)) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    r[k] = deepCloneObject(obj[k]);\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return r as any;\n            }\n        }\n    default:\n        return obj;\n    }\n}\n\n\nexport function isEqualComplexName(a: string[], b: string[]): boolean {\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i].toLowerCase() !== b[i].toLowerCase()) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getFullQualifiedName(primaryResolverName: string[], name: string[]) {\n    const ns: string[] = [];\n    for (let i = 0; i < primaryResolverName.length; i++) {\n        const sliced = primaryResolverName.slice(i);\n        if (isEqualComplexName(name.slice(0, sliced.length), sliced)) {\n            break;\n        } else {\n            ns.push(primaryResolverName[i]);\n        }\n    }\n    if (ns.length) {\n        return ns.concat(name);\n    } else {\n        return name;\n    }\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getTrueCaseFieldName(record: any, name: string) {\n    const keys = Object.keys(record);\n    const ni = name.toLowerCase();\n    const index = keys.findIndex(x => x.toLowerCase() === ni);\n\n    if (0 > index) {\n        return null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\n    return keys[index];\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getObjectValue(record: any, name: string) {\n    const keys = Object.keys(record);\n    const ni = name.toLowerCase();\n    const index = keys.findIndex(x => x.toLowerCase() === ni);\n\n    if (0 > index) {\n        return null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\n    return record[keys[index]];\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getObjectValueWithFieldNameMap(map: Map<string, string>, record: any, name: string) {\n    const ni = name.toLowerCase();\n\n    if (! map.has(ni)) {\n        return null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-non-null-assertion\n    return record[map.get(ni)!];\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getTrueCasePathName(record: any, name: string[]): string[] | null {\n    const ret: string[] = [];\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let r = record;\n\n    for (const n of name) {\n        if (r === null || r === void 0) {\n            return null;\n        }\n\n        const keys = Object.keys(r);\n        const ni = n.toLowerCase();\n        const index = keys.findIndex(x => x.toLowerCase() === ni);\n\n        if (0 > index) {\n            return null;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        r = r[keys[index]];\n\n        ret.push(keys[index]);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return ret;\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getObjectTrueCasePathValue(record: any, name: string[]) {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let r = record;\n\n    for (const n of name) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        r = r[n];\n\n        if (r === null || r === void 0) {\n            return null;\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return r;\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getObjectPathValue(record: any, name: string[]) {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let r = record;\n\n    for (const n of name) {\n        const keys = Object.keys(r);\n        const ni = n.toLowerCase();\n        const index = keys.findIndex(x => x.toLowerCase() === ni);\n\n        if (0 > index) {\n            return null;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        r = r[keys[index]];\n\n        if (r === null || r === void 0) {\n            return null;\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return r;\n}\n\n\nexport function convertPattern(v: string): string {\n    // NOTE: wildcards are '%' (= /.*/) and '_' (= /./)\n    //       wildcard escape sequences are '\\%' and '\\_'\n\n    const pat0 = v.replace(/[.*+?^=!:${}()|[\\]/]/g, '\\\\$&');\n    let pattern = '';\n    let prev: string | undefined = void 0;\n\n    for (const c of pat0) {\n        switch (c) {\n        case '%':\n            if (prev === '\\\\') {\n                pattern += '%';\n            } else {\n                pattern += '.*';\n            }\n            break;\n        case '_':\n            if (prev === '\\\\') {\n                pattern += '_';\n            } else {\n                pattern += '.';\n            }\n            break;\n        case '\\\\':\n            if (prev === '\\\\') {\n                pattern += '\\\\\\\\';\n                prev = void 0;\n                continue;\n            }\n            break;\n        default:\n            if (prev === '\\\\') {\n                pattern += '\\\\';\n            }\n            pattern += c;\n        }\n        prev = c;\n    }\n    if (prev === '\\\\') {\n        pattern += '\\\\';\n    }\n    return `^${pattern}$`;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { PreparedFnCall,\n         PreparedCondition,\n         ResolverContext,\n         PreparedAtomValue,\n         PreparedParameterizedValue,\n         SqlDialect }         from '../types';\nimport { isEqualComplexName } from './util';\n\n\n\nexport function filterZeroLengthCondFn(cond: PreparedCondition): boolean {\n    switch (cond.op) {\n    case 'true':\n        return false;\n    case 'not': case 'and': case 'or':\n        if (cond.operands.length === 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\nfunction filterCondOperands(name: string[], cond: PreparedCondition) {\n    cond.operands = cond.operands\n    .map(x => {\n        switch (typeof x) {\n        case 'object':\n            if (Array.isArray(x)) {\n                return x;\n            } else {\n                if (x === null) {\n                    // NOTE: never reach here.\n                    return x;\n                }\n                switch (x.type) {\n                case 'condition':\n                    return pruneCondition(name, x);\n                default:\n                    return x;\n                }\n            }\n        default:\n            return x;\n        }\n    })\n    .filter(x => {\n        switch (typeof x) {\n        case 'object':\n            if (x !== null && !Array.isArray(x) && x.type === 'condition') {\n                return filterZeroLengthCondFn(x);\n            }\n        }\n        return true;\n    });\n\n    return cond;\n}\n\n\nfunction pruneConditionCheckFncall(name: string[], x: PreparedFnCall): PreparedCondition | null {\n    for (const arg of x.args) {\n        switch (typeof arg) {\n        case 'object':\n            if (arg === null) {\n                // NOTE: Nothing to do.\n            } else {\n                switch (arg.type) {\n                case 'field':\n                    // TODO: Check all arguments' resolver are equal\n                    if (! isEqualComplexName(name, arg.name.slice(0, arg.name.length - 1))) {\n                        return ({\n                            type: 'condition',\n                            op: 'true',\n                            operands: [],\n                        });\n                    } else {\n                        arg.name = arg.name.slice(arg.name.length - 1);\n                    }\n                    break;\n                case 'fncall':\n                    {\n                        const tmp = pruneConditionCheckFncall(name, arg);\n                        if (tmp) {\n                            return tmp;\n                        }\n                    }\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    return null;\n}\n\n\nexport function pruneCondition(name: string[], cond: PreparedCondition): PreparedCondition {\n    if (cond.operands.length) {\n        const x = cond.operands[0];\n\n        switch (typeof x) {\n        case 'object':\n            if (x === null) {\n                // NOTE: never reach here.\n                // NOTE: Nothing to do.\n            } else if (Array.isArray(x)) {\n                // NOTE: Nothing to do. It is data.\n            } else {\n                switch (x.type) {\n                case 'field':\n                    if (! isEqualComplexName(name, x.name.slice(0, x.name.length - 1))) {\n                        return ({\n                            type: 'condition',\n                            op: 'true',\n                            operands: [],\n                        });\n                    } else {\n                        x.name = x.name.slice(x.name.length - 1);\n                    }\n                    break;\n                case 'fncall':\n                    {\n                        const tmp = pruneConditionCheckFncall(name, x);\n                        if (tmp) {\n                            return tmp;\n                        }\n                    }\n                }\n            }\n            break;\n        }\n    }\n\n    return filterCondOperands(name, cond);\n}\n\n\nexport function flatConditions(\n        dest: PreparedCondition[],\n        parentOp: 'and' | 'or' | 'not',\n        cond: PreparedCondition): void {\n\n    const recurse = (op: typeof parentOp, x: PreparedCondition) => {\n        const c: PreparedCondition[] = [];\n        flatConditions(c, op, x);\n        x.operands = c;\n        if ((op === 'and' || op === 'or') && c.length === 1) {\n            dest.push(c[0]);\n        } else {\n            dest.push(x);\n        }\n    };\n\n    const pushOperands = () => {\n        for (const x of cond.operands) {\n            switch (typeof x) {\n            case 'object':\n                if (x === null || Array.isArray(x)) {\n                    throw new Error(`Unexpected AST is found.`);\n                } else {\n                    switch (x.type) {\n                    case 'condition':\n                        switch (x.op) {\n                        case 'and': case 'or': case 'not':\n                            if (x.op !== 'not' && x.op === parentOp) {\n                                flatConditions(dest, x.op, x);\n                            } else {\n                                recurse(x.op, x);\n                            }\n                            break;\n                        default:\n                            dest.push(x);\n                            break;\n                        }\n                        break;\n                    default:\n                        throw new Error(`Unexpected AST ${x.type} is found.`);\n                    }\n                }\n                break;\n            default:\n                throw new Error(`Unexpected AST is found.`);\n            }\n        }\n    };\n\n    switch (cond.op) {\n    case 'and': case 'or': case 'not':\n        if (cond.op === parentOp) {\n            pushOperands();\n        } else {\n            recurse(cond.op, cond);\n        }\n        break;\n    default:\n        dest.push(cond);\n        break;\n    }\n}\n\n\nfunction getParameterValueDenyArray(\n        ctx: Pick<ResolverContext, 'params'>, x: PreparedParameterizedValue):\n        PreparedAtomValue {\n\n    if (! Object.prototype.hasOwnProperty.call(ctx.params, x.name)) {\n        throw new Error(`Parameter '${x.name}' is not found.`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const z = ctx.params![x.name] ?? null;\n    if (Array.isArray(z)) {\n        throw new Error(`Parameter '${x.name}' items should be atom.`);\n    }\n    return z;\n}\n\n\nfunction getParameterValueAllowArray(\n        ctx: Pick<ResolverContext, 'params'>, x: PreparedParameterizedValue):\n        PreparedAtomValue | PreparedAtomValue[] {\n\n    if (! Object.prototype.hasOwnProperty.call(ctx.params, x.name)) {\n        throw new Error(`Parameter '${x.name}' is not found.`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const z = ctx.params![x.name] ?? null;\n    if (Array.isArray(z)) {\n        return z;\n    }\n    return z;\n}\n\n\nfunction filterIndexFieldCondOperands(\n        ctx: Pick<ResolverContext, 'params'>,\n        cond: PreparedCondition, indexFieldNamesI: string[]) {\n\n    cond.operands = cond.operands\n    .map(x => {\n        switch (typeof x) {\n        case 'object':\n            if (Array.isArray(x)) {\n                return x.map(w => {\n                    if (w !== null && typeof w === 'object' && w.type === 'parameter') {\n                        return getParameterValueDenyArray(ctx, w);\n                    } else {\n                        return w;\n                    }\n                });\n            } else {\n                if (x === null) {\n                    // NOTE: never reach here.\n                    return x;\n                }\n                switch (x.type) {\n                case 'condition':\n                    return pruneNonIndexFieldConditions(ctx, x, indexFieldNamesI);\n                default:\n                    return x;\n                }\n            }\n        default:\n            return x;\n        }\n    })\n    .filter(x => {\n        switch (typeof x) {\n        case 'object':\n            if (x !== null && !Array.isArray(x) && x.type === 'condition') {\n                return filterZeroLengthCondFn(x);\n            }\n        }\n        return true;\n    });\n\n    return cond;\n}\n\n\nexport function pruneNonIndexFieldConditions(\n        ctx: Pick<ResolverContext, 'params'>,\n        cond: PreparedCondition, indexFieldNamesI: string[]): PreparedCondition {\n\n    if (cond.operands.length) {\n        {\n            const x = cond.operands[0];\n            switch (typeof x) {\n            case 'object':\n                if (x === null || Array.isArray(x)) {\n                    return ({\n                        type: 'condition',\n                        op: 'true',\n                        operands: [],\n                    });\n                } else {\n                    switch (x.type) {\n                    case 'field':\n                        if (! indexFieldNamesI.includes(x.name[x.name.length - 1].toLowerCase())) {\n                            return ({\n                                type: 'condition',\n                                op: 'true',\n                                operands: [],\n                            });\n                        }\n                        break;\n                    case 'fncall':\n                        return ({\n                            type: 'condition',\n                            op: 'true',\n                            operands: [],\n                        });\n                    }\n                }\n                break;\n            default:\n                return ({\n                    type: 'condition',\n                    op: 'true',\n                    operands: [],\n                });\n            }\n        }\n\n        {\n            const y = cond.operands[1];\n            switch (typeof y) {\n            case 'object':\n                if (y === null || Array.isArray(y)) {\n                    // NOTE: Nothing to do.\n                } else {\n                    switch (y.type) {\n                    case 'fncall': case 'subquery':\n                        return ({\n                            type: 'condition',\n                            op: 'true',\n                            operands: [],\n                        });\n                    case 'parameter':\n                        return filterIndexFieldCondOperands(ctx, {\n                            type: 'condition',\n                            op: cond.op,\n                            operands: [\n                                cond.operands[0],\n                                getParameterValueAllowArray(ctx, y),\n                                ...cond.operands.slice(2),\n                            ],\n                        }, indexFieldNamesI);\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    return filterIndexFieldCondOperands(ctx, cond, indexFieldNamesI);\n}\n\n\nexport function getSqlConditionStringImpl(\n        ctx: Pick<ResolverContext, 'params'>,\n        cond: PreparedCondition, dialect: SqlDialect): string {\n\n    switch (cond.op) {\n    case 'not':\n        return (\n            // NOTE: It is unsafe, but compiler do not generate invalid condition tree.\n            //       `x` should be `PreparedCondition`.\n            `(not ${getSqlConditionStringImpl(ctx, cond.operands[0] as PreparedCondition, dialect)})`\n        );\n    case 'and': case 'or':\n        return (\n            `(${cond.operands\n                // NOTE: It is unsafe, but compiler do not generate invalid condition tree.\n                //       `x` should be `PreparedCondition`.\n                .map(x => getSqlConditionStringImpl(ctx, x as PreparedCondition, dialect))\n                .join(` ${cond.op} `)})`\n        );\n    case 'true': case 'includes': case 'excludes':\n        return '(1=1)';\n    }\n\n    let notSupported = false;\n\n    const getArrayValue: (x: Array<PreparedAtomValue | PreparedParameterizedValue>) => string = (x) => {\n        return (\n            x.map(w => {\n                if (w === null) {\n                    return 'null';\n                } else {\n                    switch (typeof w) {\n                    case 'object':\n                        switch (w.type) {\n                        case 'date': case 'datetime':\n                            return `'${w.value}'`;\n                        case 'parameter':\n                            return getEscapedParamValue(w, false);\n                        default:\n                            notSupported = true;\n                            return '';\n                        }\n                    case 'string':\n                        return `'${dialect.escapeString(w)}'`;\n                    default:\n                        return w.toString();\n                    }\n                }\n            }).join(',')\n        );\n    };\n\n    const getEscapedParamValue = (x: PreparedParameterizedValue, allowArray: boolean) => {\n        const z = (allowArray ? getParameterValueAllowArray : getParameterValueDenyArray)(ctx, x);\n        if (z === null) {\n            return 'null';\n        } else {\n            switch (typeof z) {\n            case 'object':\n                if (Array.isArray(z)) {\n                    return `(${getArrayValue(z)})`;\n                } else {\n                    return `'${z.value}'`;\n                }\n            case 'string':\n                return `'${dialect.escapeString(z)}'`;\n            default:\n                return String(z);\n            }\n        }\n    };\n\n    const operands = cond.operands.map(x => {\n        switch (typeof x) {\n        case 'object':\n            if (Array.isArray(x)) {\n                return `(${getArrayValue(x)})`;\n            } else {\n                if (x === null) {\n                    return 'null';\n                } else {\n                    switch (x.type) {\n                    case 'field':\n                        return dialect.fieldName(x.name[x.name.length - 1]);\n                    case 'date': case 'datetime':\n                        return `'${x.value}'`;\n                    case 'parameter':\n                        return getEscapedParamValue(x, true);\n                    default:\n                        notSupported = true;\n                        return '';\n                    }\n                }\n            }\n        case 'string':\n            return `'${dialect.escapeString(x)}'`;\n        default:\n            return x.toString();\n        }\n    });\n\n    if (notSupported) {\n        return '(1=1)';\n    } else {\n        let op: string = cond.op;\n        if (operands[1] === 'null') {\n            switch (cond.op) {\n            case '=':\n                op = 'is';\n                break;\n            case '!=':\n                op = 'is not';\n                break;\n            }\n        }\n        return `${String(operands[0])} ${op} ${String(operands[1])}`;\n    }\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ResolverContext,\n         FieldResultType,\n         QueryFuncInfo,\n         PreparedConditionOperand,\n         PreparedCondition,\n         PreparedFnCall } from '../types';\n\n\n\nexport interface CondOp1CacheValue {\n    isField: boolean,\n    isDateOrDatetime: boolean,\n    op: PreparedConditionOperand,\n    op2FieldResultType: FieldResultType,\n    fnInfo: QueryFuncInfo | null,\n    fn: (fieldNameMap: Map<string, string>, ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        cache: CondOp1CacheValue, record: any) => any,\n}\n\nexport interface MemoizedValue {\n    value: any,\n}\n\n\nexport const condOp1FnCache = new WeakMap<PreparedCondition, CondOp1CacheValue>();\n\nexport const condOp2ValueCache = new WeakMap<PreparedCondition, MemoizedValue>();\n\nexport const nestedFnInfoCache = new WeakMap<PreparedFnCall, QueryFuncInfo>();\n\nexport const memoizedFnCache = new WeakMap<PreparedFnCall['args'], MemoizedValue>();\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { FieldResultType,\n         PreparedFnCall,\n         ResolverContext,\n         ScalarQueryFuncInfo,\n         ImmediateScalarQueryFuncInfo,\n         AggregateQueryFuncInfo } from '../types';\nimport { getObjectValue }         from './util';\nimport { nestedFnInfoCache,\n         memoizedFnCache }        from './cache';\n\n\n\nexport function callScalarFunction(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        field: PreparedFnCall, fnInfo: ScalarQueryFuncInfo, fieldResultType: FieldResultType,\n        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n        record: any, groupedRecs: any[] | null): any {\n\n    const args = field.args.map(a => {\n        switch (typeof a) {\n        case 'object':\n            if (a === null) {\n                return a;\n            }\n            switch (a.type) {\n            case 'field':\n                {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    let z = getObjectValue(record, a.name[a.name.length - 1]);\n                    switch (fieldResultType) {\n                    case 'date': case 'datetime':\n                        z = new Date(z).getTime();\n                        break;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return z;\n                }\n            case 'date': case 'datetime':\n                switch (fieldResultType) {\n                case 'date': case 'datetime':\n                    return new Date(a.value).getTime();\n                default:\n                    return a.value;\n                }\n            case 'parameter':\n                {\n                    if (! Object.prototype.hasOwnProperty.call(ctx.params, a.name)) {\n                        throw new Error(`Parameter '${a.name}' is not found.`);\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const z = ctx.params![a.name] ?? null;\n                    if (z === null) {\n                        return null;\n                    }\n                    switch (fieldResultType) {\n                    case 'date': case 'datetime':\n                        if (Array.isArray(z)) {\n                            throw new Error(`Parameter '${a.name}' should be string, number, or boolean.`);\n                        }\n                        switch (typeof z) {\n                        case 'object':\n                            return new Date(z.value).getTime();\n                        case 'boolean':\n                            return new Date(Number(z)).getTime();\n                        default:\n                            return new Date(z).getTime();\n                        }\n                    default:\n                        if (z === null) {\n                            return null;\n                        }\n                        if (typeof z === 'object') {\n                            if (Array.isArray(z)) {\n                                throw new Error(`Parameter '${a.name}' should be string, number, or boolean.`);\n                            }\n                            return z.value;\n                        } else {\n                            return z;\n                        }\n                    }\n                }\n            case 'fncall':\n                {\n                    let argFnInfoTmp = nestedFnInfoCache.get(a);\n                    if (! argFnInfoTmp) {\n                        const argFnNameI = a.fn.toLowerCase();\n                        argFnInfoTmp = ctx.functions.find(x => x.name.toLowerCase() === argFnNameI);\n                    }\n                    const argFnInfo = argFnInfoTmp;\n\n                    switch (argFnInfo?.type) {\n                    case 'aggregate':\n                        if (! groupedRecs) {\n                            throw new Error(`Nested function ${a.fn} is not allowed.`);\n                        }\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return callAggregateFunction(ctx, a, argFnInfo, 'any', groupedRecs);\n                    case 'scalar':\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return callScalarFunction(ctx, a, argFnInfo, 'any', record, groupedRecs);\n                    case 'immediate-scalar':\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return callImmediateScalarFunction(ctx, a, argFnInfo, 'any', record, groupedRecs);\n                    default:\n                        throw new Error(`Nested function ${a.fn} is not allowed.`);\n                    }\n                }\n            default:\n                return a;\n            }\n        default:\n            return a;\n        }\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fnInfo.fn(ctx, args, record);\n}\n\n\nexport function callImmediateScalarFunction(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        field: PreparedFnCall, fnInfo: ImmediateScalarQueryFuncInfo, fieldResultType: FieldResultType,\n        record: any | null, groupedRecs: any[] | null): any {\n\n    const cached = memoizedFnCache.get(field.args);\n    if (cached) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return cached.value;\n    }\n\n    let hasNonImmediate = false;\n    const args = field.args.map(a => {\n        switch (typeof a) {\n        case 'object':\n            if (a === null) {\n                return a;\n            }\n            switch (a.type) {\n            case 'field':\n                throw new Error(`Immediate scalar function should not refer the field (${a.name.join('.')}).`);\n            case 'date': case 'datetime':\n                switch (fieldResultType) {\n                case 'date': case 'datetime':\n                    return new Date(a.value).getTime();\n                default:\n                    return a.value;\n                }\n            case 'parameter':\n                {\n                    hasNonImmediate = true;\n\n                    if (! Object.prototype.hasOwnProperty.call(ctx.params, a.name)) {\n                        throw new Error(`Parameter '${a.name}' is not found.`);\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const z = ctx.params![a.name] ?? null;\n                    if (z === null) {\n                        return null;\n                    }\n                    switch (fieldResultType) {\n                    case 'date': case 'datetime':\n                        if (Array.isArray(z)) {\n                            throw new Error(`Parameter '${a.name}' should be string, number, or boolean.`);\n                        }\n                        switch (typeof z) {\n                        case 'object':\n                            return new Date(z.value).getTime();\n                        case 'boolean':\n                            return new Date(Number(z)).getTime();\n                        default:\n                            return new Date(z).getTime();\n                        }\n                    default:\n                        if (z === null) {\n                            return null;\n                        }\n                        if (typeof z === 'object') {\n                            if (Array.isArray(z)) {\n                                throw new Error(`Parameter '${a.name}' should be string, number, or boolean.`);\n                            }\n                            return z.value;\n                        } else {\n                            return z;\n                        }\n                    }\n                }\n            case 'fncall':\n                {\n                    if (groupedRecs !== null || record !== null) {\n                        hasNonImmediate = true;\n                    }\n\n                    let argFnInfoTmp = nestedFnInfoCache.get(a);\n                    if (! argFnInfoTmp) {\n                        const argFnNameI = a.fn.toLowerCase();\n                        argFnInfoTmp = ctx.functions.find(x => x.name.toLowerCase() === argFnNameI);\n                    }\n                    const argFnInfo = argFnInfoTmp;\n\n                    switch (argFnInfo?.type) {\n                    case 'aggregate':\n                        if (groupedRecs === null) {\n                            throw new Error(`Nested function ${a.fn} is not allowed.`);\n                        }\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return callAggregateFunction(ctx, a, argFnInfo, 'any', groupedRecs);\n                    case 'scalar':\n                        if (record === null) {\n                            throw new Error(`Nested function ${a.fn} is not allowed.`);\n                        }\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return callScalarFunction(ctx, a, argFnInfo, 'any', record, groupedRecs);\n                    case 'immediate-scalar':\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return callImmediateScalarFunction(ctx, a, argFnInfo, 'any', record, groupedRecs);\n                    default:\n                        throw new Error(`Nested function ${a.fn} is not allowed.`);\n                    }\n                }\n            default:\n                return a;\n            }\n        default:\n            return a;\n        }\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const ret = fnInfo.fn(ctx, args);\n\n    if (! hasNonImmediate) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        memoizedFnCache.set(field.args, { value: ret });\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return ret;\n}\n\n\nexport function callAggregateFunction(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        field: PreparedFnCall, fnInfo: AggregateQueryFuncInfo, fieldResultType: FieldResultType, records: any[]): any {\n\n    const args = field.args.map(a => {\n        switch (typeof a) {\n        case 'object':\n            if (a === null) {\n                return a;\n            }\n            switch (a.type) {\n            case 'field':\n                {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    let z = records.map(w => getObjectValue(w, a.name[a.name.length - 1]));\n                    switch (fieldResultType) {\n                    case 'date': case 'datetime':\n                        z = z.map(w => new Date(w).getTime());\n                        break;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return z;\n                }\n            case 'date': case 'datetime':\n                switch (fieldResultType) {\n                case 'date': case 'datetime':\n                    return new Date(a.value).getTime();\n                default:\n                    return a.value;\n                }\n            case 'parameter':\n                {\n                    if (! Object.prototype.hasOwnProperty.call(ctx.params, a.name)) {\n                        throw new Error(`Parameter '${a.name}' is not found.`);\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const z = ctx.params![a.name] ?? null;\n                    if (z === null) {\n                        return null;\n                    }\n                    switch (fieldResultType) {\n                    case 'date': case 'datetime':\n                        if (Array.isArray(z)) {\n                            throw new Error(`Parameter '${a.name}' should be string, number, or boolean.`);\n                        }\n                        switch (typeof z) {\n                        case 'object':\n                            return new Date(z.value).getTime();\n                        case 'boolean':\n                            return new Date(Number(z)).getTime();\n                        default:\n                            return new Date(z).getTime();\n                        }\n                    default:\n                        if (z === null) {\n                            return null;\n                        }\n                        if (typeof z === 'object') {\n                            if (Array.isArray(z)) {\n                                throw new Error(`Parameter '${a.name}' should be string, number, or boolean.`);\n                            }\n                            return z.value;\n                        } else {\n                            return z;\n                        }\n                    }\n                }\n            case 'fncall':\n                {\n                    let argFnInfoTmp = nestedFnInfoCache.get(a);\n                    if (! argFnInfoTmp) {\n                        const argFnNameI = a.fn.toLowerCase();\n                        argFnInfoTmp = ctx.functions.find(x => x.name.toLowerCase() === argFnNameI);\n                    }\n                    const argFnInfo = argFnInfoTmp;\n\n                    switch (argFnInfo?.type) {\n                    case 'scalar':\n                        {\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                            const z = records.map(w => callScalarFunction(ctx, a, argFnInfo, 'any', w, records));\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                            return z;\n                        }\n                    case 'immediate-scalar':\n                        {\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                            const z = records.map(w => callImmediateScalarFunction(ctx, a, argFnInfo, 'any', w, records));\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                            return z;\n                        }\n                    default:\n                        throw new Error(`Nested function ${a.fn} is not allowed.`);\n                    }\n                }\n            default:\n                return a;\n            }\n        default:\n            return a;\n        }\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fnInfo.fn(ctx, args, records);\n}\n\n\nexport function getGroupFieldTrueCaseName(groupFields: Map<string, string>, name: string): string | null {\n    if (groupFields.has(name)) {\n        const trueCaseName = groupFields.get(name);\n        if (trueCaseName) {\n            return trueCaseName;\n        }\n    }\n    return null;\n}\n\n\nexport function isScalarFnCallable(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        groupFields: Map<string, string>, args: PreparedFnCall['args']): boolean {\n\n    for (const a of args) {\n        switch (typeof a) {\n        case 'object':\n            switch (a?.type) {\n            case 'field':\n                {\n                    const trueCaseName = getGroupFieldTrueCaseName(groupFields, a.name[a.name.length - 1]);\n                    if (! trueCaseName) {\n                        return false;\n                    }\n                }\n                break;\n            case 'fncall':\n                {\n                    const argFnNameI = a.fn.toLowerCase();\n                    const argFnInfo = ctx.functions.find(x => x.name.toLowerCase() === argFnNameI);\n                    switch (argFnInfo?.type) {\n                    case 'scalar':\n                        if (! isScalarFnCallable(ctx, groupFields, a.args)) {\n                            return false;\n                        }\n                    }\n                }\n                break;\n            }\n            break;\n        }\n    }\n    return true;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ResolverContext,\n         FieldResultType,\n         PreparedParameterizedValue,\n         PreparedConditionOperand,\n         PreparedCondition,\n         PreparedPrimitiveAtomValue,\n         PreparedAtomValue,\n         PreparedField,\n         PreparedFnCall,\n         ScalarQueryFuncInfo,\n         ImmediateScalarQueryFuncInfo,\n         AggregateQueryFuncInfo,\n         SqlDialect }                     from './types';\nimport { deepCloneObject,\n         getTrueCaseFieldName,\n         getObjectValueWithFieldNameMap,\n         convertPattern }                 from './lib/util';\nimport { flatConditions,\n         pruneNonIndexFieldConditions,\n         getSqlConditionStringImpl }      from './lib/condition';\nimport { callAggregateFunction,\n         callScalarFunction,\n         callImmediateScalarFunction,\n         isScalarFnCallable }             from './lib/call';\nimport { CondOp1CacheValue,\n         condOp1FnCache,\n         condOp2ValueCache }              from './lib/cache';\n\n\n\nconst getOp1Noop = (\n    fieldNameMap: Map<string, string>, ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n    cache: CondOp1CacheValue, record: any) => void 0;\n\n\nconst getOp1AggregateFnValue = (\n        fieldNameMap: Map<string, string>, ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        cache: CondOp1CacheValue, record: any) => {\n\n    const { op, op2FieldResultType, fnInfo } = cache;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callAggregateFunction(\n        ctx, op as PreparedFnCall, fnInfo as AggregateQueryFuncInfo, op2FieldResultType,\n        record);\n}\n\n\nconst getOp1ScalarOnAggFnValue = (\n        fieldNameMap: Map<string, string>, ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        cache: CondOp1CacheValue, record: any) => {\n\n    const { op, op2FieldResultType, fnInfo } = cache;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    const firstRec = record[0];\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-assignment\n    return callScalarFunction(\n        ctx, op as PreparedFnCall, fnInfo as ScalarQueryFuncInfo, op2FieldResultType,\n        firstRec, record);\n}\n\n\nconst getOp1ScalarOnNonAggFnValue = (\n        fieldNameMap: Map<string, string>, ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        cache: CondOp1CacheValue, record: any) => {\n\n    const { op, op2FieldResultType, fnInfo } = cache;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-assignment\n    return callScalarFunction(\n        ctx, op as PreparedFnCall, fnInfo as ScalarQueryFuncInfo, op2FieldResultType,\n        record, null);\n}\n\n\nconst getOp1ImmediateScalarOnAggFnValue = (\n        fieldNameMap: Map<string, string>, ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        cache: CondOp1CacheValue, record: any) => {\n\n    const { op, op2FieldResultType, fnInfo } = cache;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-assignment\n    return callImmediateScalarFunction(\n        ctx, op as PreparedFnCall, fnInfo as ImmediateScalarQueryFuncInfo, op2FieldResultType,\n        null, record);\n}\n\n\nconst getOp1ImmediateScalarOnNonAggFnValue = (\n        fieldNameMap: Map<string, string>, ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        cache: CondOp1CacheValue, record: any) => {\n\n    const { op, op2FieldResultType, fnInfo } = cache;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-assignment\n    return callImmediateScalarFunction(\n        ctx, op as PreparedFnCall, fnInfo as ImmediateScalarQueryFuncInfo, op2FieldResultType,\n        record,  null);\n}\n\n\nfunction createOp1Cache(\n    groupFields: Map<string, string> | null,\n    isAggregation: boolean,\n    ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n    cond: PreparedCondition) {\n\n    let cache: CondOp1CacheValue | undefined = condOp1FnCache.get(cond);\n    const op = cond.operands[0];\n    const op2 = cond.operands[1];\n    let op2IsDateOrDatetime = false;\n    let op2FieldResultType: FieldResultType = 'any';\n\n    switch (typeof op2) {\n    case 'object':\n        if (op2 === null) {\n            // nothing to do\n        } else if (Array.isArray(op2)) {\n            // nothing to do\n        } else {\n            switch (op2.type) {\n            case 'date': case 'datetime':\n                op2IsDateOrDatetime = true;\n                op2FieldResultType = op2.type;\n                break;\n            }\n        }\n    }\n\n    switch (typeof op) {\n    case 'object':\n        if (op === null) {\n            // nothing to do (v is null)\n        } else if (Array.isArray(op)) {\n            throw new Error(`Array is not allowed in the operand(1).`);\n        } else {\n            switch (op.type) {\n            case 'field':\n                cache = {\n                    isField: true,\n                    isDateOrDatetime: op2IsDateOrDatetime,\n                    op,\n                    op2FieldResultType,\n                    fnInfo: null,\n                    fn: getOp1Noop,\n                };\n                condOp1FnCache.set(cond, cache);\n                break;\n            case 'fncall':\n                {\n                    const fnNameI = op.fn.toLowerCase();\n                    const fnInfo = ctx.functions.find(x => x.name.toLowerCase() === fnNameI);\n\n                    switch (fnInfo?.type) {\n                    case 'aggregate':\n                        if (! isAggregation) {\n                            throw new Error(`Aggregate function ${fnInfo.name} is not allowed.`);\n                        }\n                        cache = {\n                            isField: false,\n                            isDateOrDatetime: false,\n                            op,\n                            op2FieldResultType,\n                            fnInfo,\n                            fn: getOp1AggregateFnValue,\n                        };\n                        condOp1FnCache.set(cond, cache);\n                        break;\n                    case 'scalar':\n                        if (isAggregation) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            if (! isScalarFnCallable(ctx, groupFields!, op.args)) {\n                                throw new Error(`${op.fn} is not allowed. Aggregate function is needed.`);\n                            }\n                            cache = {\n                                isField: false,\n                                isDateOrDatetime: false,\n                                op,\n                                op2FieldResultType,\n                                fnInfo,\n                                fn: getOp1ScalarOnAggFnValue,\n                            };\n                            condOp1FnCache.set(cond, cache);\n                        } else {\n                            cache = {\n                                isField: false,\n                                isDateOrDatetime: false,\n                                op,\n                                op2FieldResultType,\n                                fnInfo,\n                                fn: getOp1ScalarOnNonAggFnValue,\n                            };\n                            condOp1FnCache.set(cond, cache);\n                        }\n                        break;\n                    case 'immediate-scalar':\n                        cache = {\n                            isField: false,\n                            isDateOrDatetime: false,\n                            op,\n                            op2FieldResultType,\n                            fnInfo,\n                            fn: isAggregation\n                                ? getOp1ImmediateScalarOnAggFnValue\n                                : getOp1ImmediateScalarOnNonAggFnValue,\n                        };\n                        condOp1FnCache.set(cond, cache);\n                        break;\n                    default:\n                        throw new Error(`Unexpected type appears in the operand(1).`);\n                    }\n                }\n                break;\n            default:\n                throw new Error(`Unexpected type appears in the operand(1).`);\n            }\n        }\n        break;\n    default:\n        throw new Error(`Unexpected type appears in the operand(1).`);\n    }\n\n    return cache as CondOp1CacheValue;\n}\n\n\nfunction getOp1Value(\n        fieldNameMap: Map<string, string>,\n        groupFields: Map<string, string> | null,\n        isAggregation: boolean,\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        cond: PreparedCondition, record: any) {\n\n    let v = null;\n    const op = cond.operands[0];\n\n    const cache: CondOp1CacheValue = condOp1FnCache.get(cond)\n        ?? createOp1Cache(groupFields, isAggregation, ctx, cond);\n    \n    if (op === null) {\n        // NOTE: `cache` is possibly undefined.\n        // nothing to do (v is null)\n    } else if (Array.isArray(op)) {\n        throw new Error(`Array is not allowed in the operand(1).`);\n    } else if (cache.isField) {\n        // NOTE: Inline expansion\n\n        const { isDateOrDatetime, op } = cache;\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        v = getObjectValueWithFieldNameMap(\n            fieldNameMap, record, (op as PreparedField).name[(op as PreparedField).name.length - 1]);\n\n        if (isDateOrDatetime && v !== null) {\n            v = new Date(v).getTime();\n        }\n    } else {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        v = cache.fn(fieldNameMap, ctx, cache, record);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return v;\n}\n\n\nfunction getOp2Value(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        cond: PreparedCondition, record: any):\n            PreparedPrimitiveAtomValue |\n            Array<PreparedPrimitiveAtomValue> |\n            RegExp |    // for `like`, `not_like`\n            string[][]  // for `include`, `exclude`\n        {\n\n    const cached = condOp2ValueCache.get(cond);\n    if (cached) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return cached.value;\n    }\n\n    const mapArrayItem = (x: PreparedAtomValue | PreparedParameterizedValue) =>{\n        if (x === null) {\n            return null;\n        }\n        switch (typeof x) {\n        case 'object':\n            switch (x.type) {\n            case 'date': case 'datetime':\n                return x.value;\n            case 'parameter':\n                {\n                    if (! Object.prototype.hasOwnProperty.call(ctx.params, x.name)) {\n                        throw new Error(`Parameter '${x.name}' is not found.`);\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const z = ctx.params![x.name] ?? null;\n                    if (Array.isArray(z)) {\n                        throw new Error(`Parameter '${x.name}' items should be atom.`);\n                    }\n                    if (z === null) {\n                        return null;\n                    }\n                    switch (typeof z) {\n                    case 'object':\n                        switch (z.type) {\n                        case 'date': case 'datetime':\n                            return z.value;\n                        default:\n                            return z;\n                        }\n                    default:\n                        return z;\n                    }\n                }\n            }\n            break;\n        default:\n            return x;\n        }\n    };\n\n    let v = null;\n    const op = cond.operands[1];\n\n    switch (typeof op) {\n    case 'object':\n        if (op === null) {\n            // nothing to do (v is null)\n        } else if (Array.isArray(op)) {\n            v = op.map(x => mapArrayItem(x));\n        } else {\n            switch (op.type) {\n            case 'fncall':\n                {\n                    const fnNameI = op.fn.toLowerCase();\n                    const fnInfo = ctx.functions.find(x => x.name.toLowerCase() === fnNameI);\n\n                    switch (fnInfo?.type) {\n                    case 'immediate-scalar':\n                        // NOTE: It is UNSAFE!\n                        v = callImmediateScalarFunction(ctx, op, fnInfo, 'any', null, null) as PreparedPrimitiveAtomValue;\n                        break;\n                    default:\n                        throw new Error(`Unexpected type appears in the operand(2).`);\n                    }\n                }\n                break;\n            default:\n                switch (op.type) {\n                case 'date': case 'datetime':\n                    v = new Date(op.value).getTime();\n                    break;\n                case 'parameter':\n                    {\n                        if (! Object.prototype.hasOwnProperty.call(ctx.params, op.name)) {\n                            throw new Error(`Parameter '${op.name}' is not found.`);\n                        }\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion\n                        const z = ctx.params![op.name] ?? null;\n                        if (Array.isArray(z)) {\n                            v = z.map(w => mapArrayItem(w));\n                        } else if (z !== null && typeof z === 'object' && (z.type === 'date' || z.type === 'datetime')) {\n                            v = z.value;\n                        } else {\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion\n                            v = z;\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error(`Unexpected type appears in the operand(2).`);\n                }\n                break;\n            }\n        }\n        break;\n    default:\n        v = op; // string or number\n        break;\n    }\n\n    switch (cond.op) {\n    case 'like': case 'not_like':\n        if (typeof v !== 'string') {\n            throw new Error(`Operator \"${cond.op}\": operand(2) should be string.`);\n        }\n        v = new RegExp(convertPattern(v), 'i');\n        break;\n    case 'in': case 'not_in':\n        if (! Array.isArray(v)) {\n            throw new Error(`Operator \"${cond.op}\": operand(2) should be array.`);\n        }\n        break;\n    case 'includes': case 'excludes':\n        if (! Array.isArray(v)) {\n            throw new Error(`Operator \"${cond.op}\": operand(2) should be array.`);\n        }\n        v = v.map(x => {\n            if (typeof x !== 'string') {\n                throw new Error(`Operator \"${cond.op}\": operand(2) array items should be string.`);\n            }\n            return x.split(';');\n        });\n        break;\n    }\n\n    condOp2ValueCache.set(cond, { value: v });\n    return v;\n}\n\n\nfunction evalRecursiveCondition(\n        fieldNameMap: Map<string, string>,\n        groupFields: Map<string, string> | null,\n        isAggregation: boolean,\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        w: PreparedConditionOperand, record: any): boolean {\n\n    // NOTE: It is unsafe, but compiler do not generate invalid condition tree.\n    return evalCondition(fieldNameMap, groupFields, isAggregation, ctx, w as any, record);\n\n    // let ret = true;\n    //\n    // switch (typeof w) {\n    // case 'object':\n    //     if (Array.isArray(w)) {\n    //         throw new Error(`Array is not allowed in the condition.`);\n    //     } else {\n    //         if (w === null) {\n    //             throw new Error(`Unexpected type appears in the condition.`);\n    //         }\n    //         switch (w.type) {\n    //         case 'condition':\n    //             ret = evalCondition(fieldNameMap, groupFields, isAggregation, ctx, w, record);\n    //             break;\n    //         default:\n    //             throw new Error(`Unexpected type appears in the condition.`);\n    //         }\n    //     }\n    //     break;\n    // default:\n    //     throw new Error(`Unexpected type appears in the condition.`);\n    // }\n    //\n    // return ret;\n}\n\n\nfunction evalCondition(\n        fieldNameMap: Map<string, string>,\n        groupFields: Map<string, string> | null,\n        isAggregation: boolean,\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        cond: PreparedCondition, record: any): boolean {\n\n    let ret = true;\n\n    EVAL: switch (cond.op) {\n    case 'true':\n        break;\n    case 'and':\n        for (const w of cond.operands) {\n            if (! evalRecursiveCondition(fieldNameMap, groupFields, isAggregation, ctx, w, record)) {\n                ret = false;\n                break EVAL;\n            }\n        }\n        break;\n    case 'or':\n        for (const w of cond.operands) {\n            if (evalRecursiveCondition(fieldNameMap, groupFields, isAggregation, ctx, w, record)) {\n                break EVAL;\n            }\n        }\n        ret = false;\n        break;\n    case 'not':\n        ret = !evalRecursiveCondition(fieldNameMap, groupFields, isAggregation, ctx, cond.operands[0], record);\n        break;\n    default:\n        {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const v1 = getOp1Value(fieldNameMap, groupFields, isAggregation, ctx, cond, record);\n            const v2 = getOp2Value(ctx, cond, record);\n            switch (cond.op) {\n            case '=':\n                if (! (v1 === v2)) {\n                    ret = false;\n                }\n                break;\n            case '!=':\n                if (! (v1 !== v2)) {\n                    ret = false;\n                }\n                break;\n            case '<':\n                if (v1 === null) {\n                    ret = false;\n                    break;\n                }\n                if (v2 === null) {\n                    ret = false;\n                    break;\n                }\n                if (! ((v1 as any) < (v2 as any))) {\n                    ret = false;\n                }\n                break;\n            case '<=':\n                if (v1 === null) {\n                    ret = false;\n                    break;\n                }\n                if (v2 === null) {\n                    ret = false;\n                    break;\n                }\n                if (! ((v1 as any) <= (v2 as any))) {\n                    ret = false;\n                }\n                break;\n            case '>':\n                if (v1 === null) {\n                    ret = false;\n                    break;\n                }\n                if (v2 === null) {\n                    ret = false;\n                    break;\n                }\n                if (! ((v1 as any) > (v2 as any))) {\n                    ret = false;\n                }\n                break;\n            case '>=':\n                if (v1 === null) {\n                    ret = false;\n                    break;\n                }\n                if (v2 === null) {\n                    ret = false;\n                    break;\n                }\n                if (! ((v1 as any) >= (v2 as any))) {\n                    ret = false;\n                }\n                break;\n            case 'like':\n                if (typeof v1 !== 'string') {\n                    ret = false;\n                    break;\n                }\n                if (! (v2 as RegExp).test(v1)) {\n                    ret = false;\n                }\n                break;\n            case 'not_like':\n                if (typeof v1 !== 'string') {\n                    ret = false;\n                    break;\n                }\n                if ((v2 as RegExp).test(v1)) {\n                    ret = false;\n                }\n                break;\n            case 'in':\n                if (! (v2 as PreparedAtomValue[]).filter(w => w !== null).includes(v1)) {\n                    // NOTE: `(null = ?)`, `(? = null)` and `(null = null)` always FALSE.\n                    ret = false;\n                }\n                break;\n            case 'not_in':\n                if (v1 === null) {\n                    // NOTE: Emulate SQL's 'not in'; `(null <> null)` always FALSE.\n                    ret = false;\n                    break;\n                }\n                if ((v2 as PreparedAtomValue[]).includes(null)) {\n                    ret = false;\n                    break;\n                }\n                if ((v2 as PreparedAtomValue[]).includes(v1)) {\n                    ret = false;\n                }\n                break;\n            case 'includes':\n                if (typeof v1 !== 'string') {\n                    ret = false;\n                    break;\n                }\n                ret = false;\n                OUTER: for (const v2Items of (v2 as string[][])) {\n                    const v1Items = v1.split(';');\n                    for (const q of v2Items) {\n                        if (! v1Items.includes(q)) {\n                            continue OUTER;\n                        }\n                    }\n                    ret = true;\n                    break;\n                }\n                break;\n            case 'excludes':\n                if (typeof v1 !== 'string') {\n                    // NOTE: Emulate SQL's 'not in'; `(null <> null)` always FALSE.\n                    ret = false;\n                    break;\n                }\n                {\n                    const v1Items = v1.split(';');\n                    for (const v2Items of (v2 as string[][])) {\n                        let matched = true;\n                        for (const q of v2Items) {\n                            if (! v1Items.includes(q)) {\n                                matched = false;\n                                break;\n                            }\n                        }\n                        if (matched) {\n                            ret = false;\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        break;\n    }\n\n    return ret;\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function applyWhereConditions(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        conds: PreparedCondition[], records: any[]) {\n\n    const ret: any[] = [];\n\n    if (! records.length) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return ret;\n    }\n    const fieldNameMap = new Map<string, string>(Object.keys(records[0]).map(x => [x.toLowerCase(), x]));\n\n    NEXTREC: for (const record of records) {\n        for (const cond of conds) {\n            if (! evalCondition(fieldNameMap, null, false, ctx, cond, record)) {\n                continue NEXTREC;\n            }\n        }\n        ret.push(record);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return ret;\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function applyHavingConditions(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        conds: PreparedCondition[], groupedRecsArray: any[][]) {\n\n    const ret: any[][] = [];\n\n    if (! groupedRecsArray.length) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return ret;\n    }\n    const fieldNameMap = new Map<string, string>(Object.keys(groupedRecsArray[0][0]).map(x => [x.toLowerCase(), x]));\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const firstRec = groupedRecsArray[0][0];\n    const groupFields = new Map<string, string>(\n        ctx.query?.groupBy?.map(w => [w.toLowerCase(), getTrueCaseFieldName(firstRec, w) ?? '']));\n\n    NEXTREC: for (const groupedRecs of groupedRecsArray) {\n        for (const cond of conds) {\n            if (! evalCondition(fieldNameMap, groupFields, true, ctx, cond, groupedRecs)) {\n                continue NEXTREC;\n            }\n        }\n        ret.push(groupedRecs);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return ret;\n}\n\n\nexport function getIndexFieldConditions(\n        ctx: Pick<ResolverContext, 'params'>,\n        conds: PreparedCondition[], indexFieldNames: string[]): PreparedCondition[] {\n\n    const indexFieldNamesI = indexFieldNames.map(x => x.toLowerCase());\n\n    const tmp: PreparedCondition = pruneNonIndexFieldConditions(ctx, {\n        type: 'condition',\n        op: 'and',\n        operands: deepCloneObject(conds),\n    }, indexFieldNamesI);\n\n    const ret: PreparedCondition[] = [];\n    flatConditions(ret, 'and', tmp);\n\n    return ret;\n}\n\n\nexport function getSqlConditionString(\n        ctx: Pick<ResolverContext, 'params'>,\n        conds: PreparedCondition[], dialect: SqlDialect): string {\n\n    return conds.map(x => getSqlConditionStringImpl(ctx, x, dialect)).join(' and ');\n}\n\n\nexport function escapeSqlStringLiteral_Std(s: string): string {\n    return s.replace(/'/g, \"''\");\n}\n\n\nexport function escapeSqlStringLiteral_MySql(s: string): string {\n    return (s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/'/g, \"\\\\'\")\n    );\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { PreparedQuery,\n         PreparedOrderByField }      from './types';\nimport { getTrueCasePathName,\n         getObjectTrueCasePathValue,\n         getObjectPathValue }        from './lib/util';\n\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function sortRecords(query: PreparedQuery, records: any[]) {\n    if (query.orderBy && records.length) {\n        const primaryPathLen = query.from[0].name.length;\n        const orderFields = query.orderBy;\n\n        const direction =\n            (f: PreparedOrderByField, r: number) =>\n                f.direction === 'desc' ? -r : r;\n\n        const fieldAndFNames = orderFields.map(f => ({\n            f,\n            fName: getTrueCasePathName(records[0], f.name.slice(primaryPathLen)),\n        }));\n\n        records = records.sort((a, b) => {\n\n            LOOP: for (let i = 0; i < fieldAndFNames.length; i++) {\n                // eslint-disable-next-line prefer-const\n                let {f, fName} = fieldAndFNames[i];\n\n                let va = null;\n                let vb = null;\n\n                if (fName !== null) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    va = getObjectTrueCasePathValue(a, fName);\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    vb = getObjectTrueCasePathValue(b, fName);\n                } else {\n                    // Fallback (when the child relationship of records[0] is null)\n\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    va = getObjectPathValue(a, f.name.slice(primaryPathLen));\n\n                    fieldAndFNames[i].fName = fName = getTrueCasePathName(b, f.name.slice(primaryPathLen));\n\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    vb = fName !== null ? getObjectTrueCasePathValue(b, fName) : null;\n                }\n\n                if (va === vb) {\n                    continue;\n                }\n                if (va === null) {\n                    return direction(f, f.nulls === 'last' ? 1 : -1); // default is `nulls first`\n                }\n                if (vb === null) {\n                    return direction(f, f.nulls === 'last' ? -1 : 1); // default is `nulls first`\n                }\n\n                switch (typeof va) {\n                case 'number': case 'bigint':\n                    return direction(f, (va as any) - (vb as any));\n                case 'string':\n                    // TODO: date and datetime\n                    return direction(f, va > vb ? 1 : -1);\n                default:\n                    // Ignore this field\n                    continue LOOP;\n                }\n            }\n            return 0;\n        });\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return records;\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport interface ParserInputWithCtx<T extends ArrayLike<T[number]>, C> {\r\n    src: T;\r\n    start: number;\r\n    end: number;\r\n    context: C;\r\n    templateArgs?: any[];       // For \"template strings\". NOTE: For backword compatibility, this is optional.\r\n    templateArgsPos?: number[]; // For \"template strings\". NOTE: For backword compatibility, this is optional.\r\n}\r\nexport type ParserInput<T extends ArrayLike<T[number]>> = ParserInputWithCtx<T, undefined>;\r\nexport type StringParserInputWithCtx<C> = ParserInputWithCtx<string, C>;\r\nexport type StringParserInput = StringParserInputWithCtx<undefined>;\r\n\r\nexport class ParseError<T extends ArrayLike<T[number]>, C, R> extends Error {\r\n    public result: ParserFnFailedResult<T, C, R>;\r\n    constructor(result: ParserFnFailedResult<T, C, R>) {\r\n        super(result.message);\r\n        this.result = result;\r\n    }\r\n}\r\n\r\n\r\nexport function parserInput<T extends ArrayLike<T[number]>>(src: T): ParserInputWithCtx<T, undefined>;\r\nexport function parserInput<T extends ArrayLike<T[number]>, C>(src: T, context: C): ParserInputWithCtx<T, C>;\r\nexport function parserInput<T extends ArrayLike<T[number]>, C>(src: T, context?: C): ParserInputWithCtx<T, C> {\r\n    return ({\r\n        src,\r\n        start: 0,\r\n        end: src.length,\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        context: context as any,\r\n        templateArgs: [],\r\n        templateArgsPos: [],\r\n    });\r\n}\r\n\r\n\r\nexport function templateStringsParserInput<C>(strings: TemplateStringsArray, values: any[], context?: C): ParserInputWithCtx<string, C> {\r\n    const templateArgsPos: number[] = [];\r\n    let pos = 0;\r\n    if (values.length) {\r\n        for (let i = 0; i < strings.length; i++) {\r\n            const x = strings[i];\r\n            if (i < values.length) {\r\n                templateArgsPos.push(pos + x.length);\r\n                pos += x.length + 1;\r\n            }\r\n        }\r\n    }\r\n    const joined = strings.join('\\x00');\r\n    return ({\r\n        src: joined,\r\n        start: 0,\r\n        end: joined.length,\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        context: context as any,\r\n        templateArgs: values,\r\n        templateArgsPos,\r\n    });\r\n}\r\n\r\n\r\n// tslint:disable-next-line: interface-over-type-literal\r\nexport type ParserFnSucceededResult<T extends ArrayLike<T[number]>, C, R> =\r\n    {succeeded: true, next: ParserInputWithCtx<T, C>, tokens: R[]};\r\n\r\n// tslint:disable-next-line: interface-over-type-literal\r\nexport type ParserFnFailedResult<T extends ArrayLike<T[number]>, C, R> =\r\n    {succeeded: false, error: boolean, src: T, pos: number, message: string};\r\n\r\nexport type ParserFnWithCtx<T extends ArrayLike<T[number]>, C, R> =\r\n    (input: ParserInputWithCtx<T, C>) =>\r\n        ParserFnSucceededResult<T, C, R> |\r\n        ParserFnFailedResult<T, C, R>;\r\n\r\nexport type ParserFn<T extends ArrayLike<T[number]>, R> = ParserFnWithCtx<T, undefined, R>;\r\nexport type StringParserFnWithCtx<C, R> = ParserFnWithCtx<string, C, R>;\r\nexport type StringParserFn<R> = StringParserFnWithCtx<undefined, R>;\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { ParserInputWithCtx,\r\n         ParseError,\r\n         parserInput,\r\n         ParserFnFailedResult,\r\n         ParserFnWithCtx } from './types';\r\n\r\n\r\n\r\nfunction getLineAndCol(src: string, pos: number) {\r\n    let line = 1;\r\n    let col = 1;\r\n\r\n    for (let i = 0; i <= pos; i++) {\r\n        switch (src[i]) {\r\n        case '\\r':\r\n            if (src[i + 1] === '\\n') {\r\n                i++;\r\n            }\r\n            // Fall Throught\r\n        case '\\n':\r\n            line++;\r\n            col = 1;\r\n            break;\r\n        default:\r\n            col++;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return ({\r\n        line,\r\n        col,\r\n    });\r\n}\r\n\r\n\r\nexport function formatErrorMessage<T extends ArrayLike<T[number]>, C, R>(\r\n    result: ParserFnFailedResult<T, C, R>): string {\r\n\r\n    let msg = '';\r\n    let src = '';\r\n    if (typeof result.src === 'string') {\r\n        src = (result.src as string).slice(Math.max(result.pos - 5, 0), result.pos + 55); // NOTE: (TS>=4.0) TS2339: Property 'slice' does not exist on type 'never'.\r\n\r\n        let ar = src.split(/\\r\\n|\\n|\\r/);\r\n        ar = ar.slice(0, 1)\r\n            .concat('          ^~~~~~~~')\r\n            .concat(...ar.slice(1));\r\n        src = ar.join('\\n') + '\\n\\n';\r\n\r\n        const lineAndCol = getLineAndCol(result.src, result.pos);\r\n        msg =  (`parse failed at position:${\r\n            result.pos} line:${lineAndCol.line} col:${lineAndCol.col} ${\r\n            result.message ? ` ${result.message}` : ''}\\n     ${src}`);\r\n    } else {\r\n        src = '     (object)\\n          ^~~~~~~~';\r\n        try {\r\n            src = '     ' +\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\r\n                JSON.stringify((result.src as any).slice(Math.max(result.pos - 10, 0), result.pos)) + '\\n          ' +\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\r\n                JSON.stringify((result.src as any).slice(result.pos, result.pos + 1)) + '\\n          ' +\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\r\n                JSON.stringify((result.src as any).slice(result.pos + 1, result.pos + 10));\r\n\r\n            let ar = src.split(/\\r\\n|\\n|\\r/);\r\n            ar = ar.slice(0, 2)\r\n                .concat('          ^~~~~~~~')\r\n                .concat(...ar.slice(2));\r\n            src = ar.join('\\n') + '\\n\\n';\r\n        } catch (e) {\r\n            // Nothing to do.\r\n        }\r\n\r\n        msg = (`parse failed at position:${\r\n            result.pos} ${\r\n            result.message ? ` ${result.message}` : ''}\\n     ${src}`);\r\n    }\r\n    return msg;\r\n}\r\n\r\n\r\nexport function zeroWidth<T extends ArrayLike<T[number]>, C, R>(\r\n        helper?: () => R\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        return ({\r\n            succeeded: true,\r\n            next: {\r\n                src: input.src,\r\n                start: input.start,\r\n                end: input.end,\r\n                context: input.context,\r\n                templateArgs: input.templateArgs,\r\n                templateArgsPos: input.templateArgsPos,\r\n            },\r\n            tokens: helper ? [helper()] : [],\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function zeroWidthError<T extends ArrayLike<T[number]>, C, R>(\r\n        message: string\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        throw new ParseError({\r\n            succeeded: false,\r\n            error: true,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: message || '',\r\n        });\r\n        // return ({\r\n        //     succeeded: false,\r\n        //     error: true,\r\n        //     src: input.src,\r\n        //     pos: input.start,\r\n        //     message: message || '',\r\n        // });\r\n    });\r\n}\r\n\r\n\r\nexport function beginning<T extends ArrayLike<T[number]>, C, R>(\r\n        helper?: () => R\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        return (input.start === 0 ? {\r\n            succeeded: true,\r\n            next: {\r\n                src: input.src,\r\n                start: input.start,\r\n                end: input.end,\r\n                context: input.context,\r\n                templateArgs: input.templateArgs,\r\n                templateArgsPos: input.templateArgsPos,\r\n            },\r\n            tokens: helper ? [helper()] : [],\r\n        } : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: 'operator \"beginning\"',\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function end<T extends ArrayLike<T[number]>, C, R>(\r\n        helper?: () => R\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        return (input.start === input.end ? {\r\n            succeeded: true,\r\n            next: {\r\n                src: input.src,\r\n                start: input.start,\r\n                end: input.end,\r\n                context: input.context,\r\n                templateArgs: input.templateArgs,\r\n                templateArgsPos: input.templateArgsPos,\r\n            },\r\n            tokens: helper ? [helper()] : [],\r\n        } : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: 'operator \"end\"',\r\n        });\r\n    });\r\n}\r\n\r\n// TODO: match by callback function parser\r\n// TODO: `nesting` parser\r\n\r\n\r\nexport function quantify<T extends ArrayLike<T[number]>, C, R>(\r\n        min?: number, max?: number\r\n        ): (parser: ParserFnWithCtx<T, C, R>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    min = min || 0;\r\n    return (parser => {\r\n        return (input => {\r\n            let next = input;\r\n            const matched: Array<{next: ParserInputWithCtx<T, C>, tokens: R[]}> = [];\r\n\r\n            for (;;) {\r\n                const x = parser(next);\r\n                if (x.succeeded) {\r\n                    next = x.next;\r\n                    matched.push({next: x.next, tokens: x.tokens});\r\n                    if (max && max === matched.length) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (x.error) {\r\n                        return x;\r\n                    }\r\n                    if (matched.length >= (min as number)) {\r\n                        break;\r\n                    } else {\r\n                        return ({\r\n                            succeeded: false,\r\n                            error: false,\r\n                            src: next.src,\r\n                            pos: next.start,\r\n                            message: 'operator \"quantify\"',\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (matched.length > 0) {\r\n                const r: R[] = [];\r\n                for (const x of matched) {\r\n                    r.push(...x.tokens);\r\n                }\r\n                return ({\r\n                    succeeded: true,\r\n                    next: (matched[matched.length - 1]).next,\r\n                    tokens: r,\r\n                });\r\n            } else {\r\n                return ({\r\n                    succeeded: true,\r\n                    next: {\r\n                        src: input.src,\r\n                        start: input.start,\r\n                        end: input.end,\r\n                        context: input.context,\r\n                        templateArgs: input.templateArgs,\r\n                        templateArgsPos: input.templateArgsPos,\r\n                    },\r\n                    tokens: [],\r\n                });\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function first<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        let matched: {next: ParserInputWithCtx<T, C>, tokens: R[]} | null = null;\r\n\r\n        let last: ParserFnFailedResult<T, C, R> | null = null;\r\n        for (const parser of parsers) {\r\n            const x = parser(input);\r\n            if (x.succeeded) {\r\n                matched = {next: x.next, tokens: x.tokens};\r\n                break;\r\n            }\r\n            if (last) {\r\n                if (x.error) {\r\n                    if (!last.error || last.pos < x.pos) {\r\n                        last = x;\r\n                    }\r\n                } else if (last.pos < x.pos) {\r\n                    last = x;\r\n                }\r\n            } else {\r\n                last = x;\r\n            }\r\n        }\r\n\r\n        return (matched ? {\r\n            succeeded: true, next: matched.next, tokens: matched.tokens\r\n        } : last ? last : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: 'operator \"first\"',\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function or<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        const matched: Array<{next: ParserInputWithCtx<T, C>, tokens: R[]}> = [];\r\n\r\n        let last: ParserFnFailedResult<T, C, R> | null = null;\r\n        for (const parser of parsers) {\r\n            const x = parser(input);\r\n            if (x.succeeded) {\r\n                matched.push({next: x.next, tokens: x.tokens});\r\n            } else {\r\n                if (last) {\r\n                    if (x.error) {\r\n                        if (!last.error || last.pos < x.pos) {\r\n                            last = x;\r\n                        }\r\n                    } else if (last.pos < x.pos) {\r\n                        last = x;\r\n                    }\r\n                } else {\r\n                    last = x;\r\n                }\r\n            }\r\n        }\r\n        if (matched.length > 0) {\r\n            const z = matched.reduce((a, b) => a.next.start >= b.next.start ? a : b);\r\n            return ({succeeded: true, next: z.next, tokens: z.tokens});\r\n        }\r\n\r\n        return (last ? last : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: 'operator \"or\"',\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function transform<T extends ArrayLike<T[number]>, C, R>(\r\n        trans?: ((tokens: R[], input: ParserInputWithCtx<T, C>) => R[]), ctxTrans?: ((context: C) => C)\r\n        ): (...parsers: Array<ParserFnWithCtx<T, C, R>>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return ((...parsers) => {\r\n        return (input => {\r\n            let next = input;\r\n            const tokens: R[] = [];\r\n\r\n            for (const parser of parsers) {\r\n                const x = parser(next);\r\n                if (! x.succeeded) {\r\n                    return x;\r\n                }\r\n                next = x.next;\r\n                tokens.push(...x.tokens);\r\n            }\r\n\r\n            // TODO: report errors while transforming\r\n            const t2 = trans ? trans(tokens, input) : tokens;\r\n            return ({\r\n                succeeded: true,\r\n                next: ctxTrans ? {\r\n                    src: next.src,\r\n                    start: next.start,\r\n                    end: next.end,\r\n                    context: ctxTrans(next.context),\r\n                    templateArgs: next.templateArgs,\r\n                    templateArgsPos: next.templateArgsPos,\r\n                } : next,\r\n                tokens: t2,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function combine<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return transform<T, C, R>()(...parsers);\r\n}\r\n\r\n\r\nexport function lookAhead<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        let next = input;\r\n\r\n        for (const parser of parsers) {\r\n            const x = parser(next);\r\n            if (! x.succeeded) {\r\n                return x;\r\n            }\r\n            next = x.next;\r\n        }\r\n\r\n        return ({\r\n            succeeded: true,\r\n            next: input,\r\n            tokens: [],\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function lookBehind<T extends ArrayLike<T[number]>, C, R>(\r\n        n: number, helper?: () => R): (\r\n            ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n            ) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return ((...parsers) => {\r\n        return (input => {\r\n            if (input.start - n < 0) {\r\n                return ({\r\n                    succeeded: false,\r\n                    error: false,\r\n                    src: input.src,\r\n                    pos: input.start,\r\n                    message: 'lookBehind: src is too short',\r\n                });\r\n            }\r\n            let next: ParserInputWithCtx<T, C> = {\r\n                src: input.src,\r\n                start: input.start - n,\r\n                end: input.end,\r\n                context: input.context,\r\n                templateArgs: input.templateArgs,\r\n                templateArgsPos: input.templateArgsPos,\r\n            };\r\n\r\n            for (const parser of parsers) {\r\n                const x = parser(next);\r\n                if (! x.succeeded) {\r\n                    return x;\r\n                }\r\n                next = x.next;\r\n            }\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: input,\r\n                tokens: helper ? [helper()] : [],\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\n// tslint:disable-next-line: interface-over-type-literal\r\nexport type ApplyProductionRulesArg<T extends ArrayLike<T[number]>, C, R> = {\r\n    rules: Array<ParserFnWithCtx<R[], C, R> |\r\n           {parser: ParserFnWithCtx<R[], C, R>, rtol: boolean}>,\r\n    maxApply?: number,\r\n    check: ParserFnWithCtx<R[], C, R>,\r\n};\r\n\r\nexport function applyProductionRules<T extends ArrayLike<T[number]>, C, R>(\r\n        args: ApplyProductionRulesArg<T, C, R>\r\n        ): (lexer: ParserFnWithCtx<T, C, R>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return (lexer => {\r\n        return (lexerInput => {\r\n            const lexResult = lexer(lexerInput);\r\n            if (! lexResult.succeeded) {\r\n                return lexResult;\r\n            }\r\n\r\n            const input = parserInput<R[], C>(lexResult.tokens, lexerInput.context);\r\n            let next = input;\r\n            let completed = false;\r\n\r\n            if (args.check(next).succeeded) {\r\n                return ({\r\n                    succeeded: true,\r\n                    next: lexResult.next,\r\n                    tokens: lexResult.tokens,\r\n                });\r\n            }\r\n\r\n            completed: for (let i = 0;\r\n                    args.maxApply !== void 0 ? i < args.maxApply : true; i++) {\r\n                let matched = false;\r\n\r\n                rules: for (const rule of args.rules) {\r\n                    const {parser, rtol} =\r\n                        typeof rule === 'function' ?\r\n                            {parser: rule, rtol: false} : rule;\r\n                    const len = next.src.length;\r\n\r\n                    for (let s = 0; s <= len; s++) {\r\n                        const x = parser({\r\n                            src: next.src,\r\n                            start: rtol ? len - s : s,\r\n                            end: next.src.length,\r\n                            context: next.context,\r\n                            templateArgs: next.templateArgs,\r\n                            templateArgsPos: next.templateArgsPos,\r\n                        });\r\n                        if (x.succeeded) {\r\n                            matched = true;\r\n                            const nextSrc = next.src.slice(0, rtol ? len - s : s);\r\n                            nextSrc.push(...x.tokens);\r\n                            nextSrc.push(...next.src.slice(x.next.start));\r\n                            next = {\r\n                                src: nextSrc,\r\n                                start: 0,\r\n                                end: nextSrc.length,\r\n                                context: x.next.context,\r\n                                templateArgs: x.next.templateArgs,\r\n                                templateArgsPos: x.next.templateArgsPos,\r\n                            };\r\n                            if (args.check(next).succeeded) {\r\n                                completed = true;\r\n                                break completed;\r\n                            }\r\n                            break rules;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (! matched) {\r\n                    break;\r\n                }\r\n            }\r\n            if (! completed) {\r\n                if (! args.check(next).succeeded) {\r\n                    throw new ParseError({\r\n                        succeeded: false,\r\n                        error: true,\r\n                        src: input.src,\r\n                        pos: input.start,\r\n                        message: 'The application of production rules was not finished',\r\n                    });\r\n                }\r\n            }\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: lexResult.next,\r\n                tokens: next.src,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function makeProgram<T extends ArrayLike<T[number]>, C, R>(\r\n    parser: ParserFnWithCtx<T, C, R>): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        try {\r\n            return parser(input);\r\n        } catch (e) {\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n            if (e.result) {\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\r\n                return e.result;\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    });\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { StringParserFnWithCtx } from './types';\r\nimport { zeroWidth,\r\n         zeroWidthError,\r\n         beginning,\r\n         end,\r\n         quantify,\r\n         first,\r\n         or,\r\n         transform,\r\n         lookAhead,\r\n         lookBehind,\r\n         ApplyProductionRulesArg,\r\n         applyProductionRules,\r\n         makeProgram } from './parser';\r\n\r\n\r\n\r\nexport function charSequence<C, R>(\r\n        helper: (token: string) => R\r\n        ): (needle: string) => StringParserFnWithCtx<C, R> {\r\n\r\n    return (needle => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n            return (src.startsWith(needle) ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + needle.length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(needle)],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"charSequence(${needle})\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function charClass<C, R>(\r\n        helper: (token: string) => R\r\n        ): (...needles: string[]) => StringParserFnWithCtx<C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n            let index = -1;\r\n\r\n            const succeeded = needles.some((needle, idx) => {\r\n                const matched = src.startsWith(needle);\r\n                if (matched) {\r\n                    index = idx;\r\n                    return true;\r\n                }\r\n            });\r\n\r\n            return (succeeded ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + needles[index].length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(needles[index])],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"charClass(${needles.join(',')})\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function charClassNot<C, R>(\r\n    helper: (token: string) => R\r\n    ): (...needles: string[]) => StringParserFnWithCtx<C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n\r\n            for (const needle of needles) {\r\n                const matched = src.startsWith(needle);\r\n                if (matched) {\r\n                    return ({\r\n                        succeeded: false,\r\n                        error: false,\r\n                        src: input.src,\r\n                        pos: input.start,\r\n                        message: `operator \"charClassNot(${needles.join(',')})\"`,\r\n                    });\r\n                }\r\n            }\r\n            const p = input.src.codePointAt(input.start);\r\n            if (p === void 0) {\r\n                return ({\r\n                    succeeded: false,\r\n                    error: false,\r\n                    src: input.src,\r\n                    pos: input.start,\r\n                    message: `operator \"charClassNot(${needles.join(',')})\"`,\r\n                });\r\n            }\r\n            const c = String.fromCodePoint(p);\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + c.length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(c)],\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function charClassByNeedleFn<C, R>(\r\n        helper: (token: string) => R\r\n        ): (needle: (src: string) => number) => StringParserFnWithCtx<C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    return (needle => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n            const len = needle(src);\r\n\r\n            return (len >= 0 ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + len,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(src.substring(0, len))],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"charClassByNeedleFn\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function templateStringsParam<C, R>(\r\n        criteria: (o: any) => boolean, conv?: (o: any) => any): StringParserFnWithCtx<C, R> {\r\n\r\n    return (input => {\r\n        const src = input.src.slice(input.start, input.start + 1);\r\n        if (src === '\\x00') {\r\n            if (input.templateArgsPos) {\r\n                let argIdx = -1;\r\n                const strIdx = input.templateArgsPos.findIndex((v, i) => {\r\n                    argIdx = i;\r\n                    return v === input.start;\r\n                });\r\n                if (0 <= strIdx) {\r\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion\r\n                    const o = input.templateArgs![argIdx];\r\n                    if (criteria(o)) {\r\n                        return ({\r\n                            succeeded: true,\r\n                            next: {\r\n                                src: input.src,\r\n                                start: input.start + 1,\r\n                                end: input.end,\r\n                                context: input.context,\r\n                                templateArgs: input.templateArgs,\r\n                                templateArgsPos: input.templateArgsPos,\r\n                            },\r\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n                            tokens: [(conv ? conv(o) : o)],\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ({\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: `operator \"stringTemplatesParam()\"`,\r\n        });\r\n    });\r\n}\r\n\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function getStringParsers<C, R>(\r\n        params: {\r\n            rawToToken: (rawToken: string) => R,\r\n            concatTokens: (tokens: R[]) => R[],\r\n        }) {\r\n\r\n    const seq = charSequence<C, R>(params.rawToToken);\r\n    const cls = charClass<C, R>(params.rawToToken);\r\n    const notCls = charClassNot<C, R>(params.rawToToken);\r\n    const clsFn = charClassByNeedleFn<C, R>(params.rawToToken);\r\n    const cat = transform<string, C, R>(params.concatTokens);\r\n    const once = quantify<string, C, R>(1, 1);\r\n    const repeat = quantify<string, C, R>();\r\n    // TODO: reduce unneccessary call for adding types.\r\n    const qty = (min?: number, max?: number) => quantify<string, C, R>(min, max);\r\n    const combine = transform<string, C, R>();\r\n    const erase = transform<string, C, R>(tokens => []);\r\n\r\n    const isAlpha = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            ('A' <= c && c <= 'Z') ||\r\n            ('a' <= c && c <= 'z')) ? c.length : -1);\r\n    });\r\n\r\n    const isUpper = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('A' <= c && c <= 'Z') ? c.length : -1);\r\n    });\r\n\r\n    const isLower = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('a' <= c && c <= 'z') ? c.length : -1);\r\n    });\r\n\r\n    const isNumber = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('0' <= c && c <= '9') ? c.length : -1);\r\n    });\r\n\r\n    const isNonZeroNumber = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('1' <= c && c <= '9') ? c.length : -1);\r\n    });\r\n\r\n    const isBinNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('0' <= c && c <= '1') ? c.length : -1);\r\n    });\r\n\r\n    const isOctNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('0' <= c && c <= '7') ? c.length : -1);\r\n    });\r\n\r\n    const isHexNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            ('A' <= c && c <= 'F') ||\r\n            ('a' <= c && c <= 'f') ||\r\n            ('0' <= c && c <= '9')) ? c.length : -1);\r\n    });\r\n\r\n    const isAlNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            ('A' <= c && c <= 'Z') ||\r\n            ('a' <= c && c <= 'z') ||\r\n            ('0' <= c && c <= '9')) ? c.length : -1);\r\n    });\r\n\r\n    const isSpace = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((' \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e' +\r\n            '\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a' +\r\n            '\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').includes(c) ? c.length : -1);\r\n    });\r\n\r\n    const isSpaceWithinSingleLine = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((' \\f\\t\\v\\u00a0\\u1680\\u180e' +\r\n            '\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a' +\r\n            '\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').includes(c) ? c.length : -1);\r\n    });\r\n\r\n    const isControl = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            (0x0000 <= p && p <= 0x001f) ||\r\n            (0x007f <= p && p <= 0x009f)) ? c.length : -1);\r\n    });\r\n\r\n    const isWord = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ((' \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e' +\r\n              '\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a' +\r\n              '\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').includes(c)) ||\r\n            ((0x0000 <= p && p <= 0x001f) ||\r\n             (0x007f <= p && p <= 0x009f)) ?\r\n            -1 : c.length);\r\n    });\r\n\r\n    const isNewline = cls('\\r\\n', '\\n', '\\r');\r\n\r\n    const isAny = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return c.length;\r\n    });\r\n\r\n\r\n    const binSep =\r\n        first(isBinNum, cls('_'));\r\n    const octSep =\r\n        first(isOctNum, cls('_'));\r\n    const hexSep =\r\n        first(isHexNum, cls('_'));\r\n\r\n    const binaryIntegerNumber = (...prefixes: Array<StringParserFnWithCtx<C, R>>) =>\r\n        combine(erase(first(...prefixes)),\r\n            cat(once(isBinNum), repeat(binSep)), );\r\n    const octalIntegerNumber = (...prefixes: Array<StringParserFnWithCtx<C, R>>) =>\r\n        combine(erase(first(...prefixes)),\r\n            cat(once(isOctNum), repeat(octSep)), );\r\n    const hexIntegerValue = (...prefixes: Array<StringParserFnWithCtx<C, R>>) =>\r\n        combine(erase(first(...prefixes)),\r\n            cat(once(isHexNum), repeat(hexSep)), );\r\n    const decimalIntegerNumber =\r\n        combine(cat(qty(0, 1)(cls('+', '-')),\r\n            first(combine(once(isNonZeroNumber), repeat(first(isNumber, cls('_')))),\r\n                seq('0'), )));\r\n    const bigDecimalIntegerNumber =\r\n        combine(cat(decimalIntegerNumber,\r\n            erase(seq('n')), ));\r\n    const floatingPointNumber =\r\n        combine(cat(qty(0, 1)(cls('+', '-')),\r\n            first(combine(once(isNonZeroNumber), repeat(first(isNumber, cls('_')))),\r\n                seq('0'), ),\r\n            qty(0, 1)(combine(seq('.'),\r\n                qty(1)(first(isNumber, cls('_'))), )),\r\n            qty(0, 1)(combine(cls('E', 'e'), qty(0, 1)(cls('+', '-')),\r\n                first(combine(once(isNonZeroNumber), repeat(isNumber)), seq('0')), ))));\r\n\r\n    // TODO: reduce unneccessary call for adding types.\r\n    return ({\r\n        seq,\r\n        cls,\r\n        notCls,\r\n        clsFn,\r\n        classes: {\r\n            alpha: isAlpha,\r\n            upper: isUpper,\r\n            lower: isLower,\r\n            num: isNumber,\r\n            nonzero: isNonZeroNumber,\r\n            bin: isBinNum,\r\n            oct: isOctNum,\r\n            hex: isHexNum,\r\n            alnum: isAlNum,\r\n            space: isSpace,\r\n            spaceWithinSingleLine: isSpaceWithinSingleLine,\r\n            ctrl: isControl,\r\n            newline: isNewline,\r\n            word: isWord,\r\n            any: isAny,\r\n        },\r\n        numbers: {\r\n            bin: binaryIntegerNumber,\r\n            oct: octalIntegerNumber,\r\n            hex: hexIntegerValue,\r\n            int: decimalIntegerNumber,\r\n            bigint: bigDecimalIntegerNumber,\r\n            float: floatingPointNumber,\r\n        },\r\n        isParam: templateStringsParam,\r\n        cat,\r\n        once,\r\n        repeat,\r\n        qty,\r\n        zeroWidth: (helper?: () => R) => zeroWidth<string, C, R>(helper), // TODO:\r\n        err: (message: string) => zeroWidthError<string, C, R>(message),  // TODO:\r\n        beginning: (helper?: () => R) => beginning<string, C, R>(helper), // TODO:\r\n        end: (helper?: () => R) => end<string, C, R>(helper),             // TODO:\r\n        first: (...parsers: Array<StringParserFnWithCtx<C, R>>) => first<string, C, R>(...parsers), // TODO:\r\n        or: (...parsers: Array<StringParserFnWithCtx<C, R>>) => or<string, C, R>(...parsers),       // TODO:\r\n        combine,\r\n        erase,\r\n        trans: (fn: (tokens: R[]) => R[]) => transform<string, C, R>(fn),                                 // TODO:\r\n        ahead: (...parsers: Array<StringParserFnWithCtx<C, R>>) => lookAhead<string, C, R>(...parsers),   // TODO:\r\n        behind: (n: number, helper?: () => R) => lookBehind<string, C, R>(n, helper),\r\n        rules: (args: ApplyProductionRulesArg<string, C, R>) => applyProductionRules<string, C, R>(args), // TODO:\r\n        makeProgram,\r\n    });\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { ParserFnWithCtx } from './types';\r\nimport { zeroWidth,\r\n         zeroWidthError,\r\n         beginning,\r\n         end,\r\n         quantify,\r\n         first,\r\n         or,\r\n         transform,\r\n         lookAhead,\r\n         lookBehind,\r\n         ApplyProductionRulesArg,\r\n         applyProductionRules,\r\n         makeProgram } from './parser';\r\n\r\n\r\n\r\nexport function objSequence<T extends ArrayLike<T[number]>, C, R>(\r\n        helper: (token: T[number]) => R,\r\n        comparator: (a: T[number], b: T[number]) => boolean,\r\n        ): (needle: T) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return (needle => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n            let matched = true;\r\n\r\n            if (len >= needle.length) {\r\n                for (let i = 0; i < needle.length; i++) {\r\n                    if (! comparator(input.src[input.start + i], needle[i])) {\r\n                        matched = false;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                matched = false;\r\n            }\r\n\r\n            return (matched ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + needle.length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(needle)],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\r\n                message: `operator \"objSequence(${needle})\"`, // TODO: BUG: `needle` is not stringify correctly.\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function objClass<T extends ArrayLike<T[number]>, C, R>(\r\n        helper: (token: T[number]) => R,\r\n        comparator: (a: T[number], b: T[number]) => boolean,\r\n        ): (...needles: Array<T[number]>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    // NOTE: <T> version `needles` type is `T`.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n            let index = -1;\r\n\r\n            const succeeded = len > 0 ? needles.some((needle, idx) => {\r\n                if (comparator(input.src[input.start], needle)) {\r\n                    index = idx;\r\n                    return true;\r\n                }\r\n            }) : false;\r\n\r\n            return (succeeded ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + 1,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(needles[index])],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"objClass(${needles.join(',')})\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function objClassNot<T extends ArrayLike<T[number]>, C, R>(\r\n    helper: (token: T[number]) => R,\r\n    comparator: (a: T[number], b: T[number]) => boolean,\r\n    ): (...needles: Array<T[number]>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    // NOTE: <T> version `needles` type is `T`.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n\r\n            if (len > 0) {\r\n                for (const needle of needles) {\r\n                    let matched = true;\r\n\r\n                    if (! comparator(input.src[input.start], needle)) {\r\n                        matched = false;\r\n                        break;\r\n                    }\r\n\r\n                    if (matched) {\r\n                        return ({\r\n                            succeeded: false,\r\n                            error: false,\r\n                            src: input.src,\r\n                            pos: input.start,\r\n                            message: `operator \"objClassNot(${needles.join(',')})\"`,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + 1,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(input.src[input.start])],\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function objClassByNeedleFn<T extends ArrayLike<T[number]>, C, R>(\r\n        helper: (token: T[number]) => R,\r\n        comparator: (a: T[number], b: T[number]) => boolean,\r\n        ): (needle: (src: T[number]) => boolean) => ParserFnWithCtx<T, C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    // NOTE: <T> version `needles` type is `T`.\r\n    return (needle => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n            const matched = len > 0 ? needle(input.src[input.start]) : false;\r\n\r\n            return (matched ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + 1,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(input.src[input.start])],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"objClassByNeedleFn\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function getObjectParsers<T extends ArrayLike<T[number]>, C, R>(\r\n        params: {\r\n            rawToToken: (rawToken: T[number]) => R,\r\n            concatTokens: (tokens: R[]) => R[],\r\n            comparator: (a: T[number], b: T[number]) => boolean,\r\n        }) {\r\n\r\n    const clsFn = objClassByNeedleFn<T, C, R>(params.rawToToken, params.comparator);\r\n\r\n    const isAny = clsFn(src => true);\r\n\r\n    // TODO: reduce unneccessary call for adding types.\r\n    return ({\r\n        seq: objSequence<T, C, R>(params.rawToToken, params.comparator),\r\n        cls: objClass<T, C, R>(params.rawToToken, params.comparator),\r\n        notCls: objClassNot<T, C, R>(params.rawToToken, params.comparator),\r\n        clsFn,\r\n        classes: {\r\n            any: isAny,\r\n        },\r\n        cat: transform<T, C, R>(params.concatTokens),\r\n        once: quantify<T, C, R>(1, 1),\r\n        repeat: quantify<T, C, R>(),\r\n        qty: (min?: number, max?: number) => quantify<T, C, R>(min, max), // TODO:\r\n        zeroWidth: (helper?: () => R) => zeroWidth<T, C, R>(helper),      // TODO:\r\n        err: (message: string) => zeroWidthError<T, C, R>(message),       // TODO:\r\n        beginning: (helper?: () => R) => beginning<T, C, R>(helper),      // TODO:\r\n        end: (helper?: () => R) => end<T, C, R>(helper),                  // TODO:\r\n        first: (...parsers: Array<ParserFnWithCtx<T, C, R>>) => first<T, C, R>(...parsers), // TODO:\r\n        or: (...parsers: Array<ParserFnWithCtx<T, C, R>>) => or<T, C, R>(...parsers),       // TODO:\r\n        combine: transform<T, C, R>(),\r\n        erase: transform<T, C, R>(tokens => []),\r\n        trans: (fn: (tokens: R[]) => R[]) => transform<T, C, R>(fn),                            // TODO:\r\n        ahead: (...parsers: Array<ParserFnWithCtx<T, C, R>>) => lookAhead<T, C, R>(...parsers), // TODO:\r\n        behind: (n: number, helper?: () => R) => lookBehind<T, C, R>(n, helper),\r\n        rules: (args: ApplyProductionRulesArg<T, C, R>) => applyProductionRules<T, C, R>(args), // TODO:\r\n        makeProgram,\r\n    });\r\n}\r\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\n// tslint:disable: no-shadowed-variable\n// tslint:disable: function-constructor\n\n\nexport const dummyTargetObject = {};\n\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nexport const { g: globalObj, o: objConstructor, f: funConstructor } = (() => {\n    let globalObj = null;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-implied-eval\n        globalObj = Function('return this')();\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! globalObj) {\n        // Fall back (for CSP, etc...)\n        if (typeof window === 'object' && window) {\n            globalObj = window;\n        } else if (typeof global === 'object' && global) {\n            globalObj = global;\n        } else if (typeof globalThis === 'object' && globalThis) {\n            globalObj = globalThis;\n        } else {\n            globalObj = dummyTargetObject;\n        }\n    }\n\n    // NOTE: ({}).constructor === Object\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let objConstructor: ObjectConstructor = null as any;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        objConstructor = (({}).constructor ?? Object) as any;\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! objConstructor) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        objConstructor = dummyTargetObject as any;\n    }\n\n    // NOTE: ({}).toString.constructor === Function\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let funConstructor: FunctionConstructor = null as any;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        funConstructor = (({}).toString.constructor ?? Function) as any;\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! funConstructor) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        funConstructor = dummyTargetObject as any;\n    }\n\n    return ({\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        g: globalObj, o: objConstructor, f: funConstructor\n    });\n})();\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function isUnsafeVarNames(target: any, varName: string) {\n    if (target === globalObj ||\n        varName === '__proto__' ||\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\n        return true;\n    }\n    if (varName === 'prototype' || varName === 'constructor') {\n        if (target === null || target === void 0 || typeof target === 'function') {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === objConstructor) {\n        if (Object.prototype.hasOwnProperty.call(objConstructor, varName)) {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === funConstructor) {\n        // checking 'call', 'arguments', 'caller', ...\n        let con: any = funConstructor;\n        while (con) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            if (Object.prototype.hasOwnProperty.call(con, varName)) {\n                return true;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n            con = con.__proto__;\n        }\n    }\n    if (typeof target === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        if (! Object.prototype.hasOwnProperty.call(target, varName)) {\n            // function's prototypes' members\n            return true;\n        }\n    }\n    return false;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { parserInput,\n         templateStringsParserInput } from 'fruitsconfits/modules/lib/types';\nimport { formatErrorMessage }         from 'fruitsconfits/modules/lib/parser';\nimport { getStringParsers }           from 'fruitsconfits/modules/lib/string-parser';\nimport { getObjectParsers }           from 'fruitsconfits/modules/lib/object-parser';\nimport { PreparedValue,\n         PreparedFieldListItem,\n         PreparedResolver,\n         PreparedCondition,\n         PreparedOrderByField,\n         ParsedQuery }                from '../types';\nimport { dummyTargetObject,\n         isUnsafeVarNames}            from './protection';\nimport { DatePattern,\n         DateTimePattern }            from './util';\n\n\n\ninterface SxOp {\n    'op': string;\n}\n\ninterface SxSymbol {\n    'symbol': string;\n}\n\ninterface SxObject {\n    'type': /* string */ any;\n}\n\ninterface SxName {\n    'name': /* string */ any[];\n}\n\ntype SxToken =\n    SxSymbol | SxObject | SxName |\n    PreparedValue | PreparedFieldListItem | PreparedResolver |\n    PreparedCondition | PreparedOrderByField | Partial<ParsedQuery> |\n    string | number | boolean | null | SxToken[];\n\ntype Ast = SxToken | SxOp | undefined | Ast[];\n\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface Ctx {}\n\n\nconst $s = getStringParsers<Ctx, Ast>({\n    rawToToken: rawToken => rawToken,\n    concatTokens: tokens => (tokens.length ?\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        [tokens.reduce((a, b) => String(a) + b)] : []),\n});\n\nconst $o = getObjectParsers<Ast[], Ctx, Ast>({\n    rawToToken: rawToken => rawToken,\n    concatTokens: tokens => (tokens.length ?\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        [tokens.reduce((a, b) => String(a) + b)] : []),\n    comparator: (a, b) => a === b,\n});\n\nconst {seq, cls, notCls, clsFn, classes, numbers, isParam, cat,\n       once, repeat, qty, zeroWidth, err, beginning, end,\n       first, or, combine, erase, trans, ahead, rules,\n       makeProgram} = $s;\n\nconst seqI = (x: string) => clsFn(c => c.slice(0, x.length).toLocaleLowerCase() === x ? x.length : -1);\n\n\nconst unaryOp = (op: string, op1: any) => {\n    return {type: 'condition', op, operands: [op1]};\n};\n\nconst binaryOp = (op: string, op1: any, op2: any) => {\n    return {type: 'condition', op, operands: [op1, op2]};\n};\n\nconst isOperator = (v: any, op: string) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (typeof v === 'object' && v.type === 'rawop' && v.op === op) {\n        return true;\n    }\n    return false;\n};\n\nconst isValue = (v: any) => {\n    // TODO: check type\n    return true;\n};\n\n\nconst lineComment =\n    combine(\n        erase(qty(2)(cls('-'))),\n        first(\n            combine(\n                repeat(notCls('\\r\\n', '\\n', '\\r')),\n                first(classes.newline, ahead(end())), ),\n            first(classes.newline, ahead(end())), ));\n\nconst blockComment =\n    combine(\n        seq('/*'),\n            repeat(notCls('*/')),\n            seq('*/'), );\n\nconst commentOrSpace =\n    first(classes.space, lineComment, blockComment);\n\n\nconst reservedKeywords =\n    first(\n        combine(seqI('select'), input => wordBoundary(input)),\n        combine(seqI('from'), input => wordBoundary(input)),\n        combine(seqI('where'), input => wordBoundary(input)),\n        cat(combine(seqI('order'), erase(qty(1)(commentOrSpace)), seqI('by'))),\n        cat(combine(seqI('group'), erase(qty(1)(commentOrSpace)), seqI('by'))),\n        combine(seqI('having'), input => wordBoundary(input)),\n        combine(seqI('offset'), input => wordBoundary(input)),\n        combine(seqI('limit'), input => wordBoundary(input)), );\n\nconst notAheadReservedKeywords =\n    ahead(input => {\n        const result = combine(\n            reservedKeywords,\n            first(\n                qty(1)(commentOrSpace),\n                cls('(', ')', \"'\", '\"', '=', '!', '<', '>'),\n                end(), ))(input);\n        if (result.succeeded) {\n            return ({\n                succeeded: false,\n                error: false,\n                src: input.src,\n                pos: input.start,\n                message: 'Unexpected reserved keyword aheads',\n            });\n        } else {\n            return ({\n                succeeded: true,\n                next: {\n                    src: input.src,\n                    start: input.start,\n                    end: input.end,\n                    context: input.context,\n                },\n                tokens: [],\n            });\n        }\n    });\n\n\nconst isWord = (s: string) => {\n    if (typeof s !== 'string') {\n        return false;\n    }\n    return /^[A-Za-z0-9$_\"]$/.test(s);\n}\n\n\nconst wordBoundary =\n    ahead(input => {\n        let w = false;\n        if (input.src.length === 0) {\n            w = true;\n        } else if (input.start === input.end) {\n            w = isWord(input.src[input.start - 1]);\n        } else if (input.start === 0) {\n            w = isWord(input.src[input.start]);\n        } else {\n            w = (!isWord(input.src[input.start - 1]) && isWord(input.src[input.start])) ||\n                (isWord(input.src[input.start - 1]) && !isWord(input.src[input.start]));\n        }\n        if (w) {\n            return ({\n                succeeded: true,\n                next: {\n                    src: input.src,\n                    start: input.start,\n                    end: input.end,\n                    context: input.context,\n                },\n                tokens: [],\n            });\n        } else {\n            return ({\n                succeeded: false,\n                error: false,\n                src: input.src,\n                pos: input.start,\n                message: 'Expect word break',\n            });\n        }\n    });\n\n\nconst trueValue =\n    trans(tokens => [true])(\n        seqI('true'), wordBoundary);\n\nconst falseValue =\n    trans(tokens => [false])(\n        seqI('false'), wordBoundary);\n\nconst nullValue =\n    trans(tokens => [null])(\n        seqI('null'), wordBoundary);\n\nconst positiveInfinityValue =\n    trans(tokens => [Number.POSITIVE_INFINITY])(\n        qty(0, 1)(seq('+')), seq('Infinity'), wordBoundary);\n\nconst negativeInfinityValue =\n    trans(tokens => [Number.NEGATIVE_INFINITY])(\n        seq('-Infinity'), wordBoundary);\n\nconst nanValue =\n    trans(tokens => [Number.NaN])(\n        seq('NaN'), wordBoundary);\n\n\nconst binaryIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 2)])(\n        numbers.bin(seq('0b')));\n\nconst octalIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 8)])(\n        numbers.oct(seq('0o'), seq('0')));\n\nconst hexIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 16)])(\n        numbers.hex(seq('0x'), seq('0X')));\n\nconst decimalIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 10)])(\n        numbers.int);\n\nconst floatingPointNumberValue =\n    trans(tokens => [Number.parseFloat((tokens as string[])[0].replace(/_/g, ''))])(\n        numbers.float);\n\nconst numberValue =\n    first(octalIntegerValue,\n          hexIntegerValue,\n          binaryIntegerValue,\n          floatingPointNumberValue,\n          decimalIntegerValue,\n          positiveInfinityValue,\n          negativeInfinityValue,\n          nanValue, );\n\n\nconst stringEscapeSeq = first(\n    trans(t => ['\\''])(seq('\\\\\\'')),\n    trans(t => ['\"'])(seq('\\\\\"')),\n    trans(t => ['`'])(seq('\\\\`')),\n    trans(t => ['/'])(seq('\\\\/')),\n    trans(t => ['\\\\'])(seq('\\\\\\\\')),\n    trans(t => [''])(seq('\\\\\\r\\n')),\n    trans(t => [''])(seq('\\\\\\r')),\n    trans(t => [''])(seq('\\\\\\n')),\n    trans(t => ['\\n'])(seq('\\\\n')),\n    trans(t => ['\\n'])(seq('\\\\N')),\n    trans(t => ['\\r'])(seq('\\\\r')),\n    trans(t => ['\\r'])(seq('\\\\R')),\n    trans(t => ['\\v'])(seq('\\\\v')),\n    trans(t => ['\\t'])(seq('\\\\t')),\n    trans(t => ['\\t'])(seq('\\\\T')),\n    trans(t => ['\\b'])(seq('\\\\b')),\n    trans(t => ['\\b'])(seq('\\\\B')),\n    trans(t => ['\\f'])(seq('\\\\f')),\n    trans(t => ['\\f'])(seq('\\\\F')),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 16))])(\n        cat(erase(seq('\\\\u')),\n                qty(4, 4)(classes.hex), )),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 16))])(\n        cat(erase(seq('\\\\u{')),\n                qty(1, 6)(classes.hex),\n                erase(seq('}')), )),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 16))])(\n        cat(erase(seq('\\\\x')),\n                qty(2, 2)(classes.hex), )),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 8))])(\n        cat(erase(seq('\\\\')),\n                qty(3, 3)(classes.oct), )));\n\nconst stringValue =\n    trans(tokens => [tokens[0] ?? ''])(\n        erase(seq(\"'\")),\n            cat(repeat(first(\n                stringEscapeSeq,\n                combine(cls('\\r', '\\n'), err('Line breaks within strings are not allowed.')),\n                notCls(\"'\"), ))),\n        erase(seq(\"'\")), );\n\n\nconst dateValue =\n    trans(tokens => [{type: 'date', value: tokens[0]}])(cat(\n        qty(4, 4)(classes.num),\n        cls('-'),\n        qty(2, 2)(classes.num),\n        cls('-'),\n        qty(2, 2)(classes.num),\n        wordBoundary, ));\n\n\nconst dateTimeValue =\n    trans(tokens => [{type: 'datetime', value: tokens[0]}])(cat(\n        qty(4, 4)(classes.num),\n        cls('-'),\n        qty(2, 2)(classes.num),\n        cls('-'),\n        qty(2, 2)(classes.num),\n        cls('T'),\n        qty(2, 2)(classes.num),\n        cls(':'),\n        qty(2, 2)(classes.num),\n        qty(0, 1)(combine(\n            cls(':'),\n            qty(2, 2)(classes.num), )),\n        first(\n            cls('Z'),\n            combine(\n                first(cls('+'), cls('-')),\n                qty(2, 2)(classes.num),\n                cls(':'),\n                qty(2, 2)(classes.num), )),\n        wordBoundary, ));\n\n\nconst symbolStringValue =\n    trans(tokens => {\n        const sym = tokens[0] ?? '';\n        if (isUnsafeVarNames(dummyTargetObject, sym as string)) {\n            throw new Error(`Unsafe symbol name is appeared: ${sym as string}`);\n        }\n        return [sym];\n    })(\n        erase(seq('\"')),\n            cat(repeat(first(\n                stringEscapeSeq,\n                combine(cls('\\r', '\\n'), err('Line breaks within strings are not allowed.')),\n                notCls('\"'), ))),\n        erase(seq('\"')), );\n\n\nconst symbolName =\n    trans(tokens => {\n        if (isUnsafeVarNames(dummyTargetObject, tokens[0] as string)) {\n            throw new Error(`Unsafe symbol name is appeared: ${tokens[0] as string}`);\n        }\n        return tokens;\n    })(cat(combine(\n        first(classes.alpha, cls('$', '_')),\n        repeat(first(classes.alnum, cls('$', '_'))), )));\n\n\nconst complexSymbolName =\n    trans(tokens => [{name: tokens}])(\n        first(symbolName, symbolStringValue),\n        repeat(combine(\n            erase(repeat(commentOrSpace),\n                  cls('.'),\n                  repeat(commentOrSpace), ),\n            first(symbolName, symbolStringValue), )));\n\n\nconst parameterizedValue =\n    trans(tokens => [{type: 'parameter', name: tokens[0]}])(\n        erase(seq(':')),\n        symbolName, );\n\n\nconst literalValue =\n    first(\n        isParam(o => {\n            switch (typeof o) {\n            case 'number': case 'string': case 'boolean':\n                return true;\n            case 'object':\n                if (o === null) {\n                    return true;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                if ((o as any).type) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                    switch ((o as any).type) {\n                    case 'date':\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                        if (typeof (o as any).value === 'string') {\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                            return DatePattern.test((o as any).value);\n                        }\n                        break;\n                    case 'datetime':\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                        if (typeof (o as any).value === 'string') {\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                            return DateTimePattern.test((o as any).value);\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n            return false;\n        }),\n        dateTimeValue,\n        dateValue,\n        numberValue,\n        stringValue,\n        trueValue,\n        falseValue,\n        nullValue,\n        parameterizedValue, );\n\n\nconst selectFieldFunctionCall =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{fn: tokens[0], args: tokens.slice(1)} as any])(\n        symbolName,\n        erase(repeat(commentOrSpace)),\n        erase(cls('(')),\n        erase(repeat(commentOrSpace)),\n        repeat(first(\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            trans(tokens => [{type: 'fncall', ...(tokens[0] as object)}])(\n                input => selectFieldFunctionCall(input), ),\n            literalValue,\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            trans(tokens => [{type: 'field', ...(tokens[0] as object)}])(\n                complexSymbolName, ))),\n        repeat(combine(\n            erase(repeat(commentOrSpace)),\n            erase(cls(',')),\n            erase(repeat(commentOrSpace)),\n            first(\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                trans(tokens => [{type: 'fncall', ...(tokens[0] as object)}])(\n                    input => selectFieldFunctionCall(input), ),\n                literalValue,\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                trans(tokens => [{type: 'field', ...(tokens[0] as object)}])(\n                    complexSymbolName, )))),\n        erase(repeat(commentOrSpace)),\n        erase(cls(')')), );\n\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-return\nconst subQuery = trans(tokens => [{query: tokens[0]} as any])(\n    erase(cls('('),\n          repeat(commentOrSpace), ),\n    input => selectStatement(input),\n    erase(repeat(commentOrSpace),\n          cls(')'), ));\n\n\nconst listValue = trans(tokens => [tokens])(\n    erase(cls('('),\n          repeat(commentOrSpace), ),\n    literalValue,\n    erase(repeat(commentOrSpace)),\n    repeat(combine(\n        erase(cls(','),\n              repeat(commentOrSpace), ),\n        literalValue, )),\n    erase(repeat(commentOrSpace),\n          cls(')'), ));\n\n\nconst complexSelectFieldName =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            ...(tokens[0] as object),\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            ...{aliasName: (tokens.length > 1 ? tokens[1] as object : null)}} as any])(\n        notAheadReservedKeywords,\n        first(\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            trans(tokens => [{type: 'fncall', ...(tokens[0] as object)}])(\n                selectFieldFunctionCall, ),\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            trans(tokens => [{type: 'field', ...(tokens[0] as object)}])(\n                complexSymbolName, ),\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            trans(tokens => [{type: 'subquery', ...(tokens[0] as object)}])(\n                subQuery, )),\n        first(\n            combine(\n                erase(repeat(commentOrSpace)), // TODO:\n                notAheadReservedKeywords,\n                symbolName, ),\n            zeroWidth(() => null), ));\n\n\nconst selectFieldList =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{select: tokens} as any])(\n        complexSelectFieldName,\n        erase(repeat(commentOrSpace)),\n        repeat(combine(\n            erase(cls(',')),\n            erase(repeat(commentOrSpace)),\n            complexSelectFieldName,\n            erase(repeat(commentOrSpace)), )));\n\n\nconst fromClause =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{from: tokens} as any])(\n        erase(seqI('from')),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/ban-types\n        trans(tokens => [{...(tokens[0] as object), aliasName: tokens[1] ?? null} as any])(\n            erase(qty(1)(commentOrSpace)),\n            notAheadReservedKeywords,\n            complexSymbolName,\n            qty(0, 1)(combine(\n                erase(qty(1)(commentOrSpace)),\n                notAheadReservedKeywords,\n                symbolName, ))),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/ban-types\n        repeat(trans(tokens => [{...(tokens[0] as object), aliasName: tokens[1] ?? null} as any])(\n            erase(repeat(commentOrSpace),\n                  cls(','),\n                  repeat(commentOrSpace), ),\n            notAheadReservedKeywords,\n            complexSymbolName,\n            first(\n                combine(\n                    erase(qty(1)(commentOrSpace)),\n                    notAheadReservedKeywords,\n                    symbolName, ),\n                zeroWidth(() => null), ))));\n\n\nconst conditionalOperator =\n    first(seq('!='),\n          seq('<='),\n          seq('>='),\n          seq('='),\n          seq('<'),\n          seq('>'),\n          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n          trans(tokens => [`${tokens[0]}_${tokens[1]}`])(\n              seqI('not'),\n                  erase(qty(1)(commentOrSpace)),\n                  first(seqI('like'), seqI('in')),\n                  erase(wordBoundary, repeat(commentOrSpace)), ),\n          combine(seqI('like'),\n                  erase(wordBoundary, repeat(commentOrSpace)), ),\n          combine(seqI('in'),\n                  erase(wordBoundary, repeat(commentOrSpace)), ),\n          combine(seqI('includes'),\n                  erase(wordBoundary, repeat(commentOrSpace)), ),\n          combine(seqI('excludes'),\n                  erase(wordBoundary, repeat(commentOrSpace)), ));\n\n\n// production rules:\n//   S -> S \"not\" S\nconst conditionExpressionExprRule3 = $o.trans(tokens => [unaryOp('not', tokens[1])])(\n    $o.clsFn(t => isOperator(t, 'not')),\n    $o.clsFn(t => isValue(t)),\n);\n\n// production rules:\n//   S -> S \"and\" S\nconst conditionExpressionExprRule2 = $o.trans(tokens => [binaryOp('and', tokens[0], tokens[2])])(\n    $o.clsFn(t => isValue(t)),\n    $o.clsFn(t => isOperator(t, 'and')),\n    $o.clsFn(t => isValue(t)),\n);\n\n// production rules:\n//   S -> S \"or\" S\nconst conditionExpressionExprRule1 = $o.trans(tokens => [binaryOp('or', tokens[0], tokens[2])])(\n    $o.clsFn(t => isValue(t)),\n    $o.clsFn(t => isOperator(t, 'or')),\n    $o.clsFn(t => isValue(t)),\n);\n\n\nconst whereFieldExpression =\n    trans(tokens => [{\n            type: 'condition',\n            op: tokens[1],\n            operands: tokens.slice(0, 1).concat(tokens.slice(2))}])(\n        notAheadReservedKeywords,\n        first(\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            trans(tokens => [{type: 'fncall', ...(tokens[0] as object)}])(\n                selectFieldFunctionCall, ),\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            trans(tokens => [{type: 'field', ...(tokens[0] as object)}])(\n                complexSymbolName, )),\n        erase(repeat(commentOrSpace)),\n        conditionalOperator,\n        erase(repeat(commentOrSpace)),\n        first(literalValue,\n              // eslint-disable-next-line @typescript-eslint/ban-types\n              trans(tokens => [{type: 'subquery', ...(tokens[0] as object)}])(\n                  subQuery, ),\n              // eslint-disable-next-line @typescript-eslint/ban-types\n              trans(tokens => [{type: 'fncall', ...(tokens[0] as object)}])(\n                  selectFieldFunctionCall, ),\n              listValue, ));\n\n\nconst whereConditionExpressionInnerRoot =\n    trans(tokens => tokens)(\n        qty(0, 1)(combine(\n            trans(tokens => [{type: 'rawop', op: tokens[0]} as Ast])(seqI('not')),\n            erase(wordBoundary, repeat(commentOrSpace)), )),\n        first(\n            trans(tokens => tokens)(\n                erase(repeat(commentOrSpace)),\n                erase(cls('(')),\n                erase(repeat(commentOrSpace)),\n                input => whereConditionExpression(input),\n                erase(repeat(commentOrSpace)),\n                erase(cls(')')), ),\n            whereFieldExpression, ),\n        repeat(combine(\n            erase(repeat(commentOrSpace)),\n            trans(tokens => [{type: 'rawop', op: tokens[0]} as Ast])(first(seqI('and'), seqI('or'))),\n            erase(wordBoundary, repeat(commentOrSpace)),\n            input => whereConditionExpression(input), )));\n\n\nconst whereConditionExpression = rules({\n    rules: [\n        conditionExpressionExprRule3,\n        conditionExpressionExprRule2,\n        conditionExpressionExprRule1,\n    ],\n    check: $o.combine($o.classes.any, $o.end()),\n})(trans(tokens => tokens)(whereConditionExpressionInnerRoot));\n\n\nconst whereClause =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{where: [tokens[0]]} as any])(\n        erase(repeat(commentOrSpace), wordBoundary),\n        erase(seqI('where')),\n        erase(first(ahead(cls('(')),\n                    qty(1)(commentOrSpace),\n                    combine(repeat(commentOrSpace), wordBoundary), )),\n        whereConditionExpression, );\n\n\nconst groupByClause =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{groupBy: tokens} as any])(\n        erase(repeat(commentOrSpace), wordBoundary),\n        erase(seqI('group'),\n              qty(1)(commentOrSpace),\n              seqI('by'),\n              qty(1)(commentOrSpace), ),\n        symbolName,\n        repeat(combine(\n            erase(repeat(commentOrSpace),\n                  cls(','),\n                  repeat(commentOrSpace), ),\n            symbolName, )));\n\n\nconst havingFieldExpression =\n    trans(tokens => [{\n            type: 'condition',\n            op: tokens[1],\n            operands: tokens.slice(0, 1).concat(tokens.slice(2))}])(\n        notAheadReservedKeywords,\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        trans(tokens => [{type: 'fncall', ...(tokens[0] as object)}])(\n            selectFieldFunctionCall, ),\n        erase(repeat(commentOrSpace)),\n        conditionalOperator,\n        erase(repeat(commentOrSpace)),\n        first(literalValue,\n              // eslint-disable-next-line @typescript-eslint/ban-types\n              trans(tokens => [{type: 'subquery', ...(tokens[0] as object)}])(\n                  subQuery,\n              // eslint-disable-next-line @typescript-eslint/ban-types\n              trans(tokens => [{type: 'fncall', ...(tokens[0] as object)}])(\n                  selectFieldFunctionCall, ),\n              listValue, )));\n\n\nconst havingConditionExpressionInnerRoot =\n    trans(tokens => tokens)(\n        qty(0, 1)(combine(\n            trans(tokens => [{type: 'rawop', op: tokens[0]} as Ast])(seqI('not')),\n            erase(wordBoundary, repeat(commentOrSpace)), )),\n        first(\n            trans(tokens => tokens)(\n                erase(repeat(commentOrSpace)),\n                erase(cls('(')),\n                erase(repeat(commentOrSpace)),\n                input => havingConditionExpression(input),\n                erase(repeat(commentOrSpace)),\n                erase(cls(')')), ),\n            havingFieldExpression, ),\n        repeat(combine(\n            erase(repeat(commentOrSpace)),\n            trans(tokens => [{type: 'rawop', op: tokens[0]} as Ast])(first(seqI('and'), seqI('or'))),\n            erase(wordBoundary, repeat(commentOrSpace)),\n            input => havingConditionExpression(input), )));\n\n\nconst havingConditionExpression = rules({\n    rules: [\n        conditionExpressionExprRule3,\n        conditionExpressionExprRule2,\n        conditionExpressionExprRule1,\n    ],\n    check: $o.combine($o.classes.any, $o.end()),\n})(trans(tokens => tokens)(havingConditionExpressionInnerRoot));\n\n\nconst havingClause =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{having: [tokens[0]]} as any])(\n        erase(repeat(commentOrSpace), wordBoundary),\n        erase(seqI('having')),\n        erase(first(ahead(cls('(')),\n                    qty(1)(commentOrSpace),\n                    combine(repeat(commentOrSpace), wordBoundary), )),\n        havingConditionExpression, );\n\n\nconst orderByDirection =\n    first(\n        qty(1, 1)(combine(\n            erase(qty(1)(commentOrSpace)),\n            trans(tokens => [(tokens[0] as string).toLowerCase()])(first(seqI('asc'), seqI('desc'))),\n            erase(wordBoundary), )),\n        zeroWidth(() => 'asc'), );\n\n\nconst orderByNulls =\n    first(\n        qty(1, 1)(combine(\n            erase(qty(1)(commentOrSpace),\n                seqI('nulls'),\n                qty(1)(commentOrSpace), ),\n            trans(tokens => [(tokens[0] as string).toLowerCase()])(first(seqI('first'), seqI('last'))),\n            erase(wordBoundary), )),\n        zeroWidth(() => 'first'), );\n\n\nconst orderByClause =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{orderBy: tokens} as any])(\n        erase(repeat(commentOrSpace), wordBoundary),\n        erase(seqI('order'),\n              qty(1)(commentOrSpace),\n              seqI('by'),\n              qty(1)(commentOrSpace), ),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/ban-types\n        trans(tokens => [{...(tokens[0] as object), direction: tokens[1], nulls: tokens[2]} as any])(\n            complexSymbolName,\n            orderByDirection,\n            orderByNulls, ),\n        repeat(combine(\n            erase(repeat(commentOrSpace),\n                  cls(','),\n                  repeat(commentOrSpace), ),\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/ban-types\n            trans(tokens => [{...(tokens[0] as object), direction: tokens[1], nulls: tokens[2]} as any])(\n                complexSymbolName,\n                orderByDirection,\n                orderByNulls, ))));\n\n\nconst offsetClause =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{offset: tokens[0]} as any])(\n        erase(repeat(commentOrSpace), wordBoundary),\n        erase(seqI('offset'),\n              qty(1)(commentOrSpace), ),\n        first(\n            decimalIntegerValue,\n            parameterizedValue,\n            isParam(o => typeof o === 'number'), ));\n\n\nconst limitClause =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    trans(tokens => [{limit: tokens[0]} as any])(\n        erase(repeat(commentOrSpace), wordBoundary),\n        erase(seqI('limit'),\n              qty(1)(commentOrSpace), ),\n        first(\n            decimalIntegerValue,\n            parameterizedValue,\n            isParam(o => typeof o === 'number'), ));\n\n\nconst forViewClause =\n    trans(tokens => [{for: (tokens as string[]).map(x => x.toLowerCase())}])(\n        erase(repeat(commentOrSpace), wordBoundary),\n        erase(seqI('for'),\n              qty(1)(commentOrSpace), ),\n        first(\n            combine(seqI('view'),\n                    qty(0, 1)(combine(\n                        erase(repeat(commentOrSpace),\n                              cls(','),\n                              repeat(commentOrSpace), ),\n                        seqI('reference'), ))),\n            combine(seqI('reference'),\n                    qty(0, 1)(combine(\n                        erase(repeat(commentOrSpace),\n                              cls(','),\n                              repeat(commentOrSpace), ),\n                        seqI('view'), )))),\n        erase(wordBoundary), );\n\n\nconst forUpdateClause =\n    trans(tokens => [{for: (tokens as string[]).map(x => x.toLowerCase())}])(\n        erase(repeat(commentOrSpace), wordBoundary),\n        erase(seqI('for'),\n              qty(1)(commentOrSpace), ),\n        seqI('update'),\n        first(\n            combine(erase(qty(1)(commentOrSpace)),\n                    seqI('tracking'),\n                    qty(0, 1)(combine(\n                        erase(repeat(commentOrSpace),\n                              cls(','),\n                              repeat(commentOrSpace), ),\n                        seqI('viewstat'), ))),\n            combine(erase(qty(1)(commentOrSpace)),\n                    seqI('viewstat'),\n                    qty(0, 1)(combine(\n                        erase(repeat(commentOrSpace),\n                              cls(','),\n                              repeat(commentOrSpace), ),\n                        seqI('tracking'), ))),\n            zeroWidth(() => void 0), ),\n        erase(wordBoundary), );\n\n\nconst selectStatement =\n    trans(tokens => {\n        let z = {};\n        for (const t of tokens) {\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            z = {...z, ...(t as object)};\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return [z] as any;\n    })(\n        erase(seqI('select')),\n        erase(qty(1)(commentOrSpace)),\n        selectFieldList,\n        fromClause,\n        // TODO: using scope\n        qty(0, 1)(whereClause),\n        // TODO: with\n        qty(0, 1)(combine(\n            groupByClause,  // TODO: rollup, cube\n            qty(0, 1)(havingClause), )),\n        qty(0, 1)(orderByClause),\n        qty(0, 1)(first(\n            combine(\n                offsetClause,\n                qty(0, 1)(limitClause), ),\n            combine(\n                limitClause,\n                qty(0, 1)(offsetClause), ))),\n        qty(0, 1)(first(forViewClause,\n                        forUpdateClause, )),\n        erase(repeat(commentOrSpace)), );\n\n\nconst program =\n    makeProgram(combine(\n        beginning(),\n        erase(repeat(commentOrSpace)),\n        selectStatement,\n        erase(repeat(commentOrSpace)),\n        end(), ));\n\n\nexport function parse(strings: TemplateStringsArray | string, ...values: any[]): ParsedQuery {\n    // TODO: deny dangerous names\n    const z = program(\n        typeof strings === 'string'\n            ? parserInput(strings, {})\n            : templateStringsParserInput(strings, values, {})\n        );\n\n    if (! z.succeeded) {\n        throw new Error(formatErrorMessage(z));\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return z.tokens[0] as any;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ParsedQuery,\n         PreparedQuery,\n         PreparedField,\n         PreparedFnCall,\n         PreparedFieldListItem,\n         ParsedResolver,\n         PreparedCondition,\n         PreparedOrderByField,\n         ResolverTreeDirection,\n         ResolverTreeNode,\n         QueryBuilderInfoInternal } from '../types';\nimport { isEqualComplexName,\n         getFullQualifiedName,\n         getTrueCaseFieldName }     from './util';\nimport { flatConditions }           from './condition';\n\n\n\nfunction makeResolverTree(\n        builder: QueryBuilderInfoInternal,\n        path: ResolverTreeNode[],\n        args: Pick<ResolverTreeNode, 'fieldOrRelName' | 'resolverName' | 'direction'>): ResolverTreeNode {\n\n    const argResolverNameI = args.resolverName.toLowerCase();\n    const argfieldOrRelNameI = args.fieldOrRelName.toLowerCase();\n    const trueCaseArgResolverName = getTrueCaseFieldName(builder.relationships, args.resolverName);\n\n    if (! trueCaseArgResolverName) {\n        throw new Error(`Resolver '${args.resolverName}' is not found.`);\n    }\n\n    const found = path.find(\n        x => x.resolverName.toLowerCase() === argResolverNameI &&\n        x.fieldOrRelName.toLowerCase() === argfieldOrRelNameI);\n\n    if (found) {\n        return found;\n    }\n\n    const children: ResolverTreeNode[] = [];\n    const ret: ResolverTreeNode = {\n        fieldOrRelName: args.fieldOrRelName,\n        resolverName: trueCaseArgResolverName,\n        // fkeyIdName: '', // TODO:\n        direction: args.direction,\n        children: children,\n    };\n\n    const q = builder.relationships[trueCaseArgResolverName];\n    const nextPath = path.concat([ret]);\n\n    for (const k of Object.keys(q)) {\n        const c = q[k];\n        if (Array.isArray(c)) {\n            children.push(makeResolverTree(builder, nextPath, {\n                resolverName: c[0],\n                fieldOrRelName: k,\n                direction: ResolverTreeDirection.MasterToDetail,\n            }));\n        } else if (typeof c === 'string') {\n            children.push(makeResolverTree(builder, nextPath, {\n                resolverName: c,\n                fieldOrRelName: k,\n                direction: ResolverTreeDirection.DetailsToMaster,\n            }));\n        } else {\n            children.push(makeResolverTree(builder, nextPath, {\n                resolverName: c.resolver,\n                fieldOrRelName: k,\n                direction: ResolverTreeDirection.DetailsToMaster,\n            }));\n        }\n    }\n\n    return ret;\n}\n\n\nfunction findResolver(\n    query: ParsedQuery,\n    x: PreparedField | PreparedOrderByField) {\n\n    const rn = x.name.slice(0, x.name.length - 1);\n    return query.from.find(w => isEqualComplexName(w.name, rn));\n}\n\n\nfunction registerFields(\n        query: ParsedQuery,\n        x: PreparedField | PreparedOrderByField,\n        defaultResolver: ParsedResolver | undefined,\n        fn: (rslv: ParsedResolver) => Set<string>) {\n\n    const resolver = findResolver(query, x) ?? defaultResolver;\n    if (resolver) {\n        fn(resolver).add(x.name[x.name.length - 1]);\n    }\n}\n\n\nfunction recureseForEachConditionFieldsFncall(\n        x: PreparedFnCall,\n        fn: (field: PreparedField | PreparedOrderByField) => void) {\n\n    for (const arg of x.args) {\n        switch (typeof arg) {\n        case 'object':\n            if (arg === null) {\n                // NOTE: Nothing to do.\n            } else {\n                switch (arg.type) {\n                case 'field':\n                    fn(arg);\n                    break;\n                case 'fncall':\n                    recureseForEachConditionFieldsFncall(arg, fn);\n                    break;\n                }\n            }\n            break;\n        }\n    }\n}\n\n\nfunction recureseForEachConditionFields(\n        cond: PreparedCondition,\n        fn: (field: PreparedField | PreparedOrderByField) => void) {\n\n    switch (cond.type) {\n    case 'condition':\n        for (const x of cond.operands) {\n            switch (typeof x) {\n            case 'object':\n                if (x === null) {\n                    // NOTE: never reach here.\n                } else if (Array.isArray(x)) {\n                    // NOTE: Nothing to do. It is data.\n                } else {\n                    switch (x.type) {\n                    case 'condition':\n                        recureseForEachConditionFields(x, fn);\n                        break;\n                    case 'field':\n                        fn(x);\n                        break;\n                    case 'fncall':\n                        for (const arg of x.args) {\n                            switch (typeof arg) {\n                            case 'object':\n                                if (arg === null) {\n                                    // NOTE: Nothing to do.\n                                } else {\n                                    switch (arg.type) {\n                                    case 'field':\n                                        fn(arg);\n                                        break;\n                                    case 'fncall':\n                                        recureseForEachConditionFieldsFncall(arg, fn);\n                                        break;\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        break;\n    }\n\n    return cond;\n}\n\n\nfunction normalize(\n        builder: QueryBuilderInfoInternal, query: ParsedQuery,\n        parentName: string[], parentAliases: Map<string, string[]> | null): PreparedQuery {\n\n    // Check and normalize `from` resolvers\n    const resolverAliases = new Map<string, string[]>(parentAliases ?? []);\n\n    if (parentName.length === 0 && query.from[0].name.length > 1) {\n        throw new Error('Relationship name is not allowed at first item of root level from clause.');\n    }\n\n    {\n        const x = query.from[0];\n        if (query.from[0].name.length > 1) {\n            while (resolverAliases.has(x.name[0].toLowerCase())) { // TODO: set max loop\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                x.name = resolverAliases.get(x.name[0].toLowerCase())!.concat(x.name.slice(1));\n            }\n        }\n        if (parentName.length > 0) {\n            x.name = getFullQualifiedName(parentName, x.name);\n            if (! isEqualComplexName(x.name.slice(0, parentName.length), parentName)) {\n                throw new Error(`Resolver name ${x.name.join('.')} is not match to parent resolver ${parentName.join('.')}`);\n            }\n        }\n    }\n\n    const primaryResolverName = query.from[0].name;\n\n    if (query.from[0].aliasName) {\n        resolverAliases.set(query.from[0].aliasName.toLowerCase(), primaryResolverName);\n    }\n\n    query.whereSubQueries = [];\n    query.havingSubQueries = [];\n    query.selectSubQueries = [];\n\n    for (const x of query.from.slice(1)) {\n        if (x.name.length === 1) {\n            x.name = primaryResolverName.concat(x.name);\n        } else {\n            let nameI = x.name[0].toLowerCase();\n            while (resolverAliases.has(nameI)) { // TODO: set max loop\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                x.name = resolverAliases.get(nameI)!.concat(x.name.slice(1));\n                nameI = x.name[0].toLowerCase();\n            }\n\n            x.name = getFullQualifiedName(primaryResolverName, x.name);\n        }\n        if (x.aliasName) {\n            resolverAliases.set(x.aliasName.toLowerCase(), x.name);\n        }\n    }\n\n    const fieldAliasNames = new Map<string, string[]>();\n    let normalizeTarget: 'select' | 'where' | 'having' | 'orderby' = 'select';\n\n    const normalizeSelectField = (x: PreparedField | PreparedOrderByField) => {\n        // Resolve field alias names\n        switch (normalizeTarget) {\n        case 'select':\n            if ((x as PreparedField).aliasName) {\n                fieldAliasNames.set(\n                    ((x as PreparedField).aliasName as string).toLowerCase(),\n                    x.name\n                );\n            }\n            break;\n        case 'where': case 'having': case 'orderby':\n            if (x.name.length === 1) {\n                const nameI = x.name[0].toLowerCase();\n                if (fieldAliasNames.has(nameI)) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    x.name = fieldAliasNames.get(nameI)!;\n                }\n            }\n            break;\n        }\n\n        // Resolve resolver alias names\n        if (x.name.length === 1) {\n            x.name = primaryResolverName.concat(x.name);\n        } else {\n            let nameI = x.name[0].toLowerCase();\n            while (resolverAliases.has(nameI)) { // TODO: set max loop\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                x.name = resolverAliases.get(nameI)!.concat(x.name.slice(1));\n                nameI = x.name[0].toLowerCase();\n            }\n\n            x.name = getFullQualifiedName(primaryResolverName, x.name);\n\n            const rn = x.name.slice(0, x.name.length - 1);\n            if (! query.from.find(w => isEqualComplexName(w.name, rn))) {\n                query.from.push({\n                    name: rn,\n                    aliasName: null,\n                });\n            }\n        }\n\n        return x;\n    };\n\n    const normalizeFnCall = (x: PreparedFnCall, opIndex: number) => {\n        const fnNameI = x.fn.toLowerCase();\n        const found = builder.functions.find(z => z.name.toLowerCase() === fnNameI);\n        if (! found) {\n            throw new Error(`Function '${x.fn}' is not found.`);\n        }\n\n        switch (normalizeTarget) {\n        case 'select':\n            if (found.type === 'aggregate' && !query.groupBy) {\n                query.groupBy = [];\n            }\n            break;\n        case 'where':\n            if (found.type === 'aggregate') {\n                // NOTE: scalar and immediate-scalar is allowed.\n                throw new Error(`Aggregate function '${x.fn}' is not allowed.`);\n            }\n            if (opIndex !== 0 && found.type !== 'immediate-scalar') {\n                throw new Error(`Function '${x.fn}' is not allowed at operand ${opIndex + 1}.`);\n            }\n            break;\n        case 'having':\n            if (opIndex !== 0 && found.type !== 'immediate-scalar') {\n                throw new Error(`Function '${x.fn}' is not allowed at operand ${opIndex + 1}.`);\n            }\n            break;\n        }\n\n        for (const arg of x.args) {\n            switch (typeof arg) {\n            case 'object':\n                if (arg === null) {\n                    // NOTE: Nothing to do.\n                } else {\n                    switch (arg.type) {\n                    case 'field':\n                        normalizeSelectField(arg);\n                        break;\n                    case 'fncall':\n                        normalizeFnCall(arg, 0); // NOTE: treat as opIndex = 0 (always correct)\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n\n        return x;\n    };\n\n    const normalizeCondition = (cond: PreparedCondition) => {\n        switch (cond.type) {\n        case 'condition':\n            for (let i = 0; i < cond.operands.length; i++) {\n                const x = cond.operands[i];\n                switch (typeof x) {\n                case 'object':\n                    if (x === null) {\n                        // NOTE: never reach here.\n                    } else if (Array.isArray(x)) {\n                        // NOTE: Nothing to do. It is data.\n                    } else {\n                        switch (x.type) {\n                        case 'condition':\n                            normalizeCondition(x);\n                            break;\n                        case 'field':\n                            normalizeSelectField(x);\n                            break;\n                        case 'fncall':\n                            normalizeFnCall(x, i);\n                            break;\n                        case 'subquery':\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            (normalizeTarget === 'where' ?\n                                query.whereSubQueries :\n                                query.havingSubQueries)!.push(x);\n                            x.query = normalize(builder, x.query, [], null);\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n            break;\n        }\n        return cond;\n    };\n\n    // Check and normalize `select` fields\n    for (let i = 0; i < query.select.length; i++) {\n        const x = query.select[i];\n        switch (x.type) {\n        case 'field':\n            normalizeSelectField(x);\n            break;\n        case 'fncall':\n            normalizeFnCall(x, i);\n            break;\n        case 'subquery':\n            query.selectSubQueries.push(x);\n            x.query = normalize(builder, x.query, primaryResolverName, resolverAliases);\n            break;\n        }\n    }\n\n    // Check and normalize `where` fields\n    if (query.where) {\n        normalizeTarget = 'where';\n        normalizeCondition(query.where[0]);\n    }\n\n    // Check and normalize `having` fields\n    if (query.having) {\n        normalizeTarget = 'having';\n        normalizeCondition(query.having[0]);\n    }\n\n    // Check and normalize `orderBy` fields\n    if (query.orderBy) {\n        normalizeTarget = 'orderby';\n        for (const x of query.orderBy) {\n            normalizeSelectField(x);\n        }\n    }\n\n    for (const x of query.from) {\n        x.queryFields = new Set<string>();\n        x.queryFieldsMap = new Map<string, PreparedFieldListItem>();\n        x.condFields = new Set<string>();\n        x.condAliasFields = new Set<string>();\n        x.havingCondFields = new Set<string>();\n        // fieldAliasNames\n        // sortFieldNames\n        x.relationshipIdFields = new Set<string>();\n    }\n\n    const registerQueryFields = (x: PreparedField) =>\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        registerFields(query, x, query.from[0], (rslv: ParsedResolver) => rslv.queryFields!);\n\n    const registerCondFields = (x: PreparedField | PreparedOrderByField) =>\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        registerFields(query, x, query.from[0], (rslv: ParsedResolver) => rslv.condFields!);\n\n    const registerHavingCondFields = (x: PreparedField | PreparedOrderByField) =>\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        registerFields(query, x, query.from[0], (rslv: ParsedResolver) => rslv.havingCondFields!);\n\n    let exprCount = 0;\n\n    const collectFncallQueryFields = (x: PreparedFnCall, nested: boolean) => {\n        if (! nested) {\n            if (! x.aliasName) {\n                x.aliasName = `expr${exprCount++}`; // TODO: Check conflict\n            }\n        }\n        let resolver: ParsedResolver | undefined = void 0;\n        for (const arg of x.args) {\n            switch (typeof arg) {\n            case 'object':\n                if (arg === null) {\n                    // NOTE: Nothing to do.\n                } else {\n                    switch (arg.type) {\n                    case 'field':\n                        registerQueryFields(arg);\n                        if (! resolver) {\n                            // BUG: TODO: Check all arguments are same resolver's field.\n                            resolver = findResolver(query, arg);\n                        }\n                        break;\n                    case 'fncall':\n                        {\n                            const resolverTmp = collectFncallQueryFields(arg, true);\n                            if (! resolver) {\n                                resolver = resolverTmp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        if (! nested) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            (resolver ?? query.from[0]).queryFieldsMap!.set(x.aliasName, x);\n        }\n        return resolver;\n    };\n\n    for (const x of query.select) {\n        switch (x.type) {\n        case 'field':\n            {\n                registerQueryFields(x);\n                const resolver = findResolver(query, x); // TODO: find twice!\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                resolver?.queryFieldsMap!.set(x.name[x.name.length - 1], x);\n            }\n            break;\n        case 'fncall':\n            collectFncallQueryFields(x, false);\n            break;\n        }\n    }\n\n    if (query.where) {\n        recureseForEachConditionFields(query.where[0], registerCondFields);\n    }\n\n    if (query.having) {\n        recureseForEachConditionFields(query.having[0], registerHavingCondFields);\n    }\n\n    if (query.groupBy) {\n        for (const x of query.groupBy) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            query.from[0].havingCondFields!.add(x);\n        }\n    }\n\n    query.from[0].name = primaryResolverName;\n\n    // Check resolvers' paths\n    const primaryResolverRootTrueCaseName = getTrueCaseFieldName(builder.relationships, primaryResolverName[0]);\n    if (! primaryResolverRootTrueCaseName) {\n        throw new Error(`Resolver '${primaryResolverName[0]}' is not found.`);\n    }\n\n    const resolverTree = makeResolverTree(builder, [], {\n        resolverName: primaryResolverRootTrueCaseName,\n        fieldOrRelName: primaryResolverRootTrueCaseName,\n        direction: ResolverTreeDirection.DetailsToMaster,\n    });\n\n    for (const x of query.from) {\n        let rt = [resolverTree];\n        let lastFound: ResolverTreeNode | undefined;\n\n        for (let j = 0; j < x.name.length; j++) {\n            const name = x.name[j];\n            const nameI = name.toLowerCase();\n            const found = rt.find(z => z.fieldOrRelName.toLowerCase() === nameI);\n            if (found) {\n                lastFound = found;\n                rt = found.children;\n                x.name[j] = found.fieldOrRelName; // NOTE: fix case\n            } else {\n                throw new Error(`Resolver '${name}' is not found.`);\n            }\n        }\n\n        if (lastFound) {\n            x.resolver = builder.resolvers.query[lastFound.resolverName];\n            x.resolverName = lastFound.resolverName;\n        }\n    }\n\n    if (query.where) {\n        const c: PreparedCondition[] = [];\n        flatConditions(c, 'and', query.where[0]);\n        query.where = c;\n    }\n    if (query.having) {\n        const c: PreparedCondition[] = [];\n        flatConditions(c, 'and', query.having[0]);\n        query.having = c;\n    }\n\n    // TODO: Error if subquery appears `or`'s 2nd or later operand.\n\n    query.from = query.from.slice(0, 1).concat(\n        query.from.slice(1).sort((a, b) => a.name.length - b.name.length));\n\n    for (let i = 0; i < query.from.length; i++) {\n        const x = query.from[i];\n\n        {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            x.fieldAliasNames = new Set<string>(Array.from(x.queryFieldsMap!.entries()).map(c => {\n                const f = c[1];\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (f.aliasName && !x.queryFields!.has(f.aliasName)) {\n                    return f.aliasName.toLowerCase();\n                } else {\n                    return '';\n                }\n            }).filter(c => !!c));\n\n            for (const c of x.fieldAliasNames) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (x.condFields!.has(c)) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    x.condFields!.delete(c);\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    x.condAliasFields!.add(c);\n                }\n            }\n        }\n\n        {\n            x.sortFieldNames = new Set<string>(\n                query.orderBy\n                    ? query.orderBy\n                        .filter(c =>\n                            x.name.length + 1 === c.name.length &&\n                                isEqualComplexName(x.name, c.name.slice(0, x.name.length)))\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        .filter(c => !(x.fieldAliasNames!.has(c.name[c.name.length - 1].toLowerCase())))\n                        .map(c => c.name[c.name.length - 1])\n                    : []);\n        }\n\n        {\n            const resolverName = x.resolverName ?? '';\n\n            for (let j = i + 1; j < query.from.length; j++) {\n                const c = query.from[j];\n\n                if (x.name.length + 1 === c.name.length && isEqualComplexName(x.name, c.name.slice(0, x.name.length))) {\n                    const childResolverName = c.resolverName ?? '';\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion\n                    const childRelationshipInfo = ((builder.relationships[resolverName] ?? {})[childResolverName] as any) ?? {};\n\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                    const childIdField = childRelationshipInfo.id\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                        ? childRelationshipInfo.id as string\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        : builder.rules.foreignIdFieldName!(childResolverName);\n\n                    if (childIdField) {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        x.relationshipIdFields!.add(childIdField);\n                    }\n                }\n            }\n        }\n    }\n\n    return query as PreparedQuery;\n}\n\n\nexport function compile(\n    builder: QueryBuilderInfoInternal, query: ParsedQuery): PreparedQuery {\n\n    return normalize(builder, query, [], null);\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getUTCDayInYear(d: Date) {\n    const d0 = Date.UTC(d.getUTCFullYear(), 0, 1);\n    const d1 = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());\n    return ((d1 - d0) / (1000 * 60 * 60 * 24)) + 1;\n}\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getDayInYear(d: Date) {\n    const d0 = Date.UTC(d.getFullYear(), 0, 1);\n    const d1 = Date.UTC(d.getFullYear(), d.getMonth(), d.getDate());\n    return ((d1 - d0) / (1000 * 60 * 60 * 24)) + 1;\n}\n\n\n/*\nexport function getUTCWeekInYearISO(d: Date) {\n    // ISO 8601 week number\n    // Weeks starting on Monday.\n    // The first week of year (W1) contains first Thursday.\n    const dcMon = d.getUTCMonth();\n    const dcDate = d.getUTCDate();\n\n    if (dcMon === 11 && dcDate >= 29) {\n        const d2 = new Date(Date.UTC(d.getUTCFullYear() + 1, 0, 1));\n        const day2 = (d2.getUTCDay() + 6) % 7; // Monday is 0\n        if (day2 <= 3) {\n            // Mon, Tue, Wed, Thu\n            //  29   30   31   01  (day2 === 3)\n            //  30   31   01       (day2 === 2)\n            //  31   01            (day2 === 1)\n            //  01                 (day2 === 0)\n            // Next year's first week is W01.\n            if (day2 + dcDate >= 32) {\n                return 1;\n            }\n        }\n    }\n\n    const d0 = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n    const day0 = (d0.getUTCDay() + 6) % 7; // Monday is 0\n\n    const ds = d0.getTime() - ((1000 * 60 * 60 * 24) * day0);\n\n    const dc = Date.UTC(d.getUTCFullYear(), dcMon, dcDate);\n    const diff = Math.floor((dc - ds) / (1000 * 60 * 60 * 24 * 7));\n\n    if (day0 > 3) {\n        // First day of year is: Fri, Sat, Sun\n        // First day of year is last year's final week.\n        if (diff === 0) {\n            // Last year's final week.\n            const d1 = new Date(Date.UTC(d.getUTCFullYear() - 1, 0, 1));\n            const day1 = (d1.getUTCDay() + 6) % 7; // Monday is 0\n\n            const dp = d1.getTime() - ((1000 * 60 * 60 * 24) * day1);\n            const diff1 = Math.floor((dc - dp) / (1000 * 60 * 60 * 24 * 7));\n            if (day1 > 3) {\n                // Fri, Sat, Sun\n                return diff1;\n            } else {\n                // Mon, Tue, Wed, Thu\n                return diff1 + 1;\n            }\n        } else {\n            return diff;\n        }\n    } else {\n        // First day of year is: Mon, Tue, Wed, Thu\n        // First day of year is this year's first week.\n        return diff + 1;\n    }\n}\n*/\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ScalarQueryFuncInfo,\n         QueryFuncInfo }   from '../types';\nimport { DatePattern,\n         DateTimePattern } from './util';\nimport { getUTCDayInYear,\n         getDayInYear }    from './datetime-util';\n\n\n\nexport const fnInfo_cast_to_string: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'cast_to_string',\n    fn: (ctx, args, records) => {\n        if (args.length > 0) {\n            if (args[0] === null) {\n                return null;\n            }\n            return String(args[0]);\n        }\n        throw new Error(`Argument of function \"cast_to_string\" should be field.`);\n    },\n};\n\nexport const fnInfo_cast_to_number: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'cast_to_number',\n    fn: (ctx, args, records) => {\n        if (args.length > 0) {\n            if (args[0] === null) {\n                return null;\n            }\n            return Number(args[0]);\n        }\n        throw new Error(`Argument of function \"cast_to_number\" should be field.`);\n    },\n};\n\nexport const fnInfo_cast_to_boolean: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'cast_to_boolean',\n    fn: (ctx, args, records) => {\n        if (args.length > 0) {\n            if (args[0] === null) {\n                return null;\n            }\n            return Boolean(args[0]);\n        }\n        throw new Error(`Argument of function \"cast_to_boolean\" should be field.`);\n    },\n};\n\nexport const fnInfo_concat: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'concat',\n    fn: (ctx, args, records) => {\n        if (args.length > 0) {\n            const z = args.filter(c => c !== null);\n            if (z.length === 0) {\n                return null;\n            }\n            return z.map(c => String(c)).join('');\n        }\n        throw new Error(`Argument of function \"concat\" should be field.`);\n    },\n};\n\nexport const fnInfo_add: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'add',\n    fn: (ctx, args, records) => {\n        if (args.length > 1) {\n            const z = args.filter(c => c !== null);\n            if (z.length === 0) {\n                return null;\n            }\n            return z.map(c => Number(c)).reduce((a, b) => a + b);\n        }\n        throw new Error(`Argument of function \"add\" should be field.`);\n    },\n};\n\nexport const fnInfo_sub: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'sub',\n    fn: (ctx, args, records) => {\n        if (args.length > 1) {\n            if (args[0] === null) {\n                return null;\n            }\n            return args.filter(c => c !== null).map(c => Number(c)).reduce((a, b) => a - b);\n        }\n        throw new Error(`Argument of function \"sub\" should be field.`);\n    },\n};\n\nexport const fnInfo_mul: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'mul',\n    fn: (ctx, args, records) => {\n        if (args.length > 1) {\n            const z = args.filter(c => c !== null);\n            if (z.length === 0) {\n                return null;\n            }\n            return z.map(c => Number(c)).reduce((a, b) => a * b);\n        }\n        throw new Error(`Argument of function \"mul\" should be field.`);\n    },\n};\n\nexport const fnInfo_div: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'div',\n    fn: (ctx, args, records) => {\n        if (args.length > 1) {\n            if (args[0] === null) {\n                return null;\n            }\n            return args.filter(c => c !== null).map(c => Number(c)).reduce((a, b) => a / b);\n        }\n        throw new Error(`Argument of function \"div\" should be field.`);\n    },\n};\n\nexport const fnInfo_mod: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'mod',\n    fn: (ctx, args, records) => {\n        if (args.length > 1) {\n            if (args[0] === null) {\n                return null;\n            }\n            return args.filter(c => c !== null).map(c => Number(c)).reduce((a, b) => a % b);\n        }\n        throw new Error(`Argument of function \"div\" should be field.`);\n    },\n};\n\n\nexport const fnInfo_count: QueryFuncInfo = {\n    type: 'aggregate',\n    name: 'count',\n    fn: (ctx, args, records) => {\n        if (args.length === 0) {\n            return records.length;\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arg = args[0];\n            if (Array.isArray(arg)) {\n                return arg.filter(r => (r === null || r === void 0) ? false : true).length;\n            }\n            throw new Error(`Argument of function \"count\" should be field.`);\n        }\n    },\n};\n\n\nexport const fnInfo_count_distinct: QueryFuncInfo = {\n    type: 'aggregate',\n    name: 'count_distinct',\n    fn: (ctx, args, records) => {\n        if (args.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arg = args[0];\n            if (Array.isArray(arg)) {\n                const w = arg\n                    .filter(r => (r === null || r === void 0) ? false : true)\n                    .map(x => JSON.stringify(x));\n                return new Set<string>(w).size;\n            }\n        }\n        throw new Error(`Argument of function \"count_distinct\" should be field.`);\n    },\n};\n\n\nexport const fnInfo_sum: QueryFuncInfo = {\n    type: 'aggregate',\n    name: 'sum',\n    fn: (ctx, args, records) => {\n        if (args.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arg = args[0];\n            if (Array.isArray(arg)) {\n                const w = arg\n                    .filter(r => (typeof r === 'number' && !Number.isNaN(r)) ? true : false);\n                if (w.length) {\n                    return w.reduce((a, b) => (a as number) + (b as number));\n                } else {\n                    return null;\n                }\n            }\n        }\n        throw new Error(`Argument of function \"sum\" should be field.`);\n    },\n};\n\n\nexport const fnInfo_avg: QueryFuncInfo = {\n    type: 'aggregate',\n    name: 'avg',\n    fn: (ctx, args, records) => {\n        if (args.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arg = args[0];\n            if (Array.isArray(arg)) {\n                const w = arg\n                    .filter(r => (typeof r === 'number' && !Number.isNaN(r)) ? true : false);\n                if (w.length) {\n                    return (w.reduce((a, b) => (a as number) + (b as number)) as number) / w.length;\n                } else {\n                    return null;\n                }\n            }\n        }\n        throw new Error(`Argument of function \"avg\" should be field.`);\n    },\n};\n\n\nexport const fnInfo_max: QueryFuncInfo = {\n    type: 'aggregate',\n    name: 'max',\n    fn: (ctx, args, records) => {\n        if (args.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arg = args[0];\n            if (Array.isArray(arg)) {\n                const w = arg\n                    .filter(r => ((typeof r === 'number' && !Number.isNaN(r)) || typeof r === 'string') ? true : false);\n                if (w.length) {\n                    return w.reduce((a, b) => (a as number | string) > (b as number | string) ? a : b);\n                } else {\n                    return null;\n                }\n            }\n        }\n        throw new Error(`Argument of function \"max\" should be field.`);\n    },\n};\n\n\nexport const fnInfo_min: QueryFuncInfo = {\n    type: 'aggregate',\n    name: 'min',\n    fn: (ctx, args, records) => {\n        if (args.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arg = args[0];\n            if (Array.isArray(arg)) {\n                const w = arg\n                    .filter(r => ((typeof r === 'number' && !Number.isNaN(r)) || typeof r === 'string') ? true : false);\n                if (w.length) {\n                    return w.reduce((a, b) => (a as number | string) < (b as number | string) ? a : b);\n                } else {\n                    return null;\n                }\n            }\n        }\n        throw new Error(`Argument of function \"min\" should be field.`);\n    },\n};\n\n\nfunction dateScalarFunctionGen(fnName: string, fn: (dateStr: string) => any): ScalarQueryFuncInfo['fn'] {\n    return (ctx, args, record) => {\n        if (args.length > 0) {\n            const arg = args[0];\n            switch (typeof arg) {\n            case 'object':\n                if (arg === null) {\n                    return null;\n                } else {\n                    switch (arg.type) {\n                    case 'date': case 'datetime':\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return fn(arg.value);\n                    default:\n                        return null;\n                    }\n                }\n            case 'string':\n                if (DatePattern.test(arg) || DateTimePattern.test(arg)) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return fn(arg);\n                } else {\n                    return null;\n                }\n            }\n        }\n        throw new Error(`Argument of function \"${fnName}\" should be field.`);\n    };\n}\n\n\nexport const fnInfo_convertTimezone: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'convertTimezone',\n    fn: dateScalarFunctionGen('convertTimezone', (dateStr) => {\n        const d = new Date(dateStr);\n        const offset = d.getTimezoneOffset() * 60 * 1000;\n        return new Date(d.getTime() - offset).toISOString();\n    }),\n};\n\n\nexport const fnInfo_calendar_month: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'calendar_month',\n    fn: dateScalarFunctionGen('calendar_month', (dateStr) => new Date(dateStr).getUTCMonth() + 1), // 1, ... , 12\n};\n\n\nexport const fnInfo_calendar_month_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'calendar_month_lc',\n    fn: dateScalarFunctionGen('calendar_month_lc', (dateStr) => new Date(dateStr).getMonth() + 1), // 1, ... , 12\n};\n\n\nexport const fnInfo_calendar_quarter: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'calendar_quarter',\n    fn: dateScalarFunctionGen('calendar_quarter', (dateStr) => Math.floor(new Date(dateStr).getUTCMonth() / 3) + 1), // 1, ... , 4\n};\n\n\nexport const fnInfo_calendar_quarter_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'calendar_quarter_lc',\n    fn: dateScalarFunctionGen('calendar_quarter_lc', (dateStr) => Math.floor(new Date(dateStr).getMonth() / 3) + 1), // 1, ... , 4\n};\n\n\nexport const fnInfo_calendar_year: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'calendar_year',\n    fn: dateScalarFunctionGen('calendar_year', (dateStr) => new Date(dateStr).getUTCFullYear()),\n};\n\n\nexport const fnInfo_calendar_year_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'calendar_year_lc',\n    fn: dateScalarFunctionGen('calendar_year_lc', (dateStr) => new Date(dateStr).getFullYear()),\n};\n\n\nexport const fnInfo_day_in_month: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'day_in_month',\n    fn: dateScalarFunctionGen('day_in_month', (dateStr) => new Date(dateStr).getUTCDate()), // 1 , ... , 31\n};\n\n\nexport const fnInfo_day_in_month_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'day_in_month_lc',\n    fn: dateScalarFunctionGen('day_in_month_lc', (dateStr) => new Date(dateStr).getDate()), // 1 , ... , 31\n};\n\n\nexport const fnInfo_day_in_week: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'day_in_week',\n    fn: dateScalarFunctionGen('day_in_week', (dateStr) => new Date(dateStr).getUTCDay() + 1), // Sun:1 , ... , Sat:7\n};\n\n\nexport const fnInfo_day_in_week_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'day_in_week_lc',\n    fn: dateScalarFunctionGen('day_in_week_lc', (dateStr) => new Date(dateStr).getDay() + 1), // Sun:1 , ... , Sat:7\n};\n\n\nexport const fnInfo_day_in_year: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'day_in_year',\n    fn: dateScalarFunctionGen('day_in_year', (dateStr) => getUTCDayInYear(new Date(dateStr))), // 1 , ... , 366\n};\n\n\nexport const fnInfo_day_in_year_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'day_in_year_lc',\n    fn: dateScalarFunctionGen('day_in_year_lc', (dateStr) => getDayInYear(new Date(dateStr))), // 1 , ... , 366\n};\n\n\nexport const fnInfo_day_only: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'day_only',\n    fn: dateScalarFunctionGen('day_only', (dateStr) => new Date(dateStr).toISOString().split('T')[0]),\n};\n\n\nexport const fnInfo_day_only_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'day_only_lc',\n    fn: dateScalarFunctionGen('day_only_lc', (dateStr) => {\n        const d = new Date(dateStr);\n        return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate())).toISOString().split('T')[0];\n    }),\n};\n\n\nexport const fnInfo_hour_in_day: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'hour_in_day',\n    fn: dateScalarFunctionGen('hour_in_day', (dateStr) => new Date(dateStr).getUTCHours()), // 0 , ... , 23\n};\n\n\nexport const fnInfo_hour_in_day_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'hour_in_day_lc',\n    fn: dateScalarFunctionGen('hour_in_day_lc', (dateStr) => new Date(dateStr).getHours()), // 0 , ... , 23\n};\n\n\nexport const fnInfo_week_in_month: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'week_in_month',\n    fn: dateScalarFunctionGen('week_in_month', (dateStr) => Math.floor((new Date(dateStr).getUTCDate() - 1) / 7) + 1), // 1(day 1~7) , ... , 5(day 29~31)\n};\n\n\nexport const fnInfo_week_in_month_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'week_in_month_lc',\n    fn: dateScalarFunctionGen('week_in_month_lc', (dateStr) => Math.floor((new Date(dateStr).getDate() - 1) / 7) + 1), // 1(day 1~7) , ... , 5(day 29~31)\n};\n\n\nexport const fnInfo_week_in_year: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'week_in_year',\n    fn: dateScalarFunctionGen('week_in_year', (dateStr) => Math.floor((getUTCDayInYear(new Date(dateStr)) - 1) / 7) + 1),\n};\n\n\nexport const fnInfo_week_in_year_lc: QueryFuncInfo = {\n    type: 'scalar',\n    name: 'week_in_year_lc',\n    fn: dateScalarFunctionGen('week_in_year_lc', (dateStr) => Math.floor((getDayInYear(new Date(dateStr)) - 1) / 7) + 1),\n};\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { PreparedQuery,\n         QueryFuncInfo,\n         QueryBuilderInfo,\n         QueryBuilderInfoInternal } from '../types';\nimport { parse }                    from './parser';\nimport { compile }                  from './compiler';\nimport { fnInfo_cast_to_string,\n         fnInfo_cast_to_number,\n         fnInfo_cast_to_boolean,\n         fnInfo_concat,\n         fnInfo_add,\n         fnInfo_sub,\n         fnInfo_mul,\n         fnInfo_div,\n         fnInfo_mod,\n         fnInfo_count,\n         fnInfo_count_distinct,\n         fnInfo_sum,\n         fnInfo_avg,\n         fnInfo_max,\n         fnInfo_min,\n         fnInfo_convertTimezone,\n         fnInfo_calendar_month,\n         fnInfo_calendar_quarter,\n         fnInfo_calendar_year,\n         fnInfo_day_in_month,\n         fnInfo_day_in_week,\n         fnInfo_day_in_year,\n         fnInfo_day_only,\n         fnInfo_hour_in_day,\n         fnInfo_week_in_month,\n         fnInfo_week_in_year,\n         fnInfo_calendar_month_lc,\n         fnInfo_calendar_quarter_lc,\n         fnInfo_calendar_year_lc,\n         fnInfo_day_in_month_lc,\n         fnInfo_day_in_week_lc,\n         fnInfo_day_in_year_lc,\n         fnInfo_day_only_lc,\n         fnInfo_hour_in_day_lc,\n         fnInfo_week_in_month_lc,\n         fnInfo_week_in_year_lc }   from './functions';\n\n\n\nconst builtinFunctions: QueryFuncInfo[] = [\n    fnInfo_cast_to_string,\n    fnInfo_cast_to_number,\n    fnInfo_cast_to_boolean,\n    fnInfo_concat,\n    fnInfo_add,\n    fnInfo_sub,\n    fnInfo_mul,\n    fnInfo_div,\n    fnInfo_mod,\n    fnInfo_count,\n    fnInfo_count_distinct,\n    fnInfo_sum,\n    fnInfo_avg,\n    fnInfo_max,\n    fnInfo_min,\n    fnInfo_convertTimezone,\n    fnInfo_calendar_month,\n    fnInfo_calendar_quarter,\n    fnInfo_calendar_year,\n    fnInfo_day_in_month,\n    fnInfo_day_in_week,\n    fnInfo_day_in_year,\n    fnInfo_day_only,\n    fnInfo_hour_in_day,\n    fnInfo_week_in_month,\n    fnInfo_week_in_year,\n    fnInfo_calendar_month_lc,\n    fnInfo_calendar_quarter_lc,\n    fnInfo_calendar_year_lc,\n    fnInfo_day_in_month_lc,\n    fnInfo_day_in_week_lc,\n    fnInfo_day_in_year_lc,\n    fnInfo_day_only_lc,\n    fnInfo_hour_in_day_lc,\n    fnInfo_week_in_month_lc,\n    fnInfo_week_in_year_lc,\n];\n\n\nconst builtinRules: QueryBuilderInfo['rules'] = {\n    idFieldName: () => 'Id',\n    foreignIdFieldName: (masterResolverName) => masterResolverName ? `${masterResolverName}Id` : void 0,\n};\n\n\nexport function prepareBuilderInfo(builder: QueryBuilderInfo): QueryBuilderInfoInternal {\n    const ret = {...builder};\n\n    if (! ret.relationships) {\n        ret.relationships = {};\n    }\n\n    for (const k of Object.keys(ret.resolvers.query)) {\n        if (! ret.relationships[k]) {\n            ret.relationships[k] = {};\n        }\n    }\n\n    if (! ret.resolvers.insert) {\n        ret.resolvers.insert = {};\n    }\n    if (! ret.resolvers.update) {\n        ret.resolvers.update = {};\n    }\n    if (! ret.resolvers.remove) {\n        ret.resolvers.remove = {};\n    }\n\n    if (! ret.functions) {\n        ret.functions = [];\n    }\n    ret.functions = ret.functions.concat(builtinFunctions);\n\n    if (! ret.rules) {\n        ret.rules = {};\n    }\n    ret.rules = {...builtinRules, ...ret.rules};\n\n    if (! ret.events) {\n        ret.events = {};\n    }\n\n    return ret as QueryBuilderInfoInternal;\n}\n\n\nexport function prepareQuery(\n        builder: QueryBuilderInfoInternal,\n        strings: TemplateStringsArray | string,\n        ...values: any[]): PreparedQuery {\n\n    return compile(builder, parse(strings, ...values));\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { PreparedQuery,\n         PreparedResolver,\n         PreparedFnCall,\n         PreparedSubQuery,\n         PreparedFieldListItem,\n         PreparedCondition,\n         PreparedParameterizedValue,\n         ResolverCapabilities,\n         ResolverContext,\n         ResolverEvent,\n         QueryParams,\n         AggregateQueryFuncInfo,\n         ScalarQueryFuncInfo,\n         ImmediateScalarQueryFuncInfo,\n         QueryFuncInfo,\n         QueryBuilderInfoInternal }       from '../types';\nimport { deepCloneObject,\n         getTrueCaseFieldName,\n         getObjectValueWithFieldNameMap } from './util';\nimport { filterZeroLengthCondFn,\n         pruneCondition }                 from './condition';\nimport { callAggregateFunction,\n         callScalarFunction,\n         callImmediateScalarFunction,\n         getGroupFieldTrueCaseName,\n         isScalarFnCallable }             from './call';\nimport { sortRecords }                    from '../sort';\nimport { applyWhereConditions,\n         applyHavingConditions }          from '../filters';\n\n\n\nfunction collectSubQueriesFromCondition(\n        subQueries: Array<{ cond: PreparedCondition, index: number, subQuery: PreparedSubQuery }>,\n        cond: PreparedCondition) {\n\n    switch (cond.type) {\n    case 'condition':\n        for (let i = 0; i < cond.operands.length; i++) {\n            const x = cond.operands[i];\n\n            switch (typeof x) {\n            case 'object':\n                if (x === null) {\n                    // NOTE: never reach here.\n                    // NOTE: Nothing to do.\n                } else if (Array.isArray(x)) {\n                    // NOTE: Nothing to do. It is data.\n                } else {\n                    switch (x.type) {\n                    case 'condition':\n                        collectSubQueriesFromCondition(subQueries, x);\n                        break;\n                    case 'subquery':\n                        subQueries.push({cond, index: i, subQuery: x});\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        break;\n    }\n\n    return cond;\n}\n\n\nasync function execCondSubQueries(\n        builder: QueryBuilderInfoInternal,\n        params: QueryParams,\n        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n        tr: any,\n        trOptions: any | undefined,\n        condTemplate: PreparedCondition[],\n        resolverData: any | null) {\n\n    const condSubQueries: Array<{ cond: PreparedCondition, index: number, subQuery: PreparedSubQuery }> = [];\n\n    condTemplate.forEach(x => collectSubQueriesFromCondition(condSubQueries, x));\n\n    const condSubQueryResults =\n        condSubQueries\n            .map(x =>\n                executeCompiledQuery(\n                    builder, params, tr, trOptions,\n                    x.subQuery.query, null, null, null, resolverData)\n                .then(r => ({ cond: x.cond, index: x.index, subQuery: x.subQuery, result: r })));\n\n    (await Promise.all(condSubQueryResults)).map(x => {\n        const field = x.subQuery.query.select[0];\n        let fieldName = '';\n\n        switch (field.type) {\n        case 'field':\n            fieldName = field.name[field.name.length - 1];\n            break;\n        default:\n            fieldName = field.aliasName ?? '';\n            break;\n        }\n\n        if (x.result.length) {\n            const fieldNameMap = new Map<string, string>(Object.keys(x.result[0]).map(x => [x.toLowerCase(), x]));\n\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            x.cond.operands[x.index] = x.result.map(w => getObjectValueWithFieldNameMap(fieldNameMap, w, fieldName));\n        } else {\n            x.cond.operands[x.index] = [];\n        }\n    });\n}\n\n\nfunction mapSelectFields(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>,\n        x: PreparedResolver, records: any[], isAggregation: boolean) {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const queryFieldsMapEntries:\n        Array<{\n            isField: boolean,\n            fieldName: string,\n            field: PreparedFieldListItem,\n            fn: (i: number, fieldName: string, field: PreparedFieldListItem, record: any) => void,\n        }> = new Array(x.queryFieldsMap.size);\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const fnInfos: QueryFuncInfo[] = new Array(x.queryFieldsMap.size);\n\n    const fnScaler = (i: number, fieldName: string, field: PreparedFieldListItem, record: any) => {\n        const fnInfo: ScalarQueryFuncInfo = fnInfos[i] as ScalarQueryFuncInfo;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        record[(field as PreparedFnCall).aliasName] = callScalarFunction(ctx, field as PreparedFnCall, fnInfo, 'any', record, null);\n    };\n\n    const fnImmediateScaler = (i: number, fieldName: string, field: PreparedFieldListItem, record: any) => {\n        const fnInfo: ImmediateScalarQueryFuncInfo = fnInfos[i] as ImmediateScalarQueryFuncInfo;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        record[(field as PreparedFnCall).aliasName] = callImmediateScalarFunction(ctx, field as PreparedFnCall, fnInfo, 'any', record, null);\n    };\n\n    const fnNoop = (i: number, fieldName: string, field: PreparedFieldListItem, record: any) => void 0;\n\n    {\n        let i = 0;\n        for (const ent of x.queryFieldsMap.entries()) {\n            const [fieldName, field] = ent;\n            switch (field.type) {\n            case 'field':\n                queryFieldsMapEntries[i] = { isField: true, fieldName, field, fn: fnNoop };\n                break;\n            case 'fncall':\n                // NOTE: If aggregation, function will be called at `aggregateFields()`.\n                if (isAggregation) {\n                    queryFieldsMapEntries[i] = { isField: false, fieldName, field, fn: fnNoop };\n                } else {\n                    const fnNameI = field.fn.toLowerCase();\n                    const fnInfo = ctx.functions.find(x => x.name.toLowerCase() === fnNameI);\n\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    fnInfos[i] = fnInfo!;\n\n                    switch (fnInfo?.type) {\n                    case 'scalar':\n                        queryFieldsMapEntries[i] = { isField: false, fieldName, field, fn: fnScaler };\n                        break;\n                    case 'immediate-scalar':\n                        queryFieldsMapEntries[i] = { isField: false, fieldName, field, fn: fnImmediateScaler };\n                        break;\n                    default:\n                        queryFieldsMapEntries[i] = { isField: false, fieldName, field, fn: fnNoop };\n                        break;\n                    }\n                }\n                break;\n            default:\n                queryFieldsMapEntries[i] = { isField: false, fieldName, field, fn: fnNoop };\n                break;\n            }\n            i++;\n        }\n    }\n\n    for (const record of records) {\n        for (let i = 0; i < queryFieldsMapEntries.length; i++) {\n            const { isField, fieldName, field, fn } = queryFieldsMapEntries[i];\n\n            if (isField) {\n                // NOTE: Inline expansion\n\n                if(field.aliasName) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-non-null-assertion\n                    record[field.aliasName!] = record[fieldName];\n                }\n            } else {\n                fn(i, fieldName, field, record);\n            }\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return records;\n}\n\n\nfunction groupRecords(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>, groupBy: string[],\n        x: PreparedResolver, records: any[]) {\n\n    if (records.length === 0) {\n        return [];\n    }\n    if (records.length === 1 || groupBy.length === 0) {\n        return [records];\n    }\n\n    const result = new Map<string, any[]>();\n\n    if (records.length) {\n        let i = 0;\n        const fieldNameMap = new Map<string, string>(Object.keys(records[0]).map(x => [x.toLowerCase(), x]));\n\n        for (const record of records) {\n            const key: any[] = [];\n            for (const k of groupBy) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                let v = getObjectValueWithFieldNameMap(fieldNameMap, record, k);\n                if (v === null || v === void 0) {\n                    v = `__$$GENSYM_VT4iHbNbZW3C7taC7J6bx8pruw40cX5X$$_${i++}`;\n                }\n                key.push(v);\n            }\n\n            const keystr = JSON.stringify(key);\n            if (result.has(keystr)) {\n                const a = result.get(keystr);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                a!.push(record);\n            } else {\n                result.set(keystr, [record]);\n            }\n        }\n    }\n\n    return Array.from(result.values());\n}\n\n\nfunction aggregateFields(\n        ctx: Omit<ResolverContext, 'resolverCapabilities'>, groupBy: string[],\n        x: PreparedResolver, records: any[][]) {\n\n    const result: any[] = [];\n    if (! records.length) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const firstRec = records[0][0];\n    const groupFields = new Map<string, string>(\n        groupBy.map(w => [w.toLowerCase(), getTrueCaseFieldName(firstRec, w) ?? '']));\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const queryFieldsMapEntries:\n        Array<{\n            isField: boolean,\n            field: PreparedFieldListItem,\n            trueCaseName: string,\n            fn: (i: number, field: PreparedFieldListItem, g: any[], agg: any) => void,\n        }> = new Array(x.queryFieldsMap.size);\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const fnInfos: QueryFuncInfo[] = new Array(x.queryFieldsMap.size);\n\n    const fnAggregate = (i: number, field: PreparedFieldListItem, g: any[], agg: any) => {\n        const fnInfo: AggregateQueryFuncInfo = fnInfos[i] as AggregateQueryFuncInfo;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        agg[(field as PreparedFnCall).aliasName] = callAggregateFunction(ctx, field as PreparedFnCall, fnInfo, 'any', g);\n    };\n\n    const fnImmediateScalar = (i: number, field: PreparedFieldListItem, g: any[], agg: any) => {\n        const fnInfo: ImmediateScalarQueryFuncInfo = fnInfos[i] as ImmediateScalarQueryFuncInfo;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        agg[(field as PreparedFnCall).aliasName] = callImmediateScalarFunction(ctx, field as PreparedFnCall, fnInfo, 'any', null, g);\n    };\n\n    const fnScalar = (i: number, field: PreparedFieldListItem, g: any[], agg: any) => {\n        const fnInfo: ScalarQueryFuncInfo = fnInfos[i] as ScalarQueryFuncInfo;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        agg[(field as PreparedFnCall).aliasName] = callScalarFunction(ctx, field as PreparedFnCall, fnInfo, 'any', g[0], g);\n    };\n\n    const fnNoop = (i: number, field: PreparedFieldListItem, g: any[], agg: any) => void 0;\n\n    {\n        let i = 0;\n        for (const ent of x.queryFieldsMap.entries()) {\n            const [, field] = ent;\n            switch (field.type) {\n            case 'field':\n                {\n                    const trueCaseName = getGroupFieldTrueCaseName(groupFields, field.name[field.name.length - 1]);\n                    if (! trueCaseName) {\n                        throw new Error(`${field.name.join('.')} is not allowed. Aggregate function is needed.`);\n                    }\n                    queryFieldsMapEntries[i] = {\n                        isField: true,\n                        field,\n                        trueCaseName,\n                        fn: fnNoop,\n                    };\n                }\n                break;\n            case 'fncall':\n                {\n                    const fnNameI = field.fn.toLowerCase();\n                    const fnInfo = ctx.functions.find(x => x.name.toLowerCase() === fnNameI);\n\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    fnInfos[i] = fnInfo!;\n\n                    switch (fnInfo?.type) {\n                    case 'aggregate':\n                        queryFieldsMapEntries[i] = {\n                            isField: false,\n                            field,\n                            trueCaseName: '',\n                            fn: fnAggregate,\n                        };\n                        break;\n                    case 'immediate-scalar':\n                        queryFieldsMapEntries[i] = {\n                            isField: false,\n                            field,\n                            trueCaseName: '',\n                            fn: fnImmediateScalar,\n                        };\n                        break;\n                    case 'scalar':\n                        if (! isScalarFnCallable(ctx, groupFields, field.args)) {\n                            throw new Error(`${field.aliasName ?? '(unnamed)'} is not allowed. Aggregate function is needed.`);\n                        }\n                        queryFieldsMapEntries[i] = {\n                            isField: false,\n                            field,\n                            trueCaseName: '',\n                            fn: fnScalar,\n                        };\n                        break;\n                    default:\n                        throw new Error(`${field.aliasName ?? '(unnamed)'} is not allowed. Aggregate function is needed.`);\n                    }\n                }\n                break;\n            default:\n                queryFieldsMapEntries[i] = {\n                    isField: false,\n                    field,\n                    trueCaseName: '',\n                    fn: fnNoop,\n                };\n                break;\n            }\n            i++;\n        }\n    }\n\n    for (const g of records) {\n        const agg = {};\n        for (let i = 0; i < queryFieldsMapEntries.length; i++) {\n            const { isField, field, trueCaseName, fn } = queryFieldsMapEntries[i];\n\n            if (isField) {\n                // NOTE: Inline expansion\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n                agg[trueCaseName] = g[0][trueCaseName];\n\n                if (field.aliasName) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n                    agg[field.aliasName] = g[0][trueCaseName];\n                }\n            } else {\n                fn(i, field, g, agg);\n            }\n        }\n        result.push(agg);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return result;\n}\n\n\nfunction getRemovingFields(x: PreparedResolver, records: any[], isAggregation: boolean) {\n    const removingFields = new Set<string>();\n    if (records.length) {\n        const requestedFields = new Set<string>();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const rec = records[0];\n        for (const ent of x.queryFieldsMap.entries()) {\n            const f = ent[1];\n            if (isAggregation && f.type === 'field' && f.aliasName) {\n                requestedFields.add(f.aliasName);\n            } else {\n                const name = getTrueCaseFieldName(rec, ent[0]);\n                if (name) {\n                    requestedFields.add(name);\n                }\n            }\n        }\n        for (const k of Object.keys(rec)) {\n            if (! requestedFields.has(k)) {\n                removingFields.add(k);\n            }\n        }\n    }\n    return removingFields;\n}\n\n\nfunction getResolversInfo(builder: QueryBuilderInfoInternal, resolverNames: Map<string, string>, x: PreparedResolver, i: number) {\n    const parentType: ('master' | 'detail') = i === 0 ? 'master' : 'detail';\n    const parentKey = JSON.stringify(x.name.slice(0, x.name.length - 1));\n    const currentKey = JSON.stringify(x.name);\n    const resolverName = x.resolverName ?? '';\n    const parentResolverName = resolverNames.get(parentKey);\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const masterRelationshipInfo = (\n        (i === 0 ?\n            (\n                // for subquery's primary resolver\n\n                (builder.relationships[resolverName] ?? {})\n                // eslint-disable-next-line no-unexpected-multiline, @typescript-eslint/no-non-null-assertion\n                [parentResolverName!] as any\n            ) : (\n                // for detail->master relationship\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                (builder.relationships[parentResolverName!] ?? {})\n                // eslint-disable-next-line no-unexpected-multiline\n                [resolverName] as any\n            )\n        ) ?? {});\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const foreignIdField = (typeof masterRelationshipInfo === 'object' && masterRelationshipInfo.id)\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        ? masterRelationshipInfo.id as string\n        : i === 0\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            ? builder.rules.foreignIdFieldName(parentResolverName!)\n            : builder.rules.foreignIdFieldName(resolverName) ;\n\n    const parentIdFieldName = parentResolverName ? builder.rules.idFieldName(parentResolverName) : void 0;\n    const currentIdFieldName = builder.rules.idFieldName(resolverName);\n\n    return ({\n        parentType,\n        parentKey,\n        currentKey,\n        resolverName,\n        parentResolverName,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        masterRelationshipInfo,\n        foreignIdField,\n        parentIdFieldName,\n        currentIdFieldName,\n    });\n}\n\n\nfunction normalizeLimitAndOffset(\n        params: QueryParams,\n        limit: number | PreparedParameterizedValue | null | undefined,\n        offset: number | PreparedParameterizedValue | null | undefined) {\n\n    limit = limit ?? null;\n    offset = offset ?? null;\n\n    if (limit !== null && typeof limit === 'object') {\n        if (! Object.prototype.hasOwnProperty.call(params, limit.name)) {\n            throw new Error(`Parameter '${limit.name}' is not found.`);\n        }\n        const w = params[limit.name] ?? null;\n        if (typeof w !== 'number') {\n            throw new Error(`Parameter '${limit.name}' should be number.`);\n        }\n        limit = w;\n    }\n    if (offset !== null && typeof offset === 'object') {\n        if (! Object.prototype.hasOwnProperty.call(params, offset.name)) {\n            throw new Error(`Parameter '${offset.name}' is not found.`);\n        }\n        const w = params[offset.name] ?? null;\n        if (typeof w !== 'number') {\n            throw new Error(`Parameter '${offset.name}' should be number.`);\n        }\n        offset = w;\n    }\n\n    return { limit, offset };\n}\n\n\nexport async function executeCompiledQuery(\n        builder: QueryBuilderInfoInternal,\n        params: QueryParams,\n        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n        tr: any,\n        trOptions: any | undefined,\n        query: PreparedQuery,\n        parent: any | null,\n        parentQueriedRecords: Map<string, any[]> | null,\n        parentResolverNames: Map<string, string> | null,\n        parentResolverData: any | null\n        ): Promise<any[]> {\n\n    let primaryRecords: any[] | undefined;\n    let primaryCapabilities: ResolverCapabilities | undefined;\n\n    const queriedRecords = parentQueriedRecords ?? new Map<string, any[]>();\n    const resolverNames = parentResolverNames ?? new Map<string, string>();\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const resolverData = parentResolverData ?? {};\n\n    const { limit, offset } = normalizeLimitAndOffset(params, query.limit, query.offset);\n\n    if (!parent && builder.events.beginExecute) {\n        await builder.events.beginExecute({\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            resolverData,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            transactionData: tr,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            transactionOptions: trOptions,\n        });\n    }\n\n    try {\n        const condWhereTemplate = query.where ?\n            deepCloneObject(query.where) : [];\n        const condHavingTemplate = query.having ?\n            deepCloneObject(query.having) : [];\n\n        await execCondSubQueries(builder, params, tr, trOptions, condWhereTemplate, resolverData);\n        await execCondSubQueries(builder, params, tr, trOptions, condHavingTemplate, resolverData);\n\n        const removingFieldsAndRecords: Array<[Set<string>, any[]]> = [];\n        const removingFieldsMap = new Map<string, Set<string>>();\n\n        for (let i = 0; i < query.from.length; i++) {\n            const x = query.from[i];\n\n            const {\n                parentType,\n                parentKey,\n                currentKey,\n                resolverName,\n                parentResolverName,\n                foreignIdField,\n                parentIdFieldName,\n                currentIdFieldName,\n            } = getResolversInfo(builder, resolverNames, x, i);\n\n            if (! x.resolver) {\n                throw new Error(`Resolver name ${x.name.join('.')} is not resolved.`);\n            }\n\n            let records: any[] = [];\n            const parentRecords = queriedRecords.get(parentKey);\n\n            const hasAliasNameCond = (x.condAliasFields.size > 0) ? true : false;\n            const isAggregation = (i === 0 && query.groupBy) ? true : false;\n\n            const queryFields =\n                Array.from(x.queryFields.values());\n            const condFields =\n                Array.from(x.condFields.values());\n            const havingCondFields =\n                Array.from(x.havingCondFields.values());\n            const groupFields: string[] =\n                (i === 0 && query.groupBy) ? query.groupBy : []; // NOTE: condition is same as `isAggregation`\n            const sortFields =\n                Array.from(x.sortFieldNames.values());\n            const relationshipIdFields =\n                Array.from(x.relationshipIdFields.values());\n\n            const resolvingFields =\n                Array.from(\n                    new Set<string>(queryFields\n                        .concat(condFields)\n                        .concat(havingCondFields)\n                        .concat(builder.rules.idFieldName ? [builder.rules.idFieldName(resolverName)] : [])\n                        .concat(groupFields)\n                        .concat(sortFields)\n                        .concat(relationshipIdFields)\n                    ).values());\n\n            const condWhere = deepCloneObject(condWhereTemplate)\n                .map(cond => pruneCondition(x.name, cond))\n                .filter(filterZeroLengthCondFn);\n            const condHaving = deepCloneObject(condHavingTemplate)\n                .map(cond => pruneCondition(x.name, cond))\n                .filter(filterZeroLengthCondFn);\n\n            const ctxGen: Omit<ResolverContext, 'resolverCapabilities'> = {\n                functions: builder.functions,\n                query,\n                params,\n                graphPath: x.name,\n                resolverName,\n                parentResolverName,\n                parentType,\n                foreignIdField,\n                masterIdField: i === 0 ? parentIdFieldName : currentIdFieldName,\n                detailIdField: i === 0 ? currentIdFieldName : parentIdFieldName,\n                parentRecords,\n                conditions: condWhere,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                resolverData,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                transactionData: tr,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                transactionOptions: trOptions,\n            };\n\n            if (i === 0) {\n                const ctx: ResolverContext = {\n                    ...ctxGen,\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    parent,\n                    resolverCapabilities: {\n                        filtering: false,\n                        sorting: false,\n                        limit: false,\n                        offset: false,\n                    },\n                };\n\n                records = await x.resolver(\n                    resolvingFields,\n                    hasAliasNameCond ? [] : condWhere,\n                    (isAggregation || hasAliasNameCond) ? null : limit,\n                    (isAggregation || hasAliasNameCond) ? null : offset,\n                    ctx,\n                );\n                primaryCapabilities = ctx.resolverCapabilities;\n\n                if (hasAliasNameCond) {\n                    primaryCapabilities.filtering = false;\n                    primaryCapabilities.limit = false;\n                    primaryCapabilities.offset = false;\n                    primaryCapabilities.sorting = false;\n                }\n\n                if (hasAliasNameCond) {\n                    records = mapSelectFields(ctxGen, x, records, isAggregation);\n                }\n\n                if (! ctx.resolverCapabilities.filtering) {\n                    records = applyWhereConditions(ctxGen, condWhere, records);\n                }\n\n                if (! hasAliasNameCond) {\n                    records = mapSelectFields(ctxGen, x, records, isAggregation);\n                }\n\n                if (isAggregation) {\n                    // TODO: `count()` on non-aggregation query\n\n                    primaryCapabilities.limit = false;\n                    primaryCapabilities.offset = false;\n                    primaryCapabilities.sorting = false;\n\n                    const grouped = groupRecords(ctxGen, groupFields, x, records);\n                    const filteredGrouped = applyHavingConditions(ctxGen, condHaving, grouped);\n                    records = aggregateFields(ctxGen, groupFields, x, filteredGrouped);\n                }\n\n                primaryRecords = records;\n            } else if (parentRecords && parentRecords.length) {\n                // Get master relationships.\n\n                // For N+1 Query problem\n                if (builder.events.beforeMasterSubQueries) {\n                    await builder.events.beforeMasterSubQueries(ctxGen);\n                }\n\n                const parentFieldName = x.name[x.name.length - 1];\n                for (const p of parentRecords) {\n                    const ctx: ResolverContext = {\n                        ...ctxGen,\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        parent: p,\n                        resolverCapabilities: {\n                            filtering: false,\n                            sorting: false,\n                            limit: false,\n                            offset: false,\n                        },\n                    };\n\n                    let recs = (await x.resolver(\n                        resolvingFields,\n                        hasAliasNameCond ? [] : condWhere,\n                        1, 0, ctx)).slice(0, 1);\n\n                    if (hasAliasNameCond) {\n                        ctx.resolverCapabilities.filtering = false;\n                        ctx.resolverCapabilities.limit = false;\n                        ctx.resolverCapabilities.offset = false;\n                        ctx.resolverCapabilities.sorting = false;\n                    }\n\n                    if (hasAliasNameCond) {\n                        recs = mapSelectFields(ctxGen, x, recs, isAggregation);\n                    }\n\n                    if (! ctx.resolverCapabilities.filtering) {\n                        recs = applyWhereConditions(ctxGen, condWhere, recs);\n                    }\n\n                    if (! hasAliasNameCond) {\n                        recs = mapSelectFields(ctxGen, x, recs, isAggregation);\n                    }\n\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n                    p[parentFieldName] = recs.length > 0 ? recs[0] : null;\n\n                    records = records.concat(recs);\n                }\n\n                if (builder.events.afterMasterSubQueries) {\n                    await builder.events.afterMasterSubQueries(ctxGen);\n                }\n\n                const parentRemovingFields = removingFieldsMap.get(parentKey);\n                if (parentRemovingFields) {\n                    parentRemovingFields.delete(parentFieldName);\n                }\n            }\n\n            const removingFields = getRemovingFields(x, records, isAggregation);\n            removingFieldsAndRecords.push([removingFields, records]);\n            removingFieldsMap.set(currentKey, removingFields);\n\n            queriedRecords.set(currentKey, records);\n            resolverNames.set(currentKey, resolverName);\n        }\n\n        if (query.selectSubQueries && primaryRecords) {\n            const promises: Promise<{ name: string[], parent: any, result: any[] }>[] = [];\n            for (const x of query.selectSubQueries) {\n                const subQueryName = x.query.from[0].name;\n                const parentKey = JSON.stringify(subQueryName.slice(0, subQueryName.length - 1));\n                const parentRecords = queriedRecords.get(parentKey);\n\n                if (parentRecords) {\n                    // For N+1 Query problem // TODO: reduce descendants (grandchildren and ...) queries\n\n                    const {\n                        parentType,\n                        resolverName,\n                        parentResolverName,\n                        foreignIdField,\n                        parentIdFieldName,\n                        currentIdFieldName,\n                    } = getResolversInfo(builder, resolverNames, x.query.from[0], 0);\n\n                    const evtGen: ResolverEvent = {\n                        functions: builder.functions,\n                        query: x.query,\n                        params,\n                        graphPath: subQueryName,\n                        resolverName,\n                        parentResolverName,\n                        parentType,\n                        foreignIdField,\n                        masterIdField: parentIdFieldName,\n                        detailIdField: currentIdFieldName,\n                        parentRecords,\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        resolverData,\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        transactionData: tr,\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        transactionOptions: trOptions,\n                    };\n\n                    if (builder.events.beforeDetailSubQueries) {\n                        await builder.events.beforeDetailSubQueries({\n                            ...evtGen,\n                        });\n                    }\n\n                    for (const p of parentRecords) {\n                        promises.push(\n                            executeCompiledQuery(\n                                builder, params, tr, trOptions,\n                                x.query, p, queriedRecords, resolverNames, resolverData)\n                            .then(q => ({\n                                name: subQueryName,\n                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                parent: p,\n                                result: q,\n                            }))\n                        );\n                    }\n\n                    if (builder.events.afterDetailSubQueries) {\n                        await builder.events.afterDetailSubQueries({\n                            ...evtGen,\n                        });\n                    }\n                }\n\n                const parentRemovingFields = removingFieldsMap.get(parentKey);\n                if (parentRemovingFields) {\n                    parentRemovingFields.delete(subQueryName[subQueryName.length - 1]);\n                }\n            }\n\n            const results = await Promise.all(promises);\n            results.forEach(r => {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                r.parent[r.name[r.name.length - 1]] = r.result;\n            });\n        }\n\n        if (primaryRecords) {\n            if (primaryCapabilities) {\n                if (! primaryCapabilities.sorting) {\n                    primaryRecords = sortRecords(query, primaryRecords);\n                }\n\n                if (! (primaryCapabilities.offset || primaryCapabilities.limit)) {\n                    if (typeof offset === 'number' && typeof limit === 'number') {\n                        primaryRecords = primaryRecords.slice(offset, offset + limit);\n                    } else if (typeof offset === 'number') {\n                        primaryRecords = primaryRecords.slice(offset);\n                    } else if (typeof limit === 'number') {\n                        primaryRecords = primaryRecords.slice(0, limit);\n                    }\n                } else if (! primaryCapabilities.offset) {\n                    if (typeof offset === 'number') {\n                        primaryRecords = primaryRecords.slice(offset);\n                    }\n                } else if (! primaryCapabilities.limit) {\n                    if (typeof limit === 'number') {\n                        primaryRecords = primaryRecords.slice(0, limit);\n                    }\n                }\n            }\n        } else {\n            // NOTE: never reach here.\n            primaryRecords = [];\n        }\n\n        for (const ent of removingFieldsAndRecords) {\n            const [removingFields, records] = ent;\n            for (const r of records) {\n                for (const name of removingFields) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                    delete r[name];\n                }\n            }\n        }\n\n        if (!parent && builder.events.endExecute) {\n            await builder.events.endExecute({\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                resolverData,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                transactionData: tr,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                transactionOptions: trOptions,\n            }, null);\n        }\n    } catch (e) {\n        if (!parent && builder.events.endExecute) {\n            await builder.events.endExecute({\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                resolverData,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                transactionData: tr,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                transactionOptions: trOptions,\n            }, e);\n        }\n        throw e;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return primaryRecords;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { QueryBuilderInfo,\n         QueryParams,\n         IQuery,\n         PreparedAtomValue,\n         PreparedQuery,\n         SubscriberParams,\n         Subscriber }      from './types';\nimport { prepareQuery,\n         prepareBuilderInfo }   from './lib/prepare';\nimport { executeCompiledQuery } from './lib/run-query';\nimport { executeInsertDML,\n         executeUpdateDML,\n         executeRemoveDML }     from './lib/run-dml';\n\n\n\nclass Query implements IQuery {\n    constructor(private query: PreparedQuery, private runCompiledQuery:\n            (q: PreparedQuery, p?: QueryParams) => Promise<any[]>) {\n        // nothing to do.\n    }\n\n    public execute<R>(params?: QueryParams): Promise<R[]> {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.runCompiledQuery(this.query, params);\n    }\n}\n\n\ninterface Subscribers {\n    [resolverNames: string]: Map<any, Set<Subscriber>>;\n}\n\ninterface PublishedEvtQueueItem extends SubscriberParams {\n    fn: Subscriber;\n}\n\ntype PublishFn = (resolver: string, on: SubscriberParams['on'], data: any[]) => void;\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function build(builder: QueryBuilderInfo) {\n    const preparedBI = prepareBuilderInfo(builder);\n    const subscribers: Subscribers = {};\n\n\n    class Publisher {\n        private eventQueue: PublishedEvtQueueItem[] = [];\n\n        public publish(resolver: string, on: SubscriberParams['on'], data: any[]) {\n            const map = subscribers[resolver];\n            if (map && map.size) {\n                {\n                    const set = map.get(null);\n                    if (set) {\n                        for (const fn of set.values()) {\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            this.eventQueue.push({ on, resolver, id: null, fn });\n                        }\n                    }\n                }\n                const idFieldName = preparedBI.rules.idFieldName(resolver);\n                for (const rec of data) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n                    const id = rec[idFieldName];\n                    const set = map.get(id);\n                    if (set) {\n                        for (const fn of set.values()) {\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            this.eventQueue.push({ on, resolver, id, fn });\n                        }\n                    }\n                }\n            }\n        }\n\n        public toPublishFn() {\n            return (resolver: string, on: SubscriberParams['on'], data: any[]) => this.publish(resolver, on, data);\n        }\n\n        public fire() {\n            if (this.eventQueue.length) {\n                const queue = this.eventQueue;\n                this.eventQueue = [];\n\n                setTimeout(() => {\n                    for (const q of queue) {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            q.fn({ on: q.on, resolver: q.resolver, id: q.id });\n                        } catch (e) {\n                            // nothing to do.\n                        }\n                    }\n                }, 0);\n            }\n        }\n    }\n\n\n    function subscribe(resolver: string, id: any | null, fn: Subscriber) {\n        if (! subscribers[resolver]) {\n            subscribers[resolver] = new Map<any, Set<Subscriber>>();\n        }\n\n        const map = subscribers[resolver];\n        if (! map.has(id)) {\n            map.set(id, new Set<Subscriber>());\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const set = map.get(id)!;\n        set.add(fn);\n    }\n\n\n    function unsubscribe(resolver: string, id: any | null, fn: Subscriber) {\n        if (! subscribers[resolver]) {\n            return;\n        }\n\n        const map = subscribers[resolver];\n        if (! map.has(id)) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const set = map.get(id)!;\n        set.delete(fn);\n    }\n\n\n    function unsubscribeAllBySubscriber(resolver: string, fn: Subscriber) {\n        if (! subscribers[resolver]) {\n            return;\n        }\n\n        const map = subscribers[resolver];\n        for (const [, set] of map.entries()) {\n            set.delete(fn);\n        }\n    }\n\n\n    function createTransactionScope(\n            scopeTr: any, scopeTrOptions: any | undefined, scopePublisher: Publisher | undefined, isIsolated: boolean) {\n\n        const scopePub = scopePublisher?.toPublishFn();\n\n\n        async function withTransactionEvents<R>(\n                tr: any, trOptions: any | undefined, publisher: Publisher,\n                run: (tx: any, txOpts: any | undefined, publish: PublishFn) => Promise<R>) {\n\n            try {\n                if (preparedBI.events.beginTransaction) {\n                    await preparedBI.events.beginTransaction({\n                        resolverData: {},\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        transactionData: tr,\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        transactionOptions: trOptions,\n                    });\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const ret =  await run(tr, trOptions, publisher.toPublishFn());\n\n                if (preparedBI.events.endTransaction) {\n                    await preparedBI.events.endTransaction({\n                        resolverData: {},\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        transactionData: tr,\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        transactionOptions: trOptions,\n                    }, null);\n                }\n\n                publisher.fire();\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return ret;\n            } catch (e) {\n                try {\n                    if (preparedBI.events.endTransaction) {\n                        await preparedBI.events.endTransaction({\n                            resolverData: {},\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            transactionData: tr,\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            transactionOptions: trOptions,\n                        }, e);\n                    }\n                } catch (e2) {\n                    // nothing to do.\n                }\n                throw e;\n            }\n        }\n\n\n        async function runCompiledQuery<R>(query: PreparedQuery, params?: QueryParams): Promise<R[]> {\n            const run = async (tr: any, trOptions: any | undefined, publish: PublishFn) => {\n                const ret = await executeCompiledQuery(preparedBI, params ?? {}, tr, trOptions, query, null, null, null, null);\n\n                if (query.for && (query.for.includes('view') || query.for.includes('reference'))) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    publish(query.from[0].resolverName![query.from[0].resolverName!.length - 1], 'update', ret);\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return ret;\n            };\n\n            if (isIsolated) {\n                return await withTransactionEvents<R[]>({}, void 0, new Publisher(), run);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-non-null-assertion\n                return await run(scopeTr, scopeTrOptions, scopePub!);\n            }\n        }\n\n\n        function compileQuery(\n                strings: TemplateStringsArray | string,\n                ...values: Array<PreparedAtomValue | Array<PreparedAtomValue>>): IQuery {\n\n            const query = prepareQuery(preparedBI, strings, ...values);\n            return new Query(query, runCompiledQuery);\n        }\n\n\n        async function runQuery<R>(\n                strings: TemplateStringsArray | string,\n                ...values: Array<PreparedAtomValue | Array<PreparedAtomValue>>): Promise<R[]> {\n\n            const run = async (tr: any, trOptions: any | undefined, publish: PublishFn) => {\n                const query = prepareQuery(preparedBI, strings, ...values);\n                const ret = await executeCompiledQuery(preparedBI, {}, tr, trOptions, query, null, null, null, null);\n\n                if (query.for && (query.for.includes('view') || query.for.includes('reference'))) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    publish(query.from[0].resolverName![query.from[0].resolverName!.length - 1], 'update', ret);\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return ret;\n            };\n\n            if (isIsolated) {\n                return await withTransactionEvents<R[]>({}, void 0, new Publisher(), run);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-non-null-assertion\n                return await run(scopeTr, scopeTrOptions, scopePub!);\n            }\n        }\n\n\n        async function runInsert<T>(resolver: string, obj: T): Promise<T extends (infer R)[] ? R[] : T> {\n            const run = async (tr: any, trOptions: any | undefined, publish: PublishFn) => {\n                const isArray = Array.isArray(obj);\n    \n                const ret = await executeInsertDML(preparedBI, tr, trOptions, resolver, isArray ? obj as any : [obj]);\n\n                publish(resolver, 'insert', ret);\n\n                if (isArray) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return ret as any;\n                } else {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return ret[0];\n                }\n            };\n\n            if (isIsolated) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return await withTransactionEvents({}, void 0, new Publisher(), run);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-non-null-assertion\n                return await run(scopeTr, scopeTrOptions, scopePub!);\n            }\n        }\n\n\n        async function runUpdate<T>(resolver: string, obj: T): Promise<T extends (infer R)[] ? R[] : T> {\n            const run = async (tr: any, trOptions: any | undefined, publish: PublishFn) => {\n                const isArray = Array.isArray(obj);\n\n                const ret = await executeUpdateDML(preparedBI, tr, trOptions, resolver, isArray ? obj as any : [obj]);\n\n                publish(resolver, 'update', ret);\n\n                if (isArray) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return ret as any;\n                } else {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return ret[0];\n                }\n            };\n\n            if (isIsolated) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return await withTransactionEvents({}, void 0, new Publisher(), run);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-non-null-assertion\n                return await run(scopeTr, scopeTrOptions, scopePub!);\n            }\n        }\n\n\n        async function runRemove<T>(resolver: string, obj: T): Promise<void> {\n            const run = async (tr: any, trOptions: any | undefined, publish: PublishFn) => {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const data: any[] = Array.isArray(obj) ? obj : [obj];\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                await executeRemoveDML(preparedBI, tr, trOptions, resolver, data);\n\n                publish(resolver, 'remove', data);\n\n                return;\n            };\n\n            if (isIsolated) {\n                return await withTransactionEvents({}, void 0, new Publisher(), run);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-non-null-assertion\n                return await run(scopeTr, scopeTrOptions, scopePub!);\n            }\n        }\n\n\n        async function runNotifyGen<T>(resolver: string, on: SubscriberParams['on'], obj: T): Promise<void> {\n            const run = (tr: any, trOptions: any | undefined, publish: PublishFn) => {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const data: any[] = Array.isArray(obj) ? obj : [obj];\n\n                publish(resolver, on, data);\n\n                return Promise.resolve();\n            };\n\n            if (isIsolated) {\n                return await withTransactionEvents({}, void 0, new Publisher(), run);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-non-null-assertion\n                return await run(scopeTr, scopeTrOptions, scopePub!);\n            }\n        }\n\n\n        async function runTouch<T>(resolver: string, obj: T): Promise<void> {\n            return runNotifyGen<T>(resolver, 'update', obj);\n        }\n\n\n        async function runNotifyRemoved<T>(resolver: string, obj: T): Promise<void> {\n            return runNotifyGen<T>(resolver, 'remove', obj);\n        }\n\n\n        async function transaction(\n                callback: (commands: {\n                        compile: typeof compileQuery,\n                        soql: typeof runQuery,\n                        insert: typeof runInsert,\n                        update: typeof runUpdate,\n                        remove: typeof runRemove,\n                        touch: typeof runTouch,\n                        notifyRemoved: typeof runNotifyRemoved,\n                    }, tr: any) => Promise<void>,\n                trOptions?: any,\n                ) {\n\n            const tr = {};\n\n            const publisher = new Publisher();\n            const commands = createTransactionScope(tr, trOptions, publisher, false);\n\n            const run = async (tr: any, _trOptions: any | undefined, _publish: PublishFn) => {\n                await callback({\n                    compile: commands.compile,\n                    soql: commands.soql,\n                    insert: commands.insert,\n                    update: commands.update,\n                    remove: commands.remove,\n                    touch: commands.touch,\n                    notifyRemoved: commands.notifyRemoved,\n                }, tr);\n            };\n\n            return await withTransactionEvents(tr, trOptions, publisher, run);\n        }\n\n        return ({\n            compile: compileQuery,\n            soql: runQuery,\n            insert: runInsert,\n            update: runUpdate,\n            remove: runRemove,\n            touch: runTouch,\n            notifyRemoved: runNotifyRemoved,\n            subscribe,\n            unsubscribe,\n            unsubscribeAllBySubscriber,\n            transaction,\n        });\n    }\n\n\n    return createTransactionScope({}, void 0, void 0, true);\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ResolverEvent,\n         InsertResolverFn,\n         UpdateResolverFn,\n         RemoveResolverFn,\n         QueryBuilderInfoInternal } from '../types';\n\n\n\nexport async function executeInsertDML(\n        builder: QueryBuilderInfoInternal,\n        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n        tr: any,\n        trOptions: any | undefined,\n        resolverName: string,\n        records: any[]\n        ): Promise<any[]> {\n\n    const resolvers = builder.resolvers.insert;\n    let resolverInfo: InsertResolverFn | null = null;\n    for (const key of Object.keys(resolvers)) {\n        if (key.toLowerCase() === resolverName.toLowerCase()) {\n            resolverInfo = resolvers[key];\n        }\n    }\n    if (! resolverInfo) {\n        throw new Error(`Resolver name ${resolverName} is not resolved.`);\n    }\n\n    const evt: ResolverEvent = {\n        resolverData: {},\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        transactionData: tr,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        transactionOptions: trOptions,\n    };\n\n    if (builder.events.beginExecute) {\n        await builder.events.beginExecute(evt);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let ret: any [] = null as any;\n\n    try {\n        const ctx = {\n            functions: builder.functions,\n            graphPath: [],\n            resolverName: resolverName,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            resolverData: evt.resolverData,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            transactionData: tr,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            transactionOptions: trOptions,\n            resolverCapabilities: {\n                filtering: false,\n                sorting: false,\n                limit: false,\n                offset: false,\n            },\n        };\n\n        ret = await resolverInfo(records, ctx);\n\n        if (builder.events.endExecute) {\n            await builder.events.endExecute(evt, null);\n        }\n    } catch(e) {\n        if (builder.events.endExecute) {\n            await builder.events.endExecute(evt, e);\n        }\n\n        throw e;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return ret;\n}\n\n\nexport async function executeUpdateDML(\n        builder: QueryBuilderInfoInternal,\n        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n        tr: any,\n        trOptions: any | undefined,\n        resolverName: string,\n        records: any[]\n        ): Promise<any[]> {\n\n    const resolvers = builder.resolvers.update;\n    let resolverInfo: UpdateResolverFn | null = null;\n    for (const key of Object.keys(resolvers)) {\n        if (key.toLowerCase() === resolverName.toLowerCase()) {\n            resolverInfo = resolvers[key];\n        }\n    }\n    if (! resolverInfo) {\n        throw new Error(`Resolver name ${resolverName} is not resolved.`);\n    }\n\n    const evt: ResolverEvent = {\n        resolverData: {},\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        transactionData: tr,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        transactionOptions: trOptions,\n    };\n\n    if (builder.events.beginExecute) {\n        await builder.events.beginExecute(evt);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let ret: any [] = null as any;\n\n    try {\n        const ctx = {\n            functions: builder.functions,\n            graphPath: [],\n            resolverName: resolverName,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            resolverData: evt.resolverData,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            transactionData: tr,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            transactionOptions: trOptions,\n            resolverCapabilities: {\n                filtering: false,\n                sorting: false,\n                limit: false,\n                offset: false,\n            },\n        };\n\n        ret = await resolverInfo(records, ctx);\n\n        if (builder.events.endExecute) {\n            await builder.events.endExecute(evt, null);\n        }\n    } catch(e) {\n        if (builder.events.endExecute) {\n            await builder.events.endExecute(evt, e);\n        }\n\n        throw e;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return ret;\n}\n\n\nexport async function executeRemoveDML(\n        builder: QueryBuilderInfoInternal,\n        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n        tr: any,\n        trOptions: any | undefined,\n        resolverName: string,\n        records: any[]\n        ): Promise<void> {\n\n    const resolvers = builder.resolvers.remove;\n    let resolverInfo: RemoveResolverFn | null = null;\n    for (const key of Object.keys(resolvers)) {\n        if (key.toLowerCase() === resolverName.toLowerCase()) {\n            resolverInfo = resolvers[key];\n        }\n    }\n    if (! resolverInfo) {\n        throw new Error(`Resolver name ${resolverName} is not resolved.`);\n    }\n\n    const evt: ResolverEvent = {\n        resolverData: {},\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        transactionData: tr,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        transactionOptions: trOptions,\n    };\n\n    if (builder.events.beginExecute) {\n        await builder.events.beginExecute(evt);\n    }\n\n    try {\n        const ctx = {\n            functions: builder.functions,\n            graphPath: [],\n            resolverName: resolverName,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            resolverData: evt.resolverData,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            transactionData: tr,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            transactionOptions: trOptions,\n            resolverCapabilities: {\n                filtering: false,\n                sorting: false,\n                limit: false,\n                offset: false,\n            },\n        };\n\n        await resolverInfo(records, ctx);\n\n        if (builder.events.endExecute) {\n            await builder.events.endExecute(evt, null);\n        }\n    } catch(e) {\n        if (builder.events.endExecute) {\n            await builder.events.endExecute(evt, e);\n        }\n\n        throw e;\n    }\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { parserInput }        from 'fruitsconfits/modules/lib/types';\nimport { formatErrorMessage } from 'fruitsconfits/modules/lib/parser';\nimport { getStringParsers }   from 'fruitsconfits/modules/lib/string-parser';\n\n\n\ntype Ctx = undefined;\ntype Ast = string | number | boolean | null | string[];\n\n\nconst $s = getStringParsers<Ctx, Ast>({\n    rawToToken: rawToken => rawToken,\n    concatTokens: tokens => (tokens.length ?\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        [tokens.reduce((a, b) => a as string + b as string)] : []),\n});\n\nconst {seq, cls, notCls, classes, numbers, cat,\n       repeat, end, first, combine, erase, trans, ahead,\n       makeProgram} = $s;\n\n\nconst decimalIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 10)])(\n        numbers.int);\n\nconst floatingPointNumberValue =\n    trans(tokens => [Number.parseFloat((tokens as string[])[0].replace(/_/g, ''))])(\n        numbers.float);\n\nconst numberValue =\n    first(floatingPointNumberValue,\n          decimalIntegerValue, );\n\nconst trueValue =\n    trans(tokens => [true])(seq('true'));\n\nconst falseValue =\n    trans(tokens => [false])(seq('false'));\n\n\nconst quoted = trans(input => input.length ? input : [''])(\n    erase(repeat(classes.spaceWithinSingleLine), cls('\"')),\n    cat(repeat(first(\n        trans(input => ['\"'])(seq('\"\"')),\n        notCls('\"'), ))),\n    erase(cls('\"'), repeat(erase(classes.spaceWithinSingleLine))), );\n\nconst nakidNum = trans(input => input.length ? input : [null])(\n    erase(repeat(classes.spaceWithinSingleLine)),\n    first(trueValue, falseValue, numberValue),\n    erase(repeat(classes.spaceWithinSingleLine)),\n    ahead(first(cls(',', '\\r\\n', '\\n', '\\r'), end())), );\n\nconst nakid = trans(input => input.length ? ([input[0] ? (input[0] as string).trim() : '']) : [null])(\n    erase(repeat(classes.spaceWithinSingleLine)),\n    cat(repeat(first(\n        erase(classes.spaceWithinSingleLine, ahead(cls(',', '\\r\\n', '\\n', '\\r'))),\n        notCls(',', '\\r\\n', '\\n', '\\r'), ))));\n\nconst cell = first(quoted, nakidNum, nakid);\n\nconst row = trans(input => [input as string[]])(\n    cell,\n    repeat(combine(erase(seq(',')), cell)), );\n\nconst rows = makeProgram(combine(\n    row,\n    repeat(combine(erase(classes.newline), row)),\n    end(), ));\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function parse(s: string) {\n    const z = rows(parserInput(s));\n    if (! z.succeeded) {\n        throw new Error(formatErrorMessage(z));\n    }\n    return z.tokens as string[][];\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { QueryResolverFn,\n         PreparedCondition,\n         ResolverContext }      from './types';\nimport { dummyTargetObject,\n         isUnsafeVarNames}      from './lib/protection';\nimport { getObjectValue,\n         getTrueCaseFieldName, \n         isEqualComplexName }   from './lib/util';\nimport { parse as parseCsv }    from './lib/csv-parser';\nimport { sortRecords }          from './sort';\nimport { applyWhereConditions } from './filters';\n\n\n\nexport interface StaticResolverConfig {\n    noCache?: boolean;\n    noFiltering?: boolean;\n    noSorting?: boolean;\n}\n\n// const defaultStaticResolverConfig: StaticResolverConfig = {\n//     noCache: true,\n//     noFiltering: true,\n//     noSorting: true,\n// };\nconst defaultStaticResolverConfig: StaticResolverConfig = {\n    noCache: false,\n    noFiltering: false,\n    noSorting: false,\n};\n\n\nexport function setDefaultStaticResolverConfig(conf: StaticResolverConfig): void {\n    Object.assign(defaultStaticResolverConfig, conf);\n}\n\n\nfunction jsonRecordsParser(src: string) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const records: any[] = JSON.parse(src);\n    if (! Array.isArray(records)) {\n        throw new Error(`jsonRecordsParser: Records should be array.`);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return records;\n}\n\n\nfunction csvRecordsParser(src: string) {\n    const rawRecords = parseCsv(src.trim());\n    if (! rawRecords.length) {\n        throw new Error(`csvRecordsParser: Header row is needed.`);\n    }\n\n    const header = rawRecords[0];\n\n    for (let c = 0; c < header.length; c++) {\n        if (isUnsafeVarNames(dummyTargetObject, header[c])) {\n            throw new Error(`Unsafe symbol name is appeared: ${header[c]}`);\n        }\n    }\n\n    const records: any[] = [];\n\n    for (let i = 1; i < rawRecords.length; i++) {\n        const cur = rawRecords[i];\n        const rec = {};\n        for (let c = 0; c < header.length; c++) {\n            rec[header[c]] = cur[c];\n        }\n        records.push(rec);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return records;\n}\n\n\nfunction passThroughParser(src: any[]) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return src;\n}\n\n\nfunction filterAndSliceRecords(\n        fromCache: boolean,\n        records: any[], fields: string[], conditions: PreparedCondition[],\n        limit: number | null, offset: number | null, ctx: ResolverContext,\n        config: StaticResolverConfig) {\n\n    if (! records.length) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return records;\n    }\n\n    const removingFields = new Set<string>();\n    const recordFields = new Map<string, string>(Object.keys(records[0]).map(x => [x.toLowerCase(), x]));\n    const requestedFields = new Set<string>(fields.map(x => x.toLowerCase()));\n\n    for (const field of requestedFields.keys()) {\n        if (! recordFields.has(field)) {\n            throw new Error(`Field \"${field}\" is not supplied from resolver \"${ctx.resolverName}\".`);\n        }\n    }\n\n    if (records.length && ctx.parent) {\n        switch (ctx.parentType) {\n        case 'master':\n            if (ctx.foreignIdField) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-non-null-assertion\n                const parentId = getObjectValue(ctx.parent, ctx.masterIdField!);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const fName = getTrueCaseFieldName(records[0], ctx.foreignIdField!);\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-non-null-assertion\n                records = records.filter(x => x[fName!] === parentId);\n            }\n            break;\n        case 'detail':\n            if (ctx.foreignIdField) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-non-null-assertion\n                const parentId = getObjectValue(ctx.parent, ctx.foreignIdField!);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const fName = getTrueCaseFieldName(records[0], ctx.masterIdField!);\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-non-null-assertion\n                records = records.filter(x => x[fName!] === parentId);\n            }\n            break;\n        }\n    }\n\n    if (! config.noFiltering) {\n        records = applyWhereConditions(ctx, conditions, records);\n        ctx.resolverCapabilities.filtering = true;\n    }\n    if (fromCache) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        records = records.map(x => ({...x}))\n    }\n    if (config.noFiltering) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return records;\n    }\n\n    if (!config.noSorting && ctx.query && ctx.query.orderBy) {\n        const primaryPathLen = ctx.query.from[0].name.length;\n        if (ctx.graphPath.length === primaryPathLen && isEqualComplexName(ctx.graphPath, ctx.query.from[0].name)) {\n            if (ctx.query.orderBy.every(w => w.name.length === primaryPathLen + 1 &&\n                recordFields.has(w.name[w.name.length - 1].toLowerCase()))) {\n\n                records = sortRecords(ctx.query, records);\n                ctx.resolverCapabilities.sorting = true;\n            }\n        }\n    }\n\n    for (const field of recordFields.keys()) {\n        if (! requestedFields.has(field)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            removingFields.add(recordFields.get(field)!);\n        }\n    }\n    for (const record of records) {\n        for (const field of removingFields) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            delete record[field];\n        }\n    }\n\n    if (ctx.resolverCapabilities.sorting) {\n        if (typeof offset === 'number') {\n            records = records.slice(offset);\n        }\n        if (typeof limit === 'number') {\n            records = records.slice(0, limit);\n        }\n        ctx.resolverCapabilities.limit = true;\n        ctx.resolverCapabilities.offset = true;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return records;\n}\n\n\nfunction staticResolverBuilderGen<T>(parser: (s: T) => any[]):\n        (resolverName: string, fetcher: () => Promise<T>, config: StaticResolverConfig) => QueryResolverFn {\n\n    return (resolverName, fetcher, config) => {\n        return async (fields, conditions, limit, offset, ctx) => {\n            let cache: Map<string, any[]> | null;\n            let cachedRecords: any[] | null = null;\n\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (ctx.resolverData.cache) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n                cache = ctx.resolverData.cache;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (cache!.has(resolverName)) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    cachedRecords = cache!.get(resolverName)!;\n                }\n            } else {\n                cache = new Map<string, any[]>();\n                if (! config.noCache) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                    ctx.resolverData.cache = cache;\n                }\n            }\n\n            let fromCache = false;\n            let records: any[] | null = null;\n            if (cachedRecords === null) {\n                const fetched = await fetcher();\n                records = parser(fetched);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-unsafe-return\n                cache!.set(resolverName, records.map(x => ({...x})));\n            } else {\n                fromCache = true;\n                records = cachedRecords;\n            }\n\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return filterAndSliceRecords(fromCache, records, fields, conditions, limit, offset, ctx, config);\n        };\n    }\n}\n\n\nexport const staticJsonResolverBuilder:\n        (resolverName: string, fetcher: () => Promise<string>, config?: StaticResolverConfig) => QueryResolverFn =\n    (resolverName, fetcher, config) => {\n        return staticResolverBuilderGen(jsonRecordsParser)(resolverName, fetcher, config ?? defaultStaticResolverConfig);\n    };\n\n\nexport const staticCsvResolverBuilder:\n        (resolverName: string, fetcher: () => Promise<string>, config?: StaticResolverConfig) => QueryResolverFn =\n    (resolverName, fetcher, config) => {\n        return staticResolverBuilderGen(csvRecordsParser)(resolverName, fetcher, config ?? defaultStaticResolverConfig);\n    };\n\n\nexport const passThroughResolverBuilder:\n        (resolverName: string, fetcher: () => Promise<any[]>, config?: StaticResolverConfig) => QueryResolverFn =\n    (resolverName, fetcher, config) => {\n        return staticResolverBuilderGen(passThroughParser)(resolverName, fetcher, config ?? defaultStaticResolverConfig);\n    };\n"],"sourceRoot":""}