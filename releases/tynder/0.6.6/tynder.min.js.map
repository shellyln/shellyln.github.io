{"version":3,"sources":["webpack://tynder/webpack/universalModuleDefinition","webpack://tynder/webpack/bootstrap","webpack://tynder/./node_modules/liyad/src/s-exp/errors.ts","webpack://tynder/./src/types/tynder-schema-types.ts","webpack://tynder/./node_modules/liyad/src/s-exp/ast.ts","webpack://tynder/./src/lib/util.ts","webpack://tynder/./node_modules/liyad/src/s-exp/evaluate.ts","webpack://tynder/./src/operators.ts","webpack://tynder/./src/lib/protection.ts","webpack://tynder/./node_modules/liyad/src/s-exp/compile.ops/helpers.ts","webpack://tynder/./src/lib/escape.ts","webpack://tynder/./src/lib/errors.ts","webpack://tynder/./src/lib/resolver.ts","webpack://tynder/./node_modules/liyad/src/s-exp/global-this.ts","webpack://tynder/./src/lib/reporter.ts","webpack://tynder/./src/stereotypes/noop.ts","webpack://tynder/./src/validator.ts","webpack://tynder/./node_modules/liyad/src/s-exp/types.ts","webpack://tynder/./src/picker.ts","webpack://tynder/./src/stereotypes/date.ts","webpack://tynder/./src/constraints/unique.ts","webpack://tynder/./node_modules/liyad/src/s-exp/compile.ts","webpack://tynder/./node_modules/liyad/src/s-exp/compile.ops/index.ts","webpack://tynder/./node_modules/fruitsconfits/src/lib/types.ts","webpack://tynder/./node_modules/fruitsconfits/src/lib/parser.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/core.fn.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/core.operator.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/core.macro.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/core.symbol.ts","webpack://tynder/./node_modules/liyad/src/s-exp/parser.ts","webpack://tynder/./node_modules/liyad/src/s-exp/defaults.ts","webpack://tynder/./node_modules/liyad/src/s-exp/interpreters/index.ts","webpack://tynder/./node_modules/fruitsconfits/src/lib/string-parser.ts","webpack://tynder/./node_modules/fruitsconfits/src/lib/object-parser.ts","webpack://tynder/./src/lib/compiler.ts","webpack://tynder/./src/compiler.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/index.ts","webpack://tynder/./src/lib/codegen/typescript.ts","webpack://tynder/./src/lib/codegen/json-schema.ts","webpack://tynder/./src/lib/codegen/proto3.ts","webpack://tynder/./src/lib/codegen/graphql.ts","webpack://tynder/./src/lib/codegen/csharp.ts","webpack://tynder/./src/serializer.ts","webpack://tynder/./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setEvaluationCount","state","evalCount","config","maxEvalCount","checkParamsLength","args","min","max","length","Error","checkUnsafeVarNames","varName","checkUnsafeVarNamesEx","target","con","__proto__","ErrorTypes","quote","x","symbol","reservedNames","backquote","wrapByUnquote","unquote","spread","splice","isSymbol","SymbolPattern","NumberPattern","DatePattern","DateTimePattern","DateTimeNoTzPattern","nvl","v","alt","nvl2","f","toNumber","NaN","Number","resolveSplice","enableSplice","Array","isArray","slice","concat","resolveMacro","macroInfo","macroMap","lastErr","r1","formalArgs","fn","actualArgs","matchResult","matchMacroArgs","Boolean","lastIsSpread","error","next","resolveValueSymbolScope","nullIfNotDefined","scopes","localScope","scope","capturedScopes","isBlockLocal","globalScope","getGlobalScope","getScope","resolveValueSymbol","symInfo","symbolMap","valueSymbolResolverFallback","raiseOnUnresolvedSymbol","collectCapturedVariables","names","getCapturedScopes","a","unshift","assign","installScope","push","uninstallScope","pop","macroName","nm","startsWith","endsWith","tpos","lastIndexOf","tname","optimizeTailCall","fnBody","front","tail","if","self","varBaseName","tempVarsSyms","map","idx","until","let","set","evaluate","sym","resolveUnquote","eval","sprs","reverse","funcInfo","funcMap","funcSymbolResolverFallback","resolveFunctionSymbol","JSON","stringify","wrapExternalValue","car","cdr","dotted","picked","ty","kind","members","member","find","m2","operator","operands","omit","partial","optional","optTy","typeName","intersect","types","filter","lastTy","Map","from","values","oneOf","primitiveValue","ret","subtract","primitive","primitiveName","substring","regexpPatternStringType","pattern","repeated","option","sequenceOf","seq","sequence","enumType","ar","objectType","revMembers","membersProps","withName","additionalProps","checkRecursiveExtends","base","symlinkTargetName","baseTypes","z","derived","exts","ext","symlinkType","withTypeName","withOriginalTypeName","originalTypeName","withDocComment","docComment","withRange","minValue","maxValue","opt","withMinValue","withMaxValue","withGreaterThan","greaterThanValue","withLessThan","lessThanValue","withMinLength","minLength","withMaxLength","maxLength","withMatch","withStereotype","stereotype","withConstraint","customConstraints","customConstraintsArgs","withForceCast","forceCast","withRecordType","isRecordTypeField","withMeta","meta","withMsg","messages","message","withMsgId","messageId","dummyTargetObject","g","globalObj","objConstructor","funConstructor","Function","e","window","global","globalThis","constructor","toString","isUnsafeVarNames","applyMacros","tok","stripQuote","stripQuoteOrPass","getScope_stateApplied","resolveValueSymbol_dynamic","checkUnsafeVarNames_dynamic","escapeString","replace","ValidationError","ctx","super","updateSchema","original","schema","has","resolved","resolveMemberNames","rootSym","memberTreeSymbols","memberPos","addTypeName","mt","memberSym","join","k","test","memberTree","resolveSymbols","ctx2","nestLevel","symlinkStack","findIndex","ty2","xTy","link","link2","mergeTypeAndSymlink","baseSymlinks","isDeserialization","d2","operators","ctx3","resolverOps","resolveSchema","opts","ent","entries","errorTypeNames","defaultMessages","invalidDefinition","required","typeUnmatched","additionalPropUnmatched","repeatQtyUnmatched","sequenceUnmatched","valueRangeUnmatched","valuePatternUnmatched","valueLengthUnmatched","valueUnmatched","getErrorMessage","errType","InvalidDefinition","Required","TypeUnmatched","AdditionalPropUnmatched","RepeatQtyUnmatched","SequenceUnmatched","ValueRangeUnmatched","ValuePatternUnmatched","ValueLengthUnmatched","ValueUnmatched","getExpectedType","String","formatErrorMessage","msg","data","tr","topRepeatable","dict","source","flags","dataPath","entryName","parentType","substitutions","RegExp","reportError","errorMessages","dataPathEntryArray","typeStack","pt","pi","isSet","len","j","q","constraints","cSrces","cSrc","pat","val","errors","code","reportErrorWithPush","tyidx","noopStereotype","tryParse","evaluateFormula","valueOrFormula","compare","b","tyA","isNaN","doCast","checkStereotypes","stereotypes","parsed","targetType","parseFloat","Math","trunc","BigInt","checkCustomConstraints","ccName","cc","kinds","includes","check","validateRoot","dataIndex","validateNeverTypeAssertion","chkSt","styp","mapper","validateAnyTypeAssertion","validateUnknownTypeAssertion","chkTarget","styVal","err","valueRangeErr","valueLengthErr","validatePrimitiveTypeAssertion","validatePrimitiveValueTypeAssertion","retVals","validateRepeatedAssertion","dIdx","sIdx","spreadLen","optionalOmitted","checkSpreadQuantity","ts","index","checkOptionalQuantity","savedErrLen","validateSequenceAssertion","choosed","savedCtxRecordTypeFieldValidated","recordTypeFieldValidated","count","firstErrLen","tyOne","e2","checkAll","validateOneOfAssertion","validateEnumAssertion","retVal","dataMembers","Set","noAdditionalProps","add","delete","getAdditionalMembers","allowImplicit","matchedAssertions","ap","at","hasError","size","validateObjectAssertion","validate","isType","assertType","getType","FatalError","MaxEvaluationCountError","ScriptTerminationError","where","pickMapper","pickRoot","pick","patch","needle","merge","FyPattern","FormulaPattern","UtcDate","Date","year","month","date","hours","minutes","seconds","ms","setUTCDate","setUTCFullYear","setUTCMonth","setUTCHours","setUTCMinutes","setUTCSeconds","setUTCMilliseconds","setTime","parse","UTC","getUTCFullYear","getUTCMonth","getUTCDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","LcDate","setDate","setFullYear","setMonth","setHours","setMinutes","setSeconds","setMilliseconds","getTime","evaluateFormulaBase","dateCtor","errMsg","formula","split","now","today","exec","parseInt","mo","yr","dateStereotype","datetimeStereotype","mapperErrMsg","checkerGen","fields","mapped","CMP","field","compileCore","_$_vars","compileValue","compFnBody","varNames","varsCount","compileToken","body","ops","arr","varNamesCount","varDefs","makeScope","scoped","varNamesCopy","enableTailCallOptimization","thiz","compFormalArgs","compFnBodyRoot","evalCompiledLambda","_$_state","compileLambda","registerOperators","raise","quoted","vName","symName","checkNameCalled","checkNamePos","str","not","w1","w0","hasSpread","ParseError","result","parserInput","src","context","start","end","templateArgs","templateArgsPos","zeroWidth","helper","input","succeeded","tokens","zeroWidthError","pos","beginning","quantify","parser","matched","first","parsers","last","or","reduce","transform","trans","ctxTrans","t2","lookAhead","lookBehind","applyProductionRules","lexer","lexerInput","lexResult","completed","maxApply","rules","rule","rtol","nextSrc","makeProgram","$car","$$first","$cdr","$cons","$$firstAndSecond","$first","$second","$$second","$last","$rest","$firstAndSecond","$atom","$eq","$notEq","$list","$__scope","returnMultiple","kv","kvSym","kvName","xSym","xName","$__lambda","fa","enableSpread","$comp$__lambda","compile","$apply","apply","$raise","$pipe","$__let","$boolean","$$boolean","$not","$$not","$__and","prev","curr","$__or","$ambiguousEq","$$ambiguousEq","$ambiguousNotEq","$lt","$le","$gt","$ge","$typeof","tyName","$symbol","$isSymbol","$isNull","$isNil","$isUndefined","$isList","$isString","$isNumber","$isNaN","$isFinite","isFinite","$isInteger","isInteger","$toString","$toNumber","assignBlacklist","$objectAssign","$jsonStringify","$jsonParse","$now","$datetimeFromIso","dt","$datetime","padStart","$datetimeLc","$datetimeToIsoString","toISOString","$datetimeToComponents","getUTCDay","$datetimeToComponentsLc","getTimezoneOffset","getDay","$match","enableRegExpMatchOperators","$consoleLog","console","log","$consoleError","$consoleTrace","trace","$consoleTime","time","$consoleTimeEnd","timeEnd","$consoleTimeLog","timeLog","st","info","fArgs","aArgs","list","inprog","path","subst","tempVarSym","keyName","compilationOperators","macros","compilationMacros","POSITIVE_INFINITY","NEGATIVE_INFINITY","EPSILON","MAX_VALUE","MIN_VALUE","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","isEOF","ch","trim","isNumberFirstChar","isNumberAfterSignChar","isSymbolFirstChar","lookCurrentLineHint","line","strings","getChar","virtualEof","disableEscape","eof","eofSeq","ch1","ch2","fromCodePoint","lookAheads","chs","skipWhitespaces","parseNumber","parseSymbol","enableShorthands","match","ws","parseStringOrComment","valuesStartSeq","valuesStopChar","allowPhysicalEof","eofSeqs","parseList","parseString","parseHereDoc","attrs","inner","parseSingleLineComment","comment","parseMultiLineComment","parseOneToken","ahead","isSpliceUnquote","aheads","enableHereDoc","isHereDoc","Template","ahs","enableVerbatimStringLiteral","listStopChar","initialList","stripComments","defaultConfig","enableEvaluate","enableCompilationOperators","returnMultipleRoot","cons","atom","eq","lambda","defun","cond","while","doWhile","doUntil","defvar","setq","and","gensym","catch","symbols","funcs","initState","globals","resetState","templateStringsParam","criteria","conv","argIdx","objSequence","comparator","objClass","needles","some","objClassNot","$s","params","rawToToken","cls","charClass","notCls","codePointAt","charClassNot","clsFn","charClassByNeedleFn","cat","concatTokens","once","repeat","qty","combine","erase","isAlpha","isUpper","isLower","isNumber","isNonZeroNumber","isBinNum","isOctNum","isHexNum","isAlNum","isSpace","isSpaceWithinSingleLine","isControl","isWord","isNewline","isAny","binSep","octSep","hexSep","decimalIntegerNumber","bigDecimalIntegerNumber","floatingPointNumber","classes","alpha","upper","lower","num","nonzero","bin","oct","hex","alnum","space","spaceWithinSingleLine","ctrl","newline","word","any","numbers","prefixes","int","bigint","float","isParam","behind","getStringParsers","rawToken","$o","getObjectParsers","directiveLineComment","directiveBlockComment","lineComment","hashLineComment","blockComment","commentOrSpace","trueValue","falseValue","nullValue","undefinedValue","positiveInfinityValue","negativeInfinityValue","nanValue","binaryIntegerValue","octalIntegerValue","decimalIntegerValue","bigDecimalIntegerValue","floatingPointNumberValue","numberValue","stringEscapeSeq","signleQuotStringValue","doubleQuotStringValue","backQuotStringValue","stringValue","regexpStringValue","symbolName","decoratorSymbolName","simpleConstExpr","objKey","listValue","ast","token","objectValue","objectKeyValuePair","constExpr","primitiveValueNoNullUndefined","primitiveTypeName","additionalPropPrimitiveTypeName","nullUndefinedTypeName","simpleOrDottedTypeName","sequenceType","spreadOrComplexType","arraySizeFactorInner","arraySizeFactor","complexArrayType","complexType","partialType","pickOrOmitType","genericOrSimpleType","spreadType","decorator","decoratorsClause","complexTypeInnerRoot","edge","interfaceDefInner","complexTypeInnerWOSinpleArrayType","op","binaryOp","op1","op2","isOperator","complexTypeExprRule3","complexTypeExprRule2","complexTypeExprRule1","setDocComment","text","typeDef","interfaceExtendsClause","interfaceKey","interfaceKeyTypePair","separator","interfaceDef","enumKeyValue","enumDef","internalDef","constDef","constDefNoErr","exportedDef","declareTypeAndEnumStatement","declareVarStatement","defStatement","externalSymbolAndType","externalTypeDef","importStatement","definition","program","lineAndCol","col","getLineAndCol","lisp","install","conf","startup","evaluateAST","repl","fRepl","sync","setGlobals","appendGlobals","setStartup","setStartupAST","appendStartup","appendStartupAST","installer","SExpression","mapTyToTySet","gensymCount","def","tySet","exported","isDeclare","passthru","docCommentText","passThruCodeBlock","ref","memberNames","noOutput","redef","export","external","asConst","isConst","asDeclare","directive","parseExternalDirective","greaterThan","lessThan","formatTypeName","formatTypeScriptCodeDocComment","indent","indexOf","trimLeft","generateTypeScriptCodeInner","isInterface","generateTypeScriptCodePrimitive","generateTypeScriptCodePrimitiveValue","generateTypeScriptCodeRepeated","generateTypeScriptCodeSequence","generateTypeScriptCodeOneOf","generateTypeScriptCodeOptional","generateTypeScriptCodeEnum","memberLines","additionalPropsLines","ak","formatAdditionalPropsName","propsLines","generateTypeScriptCodeObject","generateTypeScriptCode","indent0","indent1","addMetaInfo","a2","changed","description","minItems","maxItems","minimum","maximum","exclusiveMinimum","exclusiveMaximum","generateJsonSchemaInner","$ref","type","items","anyOf","enum","properties","patternProperties","patternPropsCount","additionalProperties","generateJsonSchemaObject","$schema","definitions","generateJsonSchema","asTs","generateProto3CodeInner","formatProto3CodeDocComment","appendOptionalModifier","generateProto3CodePrimitive","generateProto3CodePrimitiveValue","generateProto3CodeRepeated","generateProto3CodeOneOf","filtered","isNullableOneOf","formatMemberType","generateProto3CodeOptional","generateProto3CodeEnum","sep","generateProto3CodeObject","generateProto3Code","generateGraphQlCodeInner","formatGraphQlCodeDocComment","isUnion","generateGraphQlCodeOneOf","generateGraphQlCodePrimitive","generateGraphQlCodePrimitiveValue","generateGraphQlCodeRepeated","generateGraphQlCodeEnum","generateGraphQlCodeObject","generateGraphQlCode","generateCSharpCodeInner","formatCSharpCodeDocComment","generateCSharpCodePrimitive","generateCSharpCodePrimitiveValue","generateCSharpCodeRepeated","generateCSharpCodeOneOf","generateCSharpCodeObject","addAttributes","generateCSharpCodeOptional","generateCSharpCode","isFirst","accessModifier","TynderSchemaVersion","serializeInner","hasInfo","hasMetaInfo","serializeToObject","version","current","serialize","keys","deserializeRegExp","deserializeInner","deserializeFromObject","obj","deserialize","unique"],"mappings":"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","file":"tynder.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tynder\"] = factory();\n\telse\n\t\troot[\"tynder\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 19);\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         MaxEvaluationCountError } from './types';\r\nimport { globalObj,\r\n         objConstructor,\r\n         funConstructor }          from './global-this';\r\n\r\n\r\n\r\nexport function setEvaluationCount(state: SxParserState) {\r\n    state.evalCount++;\r\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\r\n        throw new MaxEvaluationCountError();\r\n    }\r\n}\r\n\r\n\r\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\r\n    if (args.length < min) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\r\n    }\r\n    if (max && max < args.length) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\r\n    }\r\n    return args;\r\n}\r\n\r\n\r\nexport function checkUnsafeVarNames(name: string, varName: string) {\r\n    if (varName === '__proto__' ||\r\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\r\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    if (varName === 'prototype' || varName === 'constructor') {\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    if (objConstructor.hasOwnProperty(varName)) {\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    if (varName === 'call' || varName === 'arguments' || varName === 'caller') {\r\n        // NOTE: arguments, caller are not accessible in strict mode\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    return varName;\r\n}\r\n\r\n\r\nexport function checkUnsafeVarNamesEx(name: string, target: any, varName: string) {\r\n    if (target === globalObj ||\r\n        varName === '__proto__' ||\r\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\r\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    if (varName === 'prototype' || varName === 'constructor') {\r\n        if (target === null || target === void 0 || typeof target === 'function') {\r\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n        }\r\n    }\r\n    if (target === null || target === void 0 || target === objConstructor) {\r\n        if (objConstructor.hasOwnProperty(varName)) {\r\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n        }\r\n    }\r\n    if (target === null || target === void 0 || target === funConstructor) {\r\n        // checking 'call', 'arguments', 'caller', ...\r\n        let con: any = funConstructor;\r\n        while (con) {\r\n            if (con.hasOwnProperty(varName)) {\r\n                throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n            }\r\n            con = con.__proto__;\r\n        }\r\n    }\r\n    if (typeof target === 'function') {\r\n        if (!target.hasOwnProperty(varName)) {\r\n            // function's prototypes' members\r\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n        }\r\n    }\r\n    return varName;\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport type PrimitiveValueTypes = number | bigint | string | boolean | null | undefined;                                            // TODO: Function\nexport type PrimitiveValueTypeNames = 'number' | 'integer' | 'bigint' | 'string' | 'boolean' | 'null' | 'undefined';                // TODO: Function, DateStr, DateTimeStr\nexport type OptionalPrimitiveValueTypeNames = 'number?' | 'integer?' | 'bigint?' | 'string?' | 'boolean?' | 'null?' | 'undefined?'; // TODO: Function?, DateStr?, DateTimeStr?\nexport type PlaceholderTypeNames = 'never' | 'any' | 'unknown';\nexport type OptionalPlaceholderTypeNames = 'never?' | 'any?' | 'unknown?';\n\n\n\nexport enum ErrorTypes {\n    InvalidDefinition = 1,\n    Required,                // (all)\n    TypeUnmatched,           // Never/Unknown/Primitive/Object\n    AdditionalPropUnmatched, // Additional prop\n    RepeatQtyUnmatched,      // Repeated/Spread\n    SequenceUnmatched,       // Sequence\n    ValueRangeUnmatched,     // Primitive: minValue, maxValue, greaterThanValue, lessThanValue\n    ValuePatternUnmatched,   // Primitive: pattern\n    ValueLengthUnmatched,    // Primitive: minLength, maxLength\n    ValueUnmatched,          // PrimitiveValue\n}\n\n\nexport type ErrorMessages = Partial<{\n    invalidDefinition: string,\n    required: string,\n    typeUnmatched: string,\n    additionalPropUnmatched: string,\n    repeatQtyUnmatched: string,\n    sequenceUnmatched: string,\n    valueRangeUnmatched: string,\n    valuePatternUnmatched: string,\n    valueLengthUnmatched: string,\n    valueUnmatched: string,\n}>;\n\n\nexport interface TypeAssertionBase {\n    messageId?: string;\n    message?: string;             // Only one of 'message' or 'messages' can be set.\n    messages?: ErrorMessages;     // Only one of 'message' or 'messages' can be set.\n    name?: string;                // Member name or 'typeName' below. For error reporting and codegen.\n    typeName?: string;            // Named user defined 'type' or 'interface' name. For error reporting and codegen.\n    originalTypeName?: string;    // To keep right hand side type name of `type Y = X;`.\n    stereotype?: string;          // `stereotype` decorator value.\n    customConstraints?: string[]; //\n    customConstraintsArgs?: {     //\n        [constraintName: string]: any;\n    };\n    forceCast?: boolean;          // `forceCast` decorator value.\n    isRecordTypeField?: boolean;  // true if `recordType` decorator is set.\n    meta?: any;                   // `meta` decorator value; user defined custom properties (meta informations).\n    docComment?: string;          // Doc comment.\n    passThruCodeBlock?: string;   // Store a pass-thru code block (e.g. import statement). use it with kind===never\n    noOutput?: boolean;           // If true, skip code generation.\n}\n\n\nexport interface NeverTypeAssertion extends TypeAssertionBase {\n    kind: 'never';\n}\n\n\nexport interface AnyTypeAssertion extends TypeAssertionBase {\n    kind: 'any';\n}\n\n\nexport interface UnknownTypeAssertion extends TypeAssertionBase {\n    kind: 'unknown';\n}\n\n\nexport interface PrimitiveTypeAssertionConstraints {\n    minValue?: number | string | null; // TODO: bigint\n    maxValue?: number | string | null; // TODO: bigint\n    greaterThanValue?: number | string | null;\n    lessThanValue?: number | string | null;\n    minLength?: number | null;\n    maxLength?: number | null;\n    pattern?: RegExp | null;\n}\n\n\nexport interface PrimitiveTypeAssertion extends TypeAssertionBase, PrimitiveTypeAssertionConstraints {\n    kind: 'primitive';\n    primitiveName: PrimitiveValueTypeNames;\n}\n\n\nexport interface PrimitiveValueTypeAssertion extends TypeAssertionBase {\n    kind: 'primitive-value';\n    value: PrimitiveValueTypes;\n    primitiveName?: 'bigint'; // for deserializer hinting\n}\n\n\nexport interface RepeatedAssertionConstraints {\n    min: number | null;\n    max: number | null;\n}\n\n\nexport interface RepeatedAssertion extends TypeAssertionBase, RepeatedAssertionConstraints {\n    kind: 'repeated';\n    repeated: TypeAssertion;\n}\n\n\nexport interface SpreadAssertion extends TypeAssertionBase, RepeatedAssertionConstraints {\n    kind: 'spread';\n    spread: TypeAssertion;\n}\n\n\nexport interface SequenceAssertion extends TypeAssertionBase {\n    kind: 'sequence';\n    sequence: TypeAssertion[];\n}\n\n\nexport interface OneOfAssertion extends TypeAssertionBase {\n    kind: 'one-of';\n    oneOf: TypeAssertion[];\n}\n\n\nexport interface OptionalAssertion extends TypeAssertionBase {\n    kind: 'optional';\n    optional: TypeAssertion;\n}\n\n\nexport interface EnumAssertion extends TypeAssertionBase {\n    kind: 'enum';\n    values: Array<[\n        string,           // enum key\n        number | string,  // enum value\n        string?,          // doc comment\n    ]>;\n    isConst?: boolean;    // If true, it is `const enum`\n}\n\n\nexport type ObjectAssertionMember = [\n    string,         // name\n    TypeAssertion,  // type\n] | [\n    string,         // name\n    TypeAssertion,  // type\n    boolean,        // If true, defined by ancestor types\n] | [\n    string,         // name\n    TypeAssertion,  // type\n    boolean,        // If true, defined by ancestor types\n    string,         // doc comment\n];\n\n\n\nexport type AdditionalPropsKey = Array<'string' | 'number' | RegExp>;\n\n\nexport type AdditionalPropsMember = [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n] | [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n    boolean,             // If true, defined by ancestor types\n] | [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n    boolean,             // If true, defined by ancestor types\n    string,              // doc comment\n];\n\n\nexport interface ObjectAssertion extends TypeAssertionBase {\n    kind: 'object';\n    members: ObjectAssertionMember[];\n    additionalProps?: AdditionalPropsMember[];\n    baseTypes?: Array<ObjectAssertion | AssertionSymlink>;\n}\n\n\nexport interface AssertionSymlink extends TypeAssertionBase {\n    kind: 'symlink';\n    symlinkTargetName: string;\n    memberTree?: string[];\n}\n\n\n// TODO: Add it to resolve backref in type operator's operands\nexport interface AssertionOperator extends TypeAssertionBase {\n    kind: 'operator';\n    operator: string;\n    operands: Array<TypeAssertion | string>;\n}\n\n\nexport type TypeAssertion =\n    NeverTypeAssertion |\n    AnyTypeAssertion |\n    UnknownTypeAssertion |\n    PrimitiveTypeAssertion |\n    PrimitiveValueTypeAssertion |\n    RepeatedAssertion |\n    SpreadAssertion |\n    SequenceAssertion |\n    OneOfAssertion |\n    OptionalAssertion |\n    EnumAssertion |\n    ObjectAssertion |\n    AssertionSymlink |\n    AssertionOperator;\n\n\nexport interface SerializedSchemaInfo {\n    version: string;\n    ns: {\n        [namespaceName: string]: {\n            [typeName: string]: TypeAssertion;\n        }\n    };\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol }     from './types';\r\n\r\n\r\n\r\nexport function quote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.quote}, x];\r\n}\r\n\r\n\r\nexport function isQuoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.quote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function backquote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.backquote}, x];\r\n}\r\n\r\n\r\nexport function isBackquoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.backquote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function wrapByUnquote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.unquote}, x];\r\n}\r\n\r\n\r\nexport function isUnquoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.unquote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function spread(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.spread}, x];\r\n}\r\n\r\n\r\nexport function splice(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.splice}, x];\r\n}\r\n\r\n\r\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\r\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\r\n        if (name !== void 0) {\r\n            return x.symbol === name ? x : null;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\nexport const SymbolPattern = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\nexport const NumberPattern = /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)$/;\nexport const DatePattern = /^(\\d{4}-[01]\\d-[0-3]\\d)$/;\nexport const DateTimePattern =\n    /^((?:(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d))(?:[+-][0-2]\\d:[0-5]\\d|Z))$/;\nexport const DateTimeNoTzPattern =\n    /^((?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d))$/;\n\n\nexport function nvl(v: any, alt: any) {\n    return (\n        v !== null && v !== void 0 ? v : alt\n    );\n}\n\n\nexport function nvl2(v: any, f: (x: any) => any, alt: any) {\n    return (\n        v !== null && v !== void 0 ? f(v) : alt\n    );\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedPair,\r\n         SxDottedFragment,\r\n         SxToken,\r\n         SxScope,\r\n         CapturedScopes,\r\n         SxMacroInfo }           from './types';\r\nimport { isSymbol }              from './ast';\r\nimport { setEvaluationCount,\r\n         checkUnsafeVarNamesEx } from './errors';\r\n\r\n\r\n\r\nexport function toNumber(x: any) {\r\n    switch (typeof x) {\r\n    case 'object': case 'symbol': case 'function':\r\n        return NaN;\r\n    default:\r\n        return Number(x);\r\n    }\r\n}\r\n\r\n\r\nexport function resolveUnquote(state: SxParserState, r: SxToken[]) {\r\n    for (let i = 0; i < r.length; i++) {\r\n        const symUnquote = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.unquote);\r\n        if (symUnquote) {\r\n            r = r.slice(0, i).concat([evaluate(state, (r[i] as SxToken[])[1])], r.slice(i + 1));\r\n        }\r\n        if (Array.isArray(r[i])) {\r\n            r = r.slice(0);\r\n            r[i] = resolveUnquote(state, r[i] as SxToken[]);\r\n        }\r\n    }\r\n    return resolveSplice(state, r);\r\n}\r\n\r\n\r\nexport function resolveSplice(state: SxParserState, r: SxToken[]) {\r\n    if (state.config.enableSplice) {\r\n        for (let i = r.length - 1; i >= 0; i--) {\r\n            const symSplice = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.splice);\r\n            if (symSplice) {\r\n                r = r.slice(0, i).concat((r[i] as SxToken[])[1], r.slice(i + 1));\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n}\r\n\r\n\r\nexport function resolveMacro(state: SxParserState, x: SxSymbol, r: SxToken[]) {\r\n    const macroInfo = state.macroMap.get(x.symbol);\r\n    let lastErr = null;\r\n    if (macroInfo) {\r\n        let m: SxMacroInfo | undefined = macroInfo;\r\n        const r1 = r.slice(1);\r\n        while (m) {\r\n            if (m.formalArgs) {\r\n                const matchResult = matchMacroArgs(state, x.symbol, m.formalArgs, Boolean(m.lastIsSpread), r1);\r\n                if (! matchResult.error) {\r\n                    return {\r\n                        fn: m.fn(state, x.symbol, matchResult.formalArgs as SxSymbol[]),\r\n                        actualArgs: r.slice(0, 1).concat(matchResult.actualArgs as SxToken[]),\r\n                    };\r\n                }\r\n                lastErr = matchResult.error;\r\n                m = m.next;\r\n            } else {\r\n                return {\r\n                    fn: m.fn(state, x.symbol),\r\n                    actualArgs: r,\r\n                };\r\n            }\r\n        }\r\n        if (lastErr) {\r\n            throw new Error(lastErr);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\r\n    if (typeof x === 'function') {\r\n        return x;\r\n    }\r\n    const funcInfo = state.funcMap.get(x.symbol);\r\n    if (funcInfo) {\r\n        return funcInfo.fn(state, x.symbol);\r\n    } else {\r\n        const v = resolveValueSymbol(state, x);\r\n        if (typeof v === 'function') {\r\n            return v;\r\n        }\r\n        if (state.config.funcSymbolResolverFallback) {\r\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\r\n            return localScope.scope;\r\n        }\r\n        if (localScope.capturedScopes &&\r\n            Object.prototype.hasOwnProperty.call(localScope.capturedScopes, x.symbol)) {\r\n            return localScope.capturedScopes[x.symbol];\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    const globalScope = getGlobalScope(state);\r\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\r\n        return globalScope.scope;\r\n    }\r\n    return nullIfNotDefined ? null : getScope(state).scope;\r\n}\r\n\r\n\r\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\r\n    const scope = resolveValueSymbolScope(state, x, true);\r\n    if (scope) {\r\n        return scope[x.symbol];\r\n    }\r\n    const symInfo = state.symbolMap.get(x.symbol);\r\n    if (symInfo) {\r\n        return symInfo.fn(state, x.symbol);\r\n    } else {\r\n        if (state.config.valueSymbolResolverFallback) {\r\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function collectCapturedVariables(state: SxParserState, names: SxSymbol[]): CapturedScopes {\r\n    const capturedScopes: CapturedScopes = {};\r\n    for (const n of names) {\r\n        const scope = resolveValueSymbolScope(state, n, true);\r\n        if (scope === null) {\r\n            throw new Error(`[SX] collectCapturedVariables: Unresolved symbols ${n}`);\r\n        }\r\n        checkUnsafeVarNamesEx('collectCapturedVariables', capturedScopes, n.symbol);\r\n        capturedScopes[n.symbol] = scope;\r\n    }\r\n    return capturedScopes;\r\n}\r\n\r\n\r\nexport function getCapturedScopes(state: SxParserState): CapturedScopes | undefined {\r\n    const a: CapturedScopes[] = [];\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope.capturedScopes) {\r\n            a.unshift(localScope.capturedScopes);\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    return a.length > 0 ? Object.assign({}, ...a) : void 0;\r\n}\r\n\r\n\r\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean, capturedScopes?: CapturedScopes): any {\r\n    state.scopes.push({isBlockLocal, scope, capturedScopes});\r\n}\r\n\r\n\r\nexport function uninstallScope(state: SxParserState): any {\r\n    if (state.scopes.length < 2) {\r\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\r\n    }\r\n    return state.scopes.pop();\r\n}\r\n\r\n\r\nexport function getScope(state: SxParserState) {\r\n    return state.scopes[state.scopes.length - 1];\r\n}\r\n\r\n\r\nexport function getGlobalScope(state: SxParserState) {\r\n    return state.scopes[0];\r\n}\r\n\r\n\r\nexport function matchMacroArgs(\r\n        state: SxParserState, macroName: string,\r\n        formalArgs: SxSymbol[], lastIsSpread: boolean, actualArgs: SxToken[]) {\r\n\r\n    formalArgs = formalArgs.slice(0);\r\n    actualArgs = actualArgs.slice(0);\r\n    if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n        return ({ error: `[SX] macro call (${macroName}): Actual args too short: actual ${\r\n            actualArgs.length} / formal ${formalArgs.length}.` });\r\n    }\r\n    for (let i = formalArgs.length - (lastIsSpread ? 2 : 1); i >= 0; i--) {\r\n        let nm = formalArgs[i].symbol;\r\n        if (nm.startsWith('!')) {\r\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1);\r\n            nm = formalArgs[i].symbol;\r\n\r\n            if (! isSymbol(actualArgs[i])) {\r\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\r\n            }\r\n        } else if (nm.startsWith('<') && nm.endsWith('>')) {\r\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1, -1);\r\n            nm = formalArgs[i].symbol;\r\n\r\n            if (isSymbol(actualArgs[i], nm)) {\r\n                formalArgs = formalArgs.slice(0, i).concat(formalArgs.slice(i + 1));\r\n                actualArgs = actualArgs.slice(0, i).concat(actualArgs.slice(i + 1));\r\n            } else {\r\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not expected symbol.` });\r\n            }\r\n        } else {\r\n            const tpos = nm.lastIndexOf(':');\r\n            if (0 < tpos) {\r\n                const tname = nm.slice(tpos + 1);\r\n                switch (tname) {\r\n                case 'number':\r\n                    if (typeof actualArgs[i] !== 'number') {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not number.` });\r\n                    }\r\n                    break;\r\n                case 'string':\r\n                    if (typeof actualArgs[i] !== 'string') {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not string.` });\r\n                    }\r\n                    break;\r\n                case 'function':\r\n                    if (! (Array.isArray(actualArgs[i]) && isSymbol((actualArgs[i] as any)[0]))) {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not function.` });\r\n                    }\r\n                    break;\r\n                case 'list':\r\n                    if (! Array.isArray(actualArgs[i])) {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not list.` });\r\n                    }\r\n                    break;\r\n                case 'symbol':\r\n                    if (! isSymbol(actualArgs[i])) {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\r\n                    }\r\n                    break;\r\n                case 'any':\r\n                    break;\r\n                default:\r\n                    return ({ error: `[SX] macro call (${macroName}): Formal arg(${i}: ${nm}) is unknown type ${tname}.` });\r\n                }\r\n                formalArgs[i].symbol = formalArgs[i].symbol.slice(0, tpos);\r\n            }\r\n        }\r\n    }\r\n    return ({ formalArgs, actualArgs });\r\n}\r\n\r\n\r\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //    formalArgs: 'sym1 ... 'symN\r\n    //        fnBody: 'expr1 ... 'exprN\r\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\r\n        const front = fnBody.slice(0, fnBody.length - 1);\r\n        const tail = fnBody[fnBody.length - 1];\r\n        if (tail && (typeof tail[0] === 'object') && tail[0].symbol === state.config.reservedNames.if) {\r\n            // S expression: ($if cond t-expr f-expr)\r\n            if (Array.isArray(tail[3]) && (typeof tail[3][0] === 'object') && tail[3][0].symbol === state.config.reservedNames.self) {\r\n                // S expression (recursive):\r\n                //     (                                 ;; fnBody\r\n                //         expr1 ... exprN-1             ;; front\r\n                //         ($if cond                     ;; tail[0] [1]\r\n                //             t-expr                    ;;     [2]\r\n                //             ($self                    ;;     [3]\r\n                //                 rArgs1 ... rArgsN) )  ;; tail[4] ... [N+4]\r\n                //     )\r\n                //\r\n                //  -> S exp (tail call optimization):\r\n                //     (                                                                  ;; fnBody\r\n                //         ($until cond                                                   ;; tail[1]\r\n                //             ($clisp-let (tempsym1 ... tempsymN)                        ;;\r\n                //                 expr1 ... exprN-1                                      ;; front\r\n                //                 ($set tempsym1   rArgs1) ... ($set tempsymN   rArgsN)  ;; tail[4] ... [N+4]\r\n                //                 ($set     sym1 tempsym1) ... ($set     symN tempsymN)  ;;\r\n                //             )                                                          ;;\r\n                //         )                                                              ;;\r\n                //         expr1 ... exprN-1                                              ;; front\r\n                //         t-expr                                                         ;; tail[2]\r\n                //     )\r\n\r\n                const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\r\n                const tempVarsSyms = formalArgs.map((a, idx) => ({symbol: `${varBaseName}_$i${idx}_${a.symbol}`}));\r\n\r\n                return [\r\n                    [{symbol: state.config.reservedNames.until}, tail[1],\r\n                        [{symbol: state.config.reservedNames.let}, [...tempVarsSyms],\r\n                            ...front,\r\n                            ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\r\n                                [{symbol: state.config.reservedNames.set}, tempVarsSyms[idx], x])),\r\n                            ...(tempVarsSyms.map((x, idx) =>\r\n                                [{symbol: state.config.reservedNames.set}, formalArgs[idx], x])),\r\n                        ],\r\n                    ],\r\n                    ...front,\r\n                    tail[2],\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return fnBody;\r\n}\r\n\r\n\r\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\r\n    setEvaluationCount(state);\r\n\r\n    if (x === null || x === void 0) {\r\n        return x;\r\n    }\r\n    let r: SxToken = x;\r\n\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                return r;\r\n            }\r\n            r = resolveSplice(state, r);\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym, r);\r\n                if (m) {\r\n                    r = m.fn(m.actualArgs as SxToken[]);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n        setEvaluationCount(state);\r\n    }\r\n\r\n    if (Array.isArray(r)) {\r\n        r = r.slice(0);\r\n        if (0 < r.length) {\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                if (sym.symbol === state.config.reservedNames.quote) {\r\n                    return r.slice(1, 2)[0];\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.backquote) {\r\n                    r = r.slice(1, 2)[0];\r\n                    if (Array.isArray(r)) {\r\n                        r = resolveUnquote(state, r);\r\n                    }\r\n                    return r;\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.eval) {\r\n                    return evaluate(state, evaluate(state, r.slice(1, 2)[0]));\r\n                }\r\n            }\r\n\r\n            const sprs = [];\r\n            for (let i = 1; i < r.length; i++) {\r\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\r\n                if (symSpr) {\r\n                    sprs.push(i);\r\n                    const a = evaluate(state, (r[i] as SxToken[])[1]);\r\n                    r[i] = Array.isArray(a) ? a : [a];\r\n                } else {\r\n                    r[i] = evaluate(state, r[i]);\r\n                }\r\n            }\r\n            for (const i of sprs.reverse()) {\r\n                r = (r as SxToken[]).slice(0, i).concat(r[i], r.slice(i + 1));\r\n            }\r\n\r\n            let fn: any;\r\n            if (typeof r[0] === 'function') {\r\n                fn = r[0];\r\n            } else if (sym) {\r\n                fn = resolveFunctionSymbol(state, sym);\r\n            } else {\r\n                fn = evaluate(state, r[0]);\r\n            }\r\n\r\n            if (typeof fn === 'function') {\r\n                r = (fn as any)(...(r.slice(1)));\r\n            } else {\r\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\r\n            }\r\n        }\r\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\r\n        r = (r as SxExternalValue).value;\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\r\n        r = resolveValueSymbol(state, r as SxSymbol);\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\r\n        const car = evaluate(state, (r as SxDottedPair).car);\r\n        const cdr = evaluate(state, (r as SxDottedPair).cdr);\r\n        if (Array.isArray(cdr)) {\r\n            const a = (cdr as any[]).slice(0);\r\n            a.unshift(car);\r\n            r = a;\r\n        } else {\r\n            r = { car, cdr };\r\n        }\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\r\n        r = [\r\n            evaluate(state, (r as SxDottedFragment).dotted),\r\n        ];\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\r\n        r = [];\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { NeverTypeAssertion,\n         AnyTypeAssertion,\n         UnknownTypeAssertion,\n         PrimitiveValueTypes,\n         PrimitiveValueTypeNames,\n         OptionalPrimitiveValueTypeNames,\n         PlaceholderTypeNames,\n         OptionalPlaceholderTypeNames,\n         ErrorMessages,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         OptionalAssertion,\n         EnumAssertion,\n         ObjectAssertionMember,\n         AdditionalPropsKey,\n         AdditionalPropsMember,\n         ObjectAssertion,\n         AssertionSymlink,\n         AssertionOperator,\n         TypeAssertion }    from './types';\nimport { dummyTargetObject,\n         isUnsafeVarNames } from './lib/protection';\n\n\n\n// emulate Pick<T> // ex. Pick<Foo, 'a' | 'b'>\nexport function picked(ty: TypeAssertion, ...names: string[]): ObjectAssertion | AssertionOperator {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const name of names) {\n                const member = ty.members.find(x => x[0] === name);\n                if (member) {\n                    if (member[2]) {\n                        const m2: ObjectAssertionMember = [...member] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.push(m2);\n                    } else {\n                        members.push(member);\n                    }\n                }\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'picked',\n                operands: [ty, ...names],\n            });\n        }\n    default:\n        return ({\n            kind: 'object',\n            members: [],\n        });\n    }\n}\n\n\n// emulate Omit<T> // ex. Omit<Foo, 'a' | 'b'>\nexport function omit(ty: TypeAssertion, ...names: string[]): ObjectAssertion | AssertionOperator {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const member of ty.members) {\n                if (! names.find(name => member[0] === name)) {\n                    if (member[2]) {\n                        const m2: ObjectAssertionMember = [...member] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.push(m2);\n                    } else {\n                        members.push(member);\n                    }\n                }\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'omit',\n                operands: [ty, ...names],\n            });\n        }\n    default:\n        return ({\n            kind: 'object',\n            members: [],\n        });\n    }\n}\n\n\n// emulate Partial<T>\nexport function partial(ty: TypeAssertion): TypeAssertion {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const member of ty.members) {\n                let m: ObjectAssertionMember = member[1].kind === 'optional' ?\n                    member :\n                    [member[0], optional(member[1]), ...member.slice(2)] as ObjectAssertionMember;\n                if (m[2]) {\n                    m = [...m] as any;\n                    if (3 < m.length) {\n                        m[2] = false;\n                    } else {\n                        m.length = 2;\n                    }\n                }\n                m[1].name = m[0];\n                const optTy = {...(m[1] as OptionalAssertion).optional};\n                (m[1] as OptionalAssertion).optional = optTy;\n                if (optTy.name && optTy.name !== optTy.typeName) {\n                    delete optTy.name;\n                }\n                if (!optTy.name && optTy.typeName) {\n                    optTy.name = optTy.typeName;\n                }\n                members.push(m);\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'partial',\n                operands: [ty],\n            });\n        }\n    default:\n        return ty;\n    }\n}\n\n\n// intersection (a & b)\nexport function intersect(...types: TypeAssertion[]): TypeAssertion {\n    if (types.length === 0) {\n        throw new Error(`Empty intersection type is not allowed.`);\n    }\n    if (0 < types.filter(x => x && typeof x === 'object' &&\n            (x.kind === 'symlink' || x.kind === 'operator')).length) {\n        return ({\n            kind: 'operator',\n            operator: 'intersect',\n            operands: types.slice(),\n        });\n    }\n    let lastTy: TypeAssertion | null = null;\n    const members = new Map<string, ObjectAssertionMember>();\n\n    for (const ty of types) {\n        if (ty && typeof ty === 'object') {\n            if (lastTy && lastTy.kind !== ty.kind) {\n                return ({\n                    kind: 'never',\n                });\n            }\n            lastTy = ty;\n            if (ty.kind === 'object') {\n                for (const m of ty.members) {\n                    if (m[2]) {\n                        const m2: ObjectAssertionMember = [...m] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.set(m[0], m2); // Overwrite if exists\n                    } else {\n                        members.set(m[0], m);  // Overwrite if exists\n                    }\n                }\n            }\n        } else {\n            return ({\n                kind: 'never',\n            });\n        }\n    }\n    if (lastTy && lastTy.kind !== 'object') {\n        return lastTy;\n    } else {\n        return ({\n            kind: 'object',\n            members: Array.from(members.values()),\n        });\n    }\n}\n\n\n// union (a | b)\nexport function oneOf(...types: Array<PrimitiveValueTypes | TypeAssertion>): TypeAssertion {\n    if (types.length === 0) {\n        throw new Error(`Empty union type is not allowed.`);\n    }\n    if (types.length === 1) {\n        const ty = types[0];\n        if (ty && typeof ty === 'object') {\n            return ty;\n        } else {\n            return primitiveValue(ty);\n        }\n    }\n    const ret: OneOfAssertion = {\n        kind: 'one-of',\n        oneOf: [],\n    };\n    for (const ty of types) {\n        // TODO: remove same type\n        if (ty && typeof ty === 'object') {\n            if (ty.kind === 'one-of') {\n                ret.oneOf = ret.oneOf.concat(ty.oneOf);\n            } else {\n                ret.oneOf.push(ty);\n            }\n        } else {\n            ret.oneOf.push(primitiveValue(ty));\n        }\n    }\n    return ret;\n}\n\n\n// subtraction (a - b)\nexport function subtract(...types: TypeAssertion[]): ObjectAssertion | AssertionOperator {\n    if (types.length === 0) {\n        throw new Error(`Empty subtraction type is not allowed.`);\n    }\n    if (0 < types.filter(x => x && typeof x === 'object' &&\n            (x.kind === 'symlink' || x.kind === 'operator')).length) {\n        return ({\n            kind: 'operator',\n            operator: 'subtract',\n            operands: types.slice(),\n        });\n    }\n    let ret = types[0];\n    if (!ret || typeof ret !== 'object' || ret.kind !== 'object') {\n        throw new Error(`First parameter of subtraction type should be 'object'.`);\n    }\n    for (const ty of types.slice(1)) {\n        if (ty && typeof ty === 'object' && ty.kind === 'object') {\n            ret = omit(ret, ...ty.members.map(m => m[0]));\n        }\n    }\n    return ret;\n}\n\n\nexport function primitive(typeName: PrimitiveValueTypeNames |\n                                    OptionalPrimitiveValueTypeNames |\n                                    PlaceholderTypeNames |\n                                    OptionalPlaceholderTypeNames):\n        PrimitiveTypeAssertion | OptionalAssertion | NeverTypeAssertion | AnyTypeAssertion | UnknownTypeAssertion {\n    switch (typeName) {\n    case 'never':\n        return ({\n            kind: 'never',\n        });\n    case 'any':\n        return ({\n            kind: 'any',\n        });\n    case 'unknown':\n        return ({\n            kind: 'unknown',\n        });\n    case 'number':\n        // FALL_THRU\n    case 'integer':\n        // FALL_THRU\n    case 'bigint':\n        // FALL_THRU\n    case 'string':\n        // FALL_THRU\n    case 'boolean':\n        // FALL_THRU\n    case 'null':\n        // FALL_THRU\n    case 'undefined':\n        return ({\n            kind: 'primitive',\n            primitiveName: typeName,\n        });\n    case 'never?':\n        return (optional({\n            kind: 'never',\n        }));\n    case 'any?':\n        return (optional({\n            kind: 'any',\n        }));\n    case 'unknown?':\n        return (optional({\n            kind: 'unknown',\n        }));\n    case 'number?':\n        // FALL_THRU\n    case 'integer?':\n        // FALL_THRU\n    case 'bigint?':\n        // FALL_THRU\n    case 'string?':\n        // FALL_THRU\n    case 'boolean?':\n        // FALL_THRU\n    case 'null?':\n        // FALL_THRU\n    case 'undefined?':\n        return (optional({\n            kind: 'primitive',\n            primitiveName: typeName.substring(0, typeName.length - 1) as any,\n        }));\n    default:\n        throw new Error(`Unknown primitive type assertion: ${typeName}`);\n    }\n    // TODO: Function, DateStr, DateTimeStr, Funtion?, DateStr?, DateTimeStr?\n}\n\n\nexport function regexpPatternStringType(pattern: RegExp): PrimitiveTypeAssertion {\n    return ({\n        kind: 'primitive',\n        primitiveName: 'string',\n        pattern,\n    });\n}\n\n\nexport function primitiveValue(value: PrimitiveValueTypes): PrimitiveValueTypeAssertion {\n    if (value === null || value === void 0) {\n        return ({\n            kind: 'primitive-value',\n            value,\n        });\n    } else switch (typeof value) {\n    case 'number':\n        // FALL_THRU\n    case 'bigint':\n        // FALL_THRU\n    case 'string':\n        // FALL_THRU\n    case 'boolean':\n        return ({\n            kind: 'primitive-value',\n            value,\n        });\n    default:\n        throw new Error(`Unknown primitive value assertion: ${value}`);\n    }\n}\n\n\nexport function optional(ty: PrimitiveValueTypes | TypeAssertion): OptionalAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        if (ty.kind === 'optional') {\n            return ty;\n        } else {\n            return ({\n                kind: 'optional',\n                optional: ty,\n                ...(ty.typeName ? {typeName: ty.typeName} : {}),\n            });\n        }\n    } else {\n        return ({\n            kind: 'optional',\n            optional: primitiveValue(ty),\n        });\n    }\n}\n\n\nexport function repeated(\n        ty: PrimitiveValueTypeNames | TypeAssertion, option?:\n        Partial<Pick<RepeatedAssertion, 'max'> & Pick<RepeatedAssertion, 'min'>>): RepeatedAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        return ({\n            kind: 'repeated',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            repeated: ty,\n        });\n    } else {\n        return ({\n            kind: 'repeated',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            repeated: primitive(ty),\n        });\n    }\n}\n\n\nexport function sequenceOf(...seq: Array<PrimitiveValueTypes | TypeAssertion>): SequenceAssertion {\n    return ({\n        kind: 'sequence',\n        sequence: seq.map(ty => ty && typeof ty === 'object' && ty.kind ? ty : primitiveValue(ty)),\n    });\n}\n\n\nexport function spread(\n        ty: PrimitiveValueTypes | TypeAssertion,\n        option?: Partial<Pick<SpreadAssertion, 'max'> & Pick<SpreadAssertion, 'min'>>): SpreadAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        return ({\n            kind: 'spread',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            spread: ty,\n        });\n    } else {\n        return ({\n            kind: 'spread',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            spread: primitiveValue(ty),\n        });\n    }\n}\n\n\nexport function enumType(...values: Array<[string, number | string | null, string?]>): EnumAssertion {\n    const ar = values.slice();\n    let value = 0;\n    for (let i = 0; i < ar.length; i++) {\n        if (isUnsafeVarNames(dummyTargetObject, ar[i][0])) {\n            throw new Error(`Unsafe symbol name is appeared in enum assertion: ${ar[i][0]}`);\n        }\n\n        if (ar[i][1] === null || ar[i][1] === void 0) {\n            ar[i][1] = value++;\n        } else if (typeof ar[i][1] === 'number') {\n            value = (ar[i][1] as number) + 1;\n        }\n        if (! ar[i][2]) {\n            ar[i].length = 2;\n        }\n    }\n    return ({\n        kind: 'enum',\n        values: ar as Array<[string, number | string, string?]>,\n    });\n}\n\n\nexport function objectType(\n        ...members: Array<[\n            string | AdditionalPropsKey,\n            PrimitiveValueTypes | TypeAssertion,\n            string?\n        ]>): ObjectAssertion {\n    const revMembers = members.slice().reverse();\n    for (const x of members) {\n        if (typeof x[0] === 'string') {\n            if (isUnsafeVarNames(dummyTargetObject, x[0])) {\n                throw new Error(`Unsafe symbol name is appeared in object assertion: ${x[0]}`);\n            }\n            if (members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n                throw new Error(`Duplicated member is found: ${x[0]}`);\n            }\n        }\n    }\n\n    const membersProps: ObjectAssertionMember[] = (members\n        .filter(\n            x => typeof x[0] === 'string') as\n                Array<[string, PrimitiveValueTypes | TypeAssertion, string?]>)\n        .map(\n            x => x[1] && typeof x[1] === 'object' && x[1].kind ?\n                [x[0], withName(x[1], x[0]), x[2]] :\n                [x[0], withName(primitiveValue(x[1]), x[0]), x[2]])\n        .map(\n            x => (x[2] ?\n                [x[0], x[1], false, ...x.slice(2)] :\n                [x[0], x[1]]) as ObjectAssertionMember);\n\n    const additionalProps: AdditionalPropsMember[] = (members\n        .filter(x => typeof x[0] !== 'string') as Array<[\n            AdditionalPropsKey,\n            PrimitiveValueTypes | TypeAssertion,\n            string?\n        ]>)\n        .map(x => x[1] && typeof x[1] === 'object' && x[1].kind ?\n            x :\n            [x[0], primitiveValue(x[1]), x[2]])\n        .map(\n            x => (x[2] ?\n                [x[0], x[1], false, ...x.slice(2)] :\n                [x[0], x[1]]) as AdditionalPropsMember);\n\n    return ({\n        ...{\n            kind: 'object',\n            members: membersProps,\n        },\n        ...(0 < additionalProps.length ? {\n            additionalProps,\n        } : {}),\n    });\n}\n\n\nfunction checkRecursiveExtends(ty: ObjectAssertion, base: ObjectAssertion | AssertionSymlink): boolean {\n    if (ty === base) {\n        return false;\n    }\n    if (ty.typeName &&\n        (ty.typeName === base.typeName ||\n         (base.kind === 'symlink' && ty.typeName === base.symlinkTargetName))) {\n        return false;\n    }\n    if (base.kind === 'object' && base.baseTypes) {\n        for (const z of base.baseTypes) {\n            if (! checkRecursiveExtends(ty, z)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\nexport function derived(ty: ObjectAssertion, ...exts: TypeAssertion[]): ObjectAssertion {\n    const ret: ObjectAssertion = {\n        kind: 'object',\n        members: [],\n        baseTypes: [],\n    };\n\n    for (const ext of exts) {\n        switch (ext.kind) {\n        case 'object':\n            if (! checkRecursiveExtends(ty, ext)) {\n                throw new Error(`Recursive extend is found: ${ty.name || '(unnamed)'}`);\n            }\n            for (const m of ext.members) {\n                if (! ret.members.find(x => x[0] === m[0])) {\n                    ret.members.push([m[0], m[1], true, ...m.slice(3)] as ObjectAssertionMember);\n                }\n                // TODO: Check for different types with the same name.\n            }\n        // FALL_THRU\n        case 'symlink':\n            (ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>).push(ext);\n            break;\n        case 'operator':\n            {\n                throw new Error(`Unresolved type operator is found: ${ext.operator}`);\n            }\n        }\n        // NOTE: 'symlink' base types will resolved by calling `resolveSymbols()`.\n        //       `resolveSymbols()` will call `derived()` after resolve symlink exts.\n    }\n    ret.members = ty.members.concat(ret.members);\n    if (ty.baseTypes) {\n        ret.baseTypes = ty.baseTypes\n            .filter(x => x.kind !== 'symlink')\n            .concat(ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>);\n    }\n    if ((ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>).length === 0) {\n        delete ret.baseTypes;\n    }\n\n    const revMembers = ret.members.slice().reverse();\n    for (const x of ret.members) {\n        if (ret.members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n            throw new Error(`Duplicated member is found: ${x[0]} in ${ty.name || '(unnamed)'}`);\n        }\n    }\n\n    let additionalProps: AdditionalPropsMember[] = [];\n    if (ret.baseTypes) {\n        for (const base of ret.baseTypes) {\n            if (base.kind === 'object') {\n                if (base.additionalProps && 0 < base.additionalProps.length) {\n                    additionalProps = additionalProps.concat(\n                        base.additionalProps.map(x =>\n                            [x[0], x[1], true, ...x.slice(3)] as AdditionalPropsMember));\n                }\n            }\n            // NOTE: 'symlink' base types will resolved by calling `resolveSymbols()`.\n            //       `resolveSymbols()` will call `derived()` after resolve symlink exts.\n        }\n    }\n    if (ty.additionalProps && 0 < ty.additionalProps.length) {\n        additionalProps = additionalProps.concat(ty.additionalProps); // TODO: concat order\n    }\n    if (0 < additionalProps.length) {\n        ret.additionalProps = additionalProps;\n    }\n\n    return ret;\n}\n\n\nexport function symlinkType(name: string): AssertionSymlink {\n    return ({\n        kind: 'symlink',\n        symlinkTargetName: name,\n    });\n}\n\n\nexport function withName(ty: TypeAssertion, name: string) {\n    if (! name) {\n        return ty;\n    }\n    return ({...ty, name});\n}\n\n\nexport function withTypeName(ty: TypeAssertion, typeName: string) {\n    if (! typeName) {\n        return ty;\n    }\n    return ({...ty, typeName});\n}\n\n\nexport function withOriginalTypeName(ty: TypeAssertion, originalTypeName: string) {\n    if (! originalTypeName) {\n        return ty;\n    }\n    return ({...ty, originalTypeName});\n}\n\n\nexport function withDocComment(ty: TypeAssertion, docComment: string) {\n    if (! docComment) {\n        return ty;\n    }\n    return ({...ty, docComment});\n}\n\n\nexport function withRange(minValue: number | string, maxValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minValue !== 'number' && typeof minValue !== 'string') {\n            throw new Error(`Decorator '@range' parameter 'minValue' should be number or string.`);\n        }\n        if (typeof maxValue !== 'number' && typeof maxValue !== 'string') {\n            throw new Error(`Decorator '@range' parameter 'maxValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@range' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minValue, maxValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@range' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minValue, maxValue});\n        }\n    };\n}\n\n\nexport function withMinValue(minValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minValue !== 'number' && typeof minValue !== 'string') {\n            throw new Error(`Decorator '@minValue' parameter 'minValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@minValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@minValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minValue});\n        }\n    };\n}\n\n\nexport function withMaxValue(maxValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof maxValue !== 'number' && typeof maxValue !== 'string') {\n            throw new Error(`Decorator '@maxValue' parameter 'maxValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, maxValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, maxValue});\n        }\n    };\n}\n\n\nexport function withGreaterThan(greaterThanValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof greaterThanValue !== 'number' && typeof greaterThanValue !== 'string') {\n            throw new Error(`Decorator '@greaterThan' parameter 'greaterThan' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@greaterThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, greaterThanValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@greaterThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, greaterThanValue});\n        }\n    };\n}\n\n\nexport function withLessThan(lessThanValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof lessThanValue !== 'number' && typeof lessThanValue !== 'string') {\n            throw new Error(`Decorator '@lessThan' parameter 'lessThan' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@lessThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, lessThanValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@lessThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, lessThanValue});\n        }\n    };\n}\n\n\nexport function withMinLength(minLength: number) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minLength !== 'number') {\n            throw new Error(`Decorator '@minLength' parameter 'minLength' should be number.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@minLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minLength}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@minLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minLength});\n        }\n    };\n}\n\n\nexport function withMaxLength(maxLength: number) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof maxLength !== 'number') {\n            throw new Error(`Decorator '@maxLength' parameter 'maxLength' should be number.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, maxLength}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, maxLength});\n        }\n    };\n}\n\n\nexport function withMatch(pattern: RegExp) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof pattern !== 'object') {\n            throw new Error(`Decorator '@match' parameter 'pattern' should be RegExp.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@match' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, pattern}});\n        } else {\n            if (!ty || ty.kind !== 'primitive' || ty.primitiveName !== 'string') {\n                throw new Error(`Decorator '@match' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, pattern});\n        }\n    };\n}\n\n\nexport function withStereotype<T extends TypeAssertion>(stereotype: string): (ty: T) => T {\n    if (typeof stereotype !== 'string') {\n        throw new Error(`Decorator '@stereotype' parameter 'stereotype' should be string.`);\n    }\n    if (isUnsafeVarNames(dummyTargetObject, stereotype)) {\n        throw new Error(`Unsafe symbol name is appeared in stereotype assertion: ${stereotype}`);\n    }\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...(ty as OptionalAssertion).optional,\n                    stereotype,\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                stereotype,\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withConstraint<T extends TypeAssertion>(name: string, args?: any): (ty: T) => T {\n    if (typeof name !== 'string') {\n        throw new Error(`Decorator '@constraint' parameter 'name' should be string.`);\n    }\n    if (isUnsafeVarNames(dummyTargetObject, name)) {\n        throw new Error(`Unsafe symbol name is appeared in constraint assertion: ${name}`);\n    }\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const opt = (ty as OptionalAssertion).optional;\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...opt,\n                    customConstraints: opt.customConstraints\n                        ? opt.customConstraints.slice().push(name)\n                        : [name],\n                    customConstraintsArgs: opt.customConstraintsArgs\n                        ? {...opt.customConstraintsArgs, [name]: args}\n                        : {[name]: args},\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                customConstraints: ty.customConstraints\n                    ? ty.customConstraints.slice().push(name)\n                    : [name],\n                customConstraintsArgs: ty.customConstraintsArgs\n                    ? {...ty.customConstraintsArgs, [name]: args}\n                    : {[name]: args},\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withForceCast<T extends TypeAssertion>(): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...(ty as OptionalAssertion).optional,\n                    forceCast: true,\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                forceCast: true,\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withRecordType<T extends TypeAssertion>(): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...(ty as OptionalAssertion).optional,\n                    isRecordTypeField: true,\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                isRecordTypeField: true,\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withMeta<T extends TypeAssertion>(meta: any): (ty: T) => T {\n    return (ty: T) => {\n        const ret: T = ({\n            ...ty,\n            meta,\n        });\n        return ret;\n    };\n}\n\n\nexport function withMsg<T extends TypeAssertion>(messages: string | ErrorMessages): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            if (typeof messages === 'string') {\n                const ret = ({\n                    ...ty,\n                    message: messages,\n                    optional: {...(ty as OptionalAssertion).optional, message: messages},\n                });\n                delete ret.messages;\n                delete ret.optional.messages;\n                return ret;\n            } else {\n                const ret = ({\n                    ...ty,\n                    messages,\n                    optional: {...(ty as OptionalAssertion).optional, messages},\n                });\n                delete ret.message;\n                delete ret.optional.message;\n                return ret;\n            }\n        } else {\n            if (typeof messages === 'string') {\n                const ret = ({...ty, message: messages});\n                delete ret.messages;\n                return ret;\n            } else {\n                const ret = ({...ty, messages});\n                delete ret.message;\n                return ret;\n            }\n        }\n    };\n}\n\n\nexport function withMsgId<T extends TypeAssertion>(messageId: string): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            return ({\n                ...ty,\n                messageId,\n                optional: {...(ty as OptionalAssertion).optional, messageId},\n            });\n        } else {\n            return ({...ty, messageId});\n        }\n    };\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\n// tslint:disable: no-shadowed-variable\n// tslint:disable: function-constructor\n\n\nexport const dummyTargetObject = {};\n\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nexport const { g: globalObj, o: objConstructor, f: funConstructor } = (() => {\n    let globalObj = null;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-implied-eval\n        globalObj = Function('return this')();\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! globalObj) {\n        // Fall back (for CSP, etc...)\n        if (typeof window === 'object' && window) {\n            globalObj = window;\n        } else if (typeof global === 'object' && global) {\n            globalObj = global;\n        } else if (typeof globalThis === 'object' && globalThis) {\n            globalObj = globalThis;\n        } else {\n            globalObj = dummyTargetObject;\n        }\n    }\n\n    // NOTE: ({}).constructor === Object\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let objConstructor: ObjectConstructor = null as any;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        objConstructor = (({}).constructor ?? Object) as any;\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! objConstructor) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        objConstructor = dummyTargetObject as any;\n    }\n\n    // NOTE: ({}).toString.constructor === Function\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let funConstructor: FunctionConstructor = null as any;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        funConstructor = (({}).toString.constructor ?? Function) as any;\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! funConstructor) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        funConstructor = dummyTargetObject as any;\n    }\n\n    return ({\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        g: globalObj, o: objConstructor, f: funConstructor\n    });\n})();\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function isUnsafeVarNames(target: any, varName: string) {\n    if (target === globalObj ||\n        varName === '__proto__' ||\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\n        return true;\n    }\n    if (varName === 'prototype' || varName === 'constructor') {\n        if (target === null || target === void 0 || typeof target === 'function') {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === objConstructor) {\n        if (Object.prototype.hasOwnProperty.call(objConstructor, varName)) {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === funConstructor) {\n        // checking 'call', 'arguments', 'caller', ...\n        let con: any = funConstructor;\n        while (con) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            if (Object.prototype.hasOwnProperty.call(con, varName)) {\n                return true;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n            con = con.__proto__;\n        }\n    }\n    if (typeof target === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        if (! Object.prototype.hasOwnProperty.call(target, varName)) {\n            // function's prototypes' members\n            return true;\n        }\n    }\n    return false;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken }             from '../types';\r\nimport { isSymbol }            from '../ast';\r\nimport { resolveSplice,\r\n         resolveMacro,\r\n         resolveValueSymbol,\r\n         getScope }            from '../evaluate';\r\nimport { setEvaluationCount,\r\n         checkUnsafeVarNamesEx,\r\n         checkUnsafeVarNames } from '../errors';\r\n\r\n\r\n\r\nexport function applyMacros(state: SxParserState, tok: SxToken) {\r\n    let r: SxToken = tok;\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                break;\r\n            }\r\n            r = resolveSplice(state, r);\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym, r);\r\n                if (m) {\r\n                    r = m.fn(m.actualArgs as SxToken[]);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n        setEvaluationCount(state);\r\n    }\r\n    return r;\r\n}\r\n\r\n\r\nexport function stripQuote(state: SxParserState, tok: SxToken) {\r\n    if (! (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote))) {\r\n        throw new Error(`[SX] stripQuote: token is not quoted.`);\r\n    }\r\n    return (tok as any)[1];\r\n}\r\n\r\n\r\nexport function stripQuoteOrPass(state: SxParserState, tok: SxToken) {\r\n    if (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote)) {\r\n        return (tok as any)[1];\r\n    } else {\r\n        return tok;\r\n    }\r\n}\r\n\r\n\r\nexport function getScope_stateApplied(state: SxParserState) {\r\n    return (function() { return getScope(state); });\r\n}\r\n\r\n\r\nexport function resolveValueSymbol_dynamic(state: SxParserState, varName: string) {\r\n    checkUnsafeVarNames('(compiler)resolveValueSymbol_dynamic', varName);\r\n    return (function(){ return resolveValueSymbol(state, {symbol: varName}); });\r\n}\r\n\r\nexport function checkUnsafeVarNames_dynamic(name: string) {\r\n    return (function(varName: string){ return checkUnsafeVarNames(name, varName); });\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport function escapeString(s: string) {\n    return (s\n        .replace(/\\x08/g, '\\\\b')\n        .replace(/\\f/g, '\\\\f')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\v/g, '\\\\v')\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\'/g, '\\\\\\'')\n        .replace(/\\\"/g, '\\\\\\\"')\n        .replace(/\\`/g, '\\\\\\`')\n    );\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         ValidationContext } from '../types';\n\n\n\nexport class ValidationError extends Error {\n    public ty?: TypeAssertion;\n    public ctx?: Partial<ValidationContext>;\n    public constructor(message: string, ty?: TypeAssertion, ctx?: Partial<ValidationContext>) {\n        super(message);\n        this.ty = ty;\n        this.ctx = ctx;\n    }\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         TypeAssertionMap,\n         TypeAssertionSetValue,\n         ObjectAssertion,\n         AssertionSymlink,\n         SymbolResolverOperators,\n         ResolveSymbolOptions,\n         SymbolResolverContext } from '../types';\nimport * as operators            from '../operators';\nimport { NumberPattern }         from '../lib/util';\n\n\n\nfunction mergeTypeAndSymlink(ty: TypeAssertion, link: AssertionSymlink): TypeAssertion {\n    const link2 = {...link};\n    delete (link2 as any).kind;              // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n    delete (link2 as any).symlinkTargetName; // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n    delete (link2 as any).memberTree;        // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n    return ({...ty, ...link2} as any as TypeAssertion);\n}\n\n\nfunction updateSchema(original: TypeAssertion, schema: TypeAssertionMap, ty: TypeAssertion, typeName: string | undefined) {\n    if (typeName && schema.has(typeName)) {\n        const z: TypeAssertionSetValue = schema.get(typeName) as TypeAssertionSetValue;\n        if (z.ty === original) {\n            schema.set(typeName, {...z, ty, resolved: true});\n        }\n    }\n    return ty;\n}\n\n\nexport function resolveMemberNames(\n        ty: TypeAssertion, rootSym: string, memberTreeSymbols: string[], memberPos: number): TypeAssertion {\n\n    const addTypeName = (mt: TypeAssertion, typeName: string | undefined, memberSym: string) => {\n        if (typeName) {\n            return ({\n                ...mt,\n                typeName: memberPos === 0 ?\n                    `${rootSym}.${memberTreeSymbols.join('.')}` :\n                    `${typeName}.${memberSym}`,\n            });\n        } else {\n            return mt;\n        }\n    };\n\n    for (let i = memberPos; i < memberTreeSymbols.length; i++) {\n        const memberSym = memberTreeSymbols[i];\n\n        switch (ty.kind) {\n        case 'optional':\n            return resolveMemberNames(ty.optional, rootSym, memberTreeSymbols, i + 1);\n        case 'object':\n            for (const m of ty.members) {\n                if (memberSym === m[0]) {\n                    return addTypeName(\n                        resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1),\n                        ty.typeName,\n                        memberSym,\n                    );\n                }\n            }\n            if (ty.additionalProps) {\n                for (const m of ty.additionalProps) {\n                    for (const k of m[0]) {\n                        switch (k) {\n                        case 'number':\n                            if (NumberPattern.test(memberSym)) {\n                                return resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1);\n                            }\n                            break;\n                        case 'string':\n                            return resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1);\n                        default:\n                            if (k.test(memberSym)) {\n                                return resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            throw new Error(`Undefined member name is appeared: ${memberSym}`);\n        case 'symlink':\n            if (! ty.typeName) {\n                throw new Error(`Reference of anonymous type is appeared: ${memberSym}`);\n            }\n            return ({\n                ...{\n                    kind: 'symlink',\n                    symlinkTargetName: rootSym,\n                    name: memberSym,\n                    typeName: rootSym,\n                },\n                ...(0 < memberTreeSymbols.length ? {\n                    memberTree: memberTreeSymbols,\n                } : {}),\n            });\n        default:\n            // TODO: kind === 'operator'\n            throw new Error(`Unsupported type kind is appeared: (kind:${ty.kind}).${memberSym}`);\n        }\n    }\n    return ty;\n}\n\n\nexport function resolveSymbols(schema: TypeAssertionMap, ty: TypeAssertion, ctx: SymbolResolverContext): TypeAssertion {\n    const ctx2 = {...ctx, nestLevel: ctx.nestLevel + 1};\n    switch (ty.kind) {\n    case 'symlink':\n        {\n            const x = schema.get(ty.symlinkTargetName);\n            if (! x) {\n                throw new Error(`Undefined symbol '${ty.symlinkTargetName}' is referred.`);\n            }\n            if (0 <= ctx.symlinkStack.findIndex(s => s === ty.symlinkTargetName)) {\n                return ty;\n            }\n\n            const ty2 = {...ty};\n            let xTy = x.ty;\n            if (ty.memberTree && 0 < ty.memberTree.length) {\n                xTy = {\n                    ...resolveMemberNames(xTy, ty.symlinkTargetName, ty.memberTree, 0),\n                };\n                ty2.typeName = xTy.typeName;\n            }\n\n            return (\n                resolveSymbols(\n                    schema,\n                    mergeTypeAndSymlink(xTy, ty2),\n                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty2.symlinkTargetName]},\n                )\n            );\n        }\n    case 'repeated':\n        return updateSchema(ty, schema, {\n            ...ty,\n            repeated: resolveSymbols(schema, ty.repeated, ctx2),\n        }, ty.typeName);\n    case 'spread':\n        return updateSchema(ty, schema, {\n            ...ty,\n            spread: resolveSymbols(schema, ty.spread, ctx2),\n        }, ty.typeName);\n    case 'sequence':\n        return updateSchema(ty, schema, {\n            ...ty,\n            sequence: ty.sequence.map(x => resolveSymbols(schema, x, ctx2)),\n        }, ty.typeName);\n    case 'one-of':\n        return updateSchema(ty, schema, {\n            ...ty,\n            oneOf: ty.oneOf.map(x => resolveSymbols(schema, x, ctx2)),\n        }, ty.typeName);\n    case 'optional':\n        return updateSchema(ty, schema, {\n            ...ty,\n            optional: resolveSymbols(schema, ty.optional, ctx2),\n        }, ty.typeName);\n    case 'object':\n        {\n            if (0 < ctx.nestLevel && ty.typeName && 0 <= ctx.symlinkStack.findIndex(s => s === ty.typeName)) {\n                if (schema.has(ty.typeName)) {\n                    const z = schema.get(ty.typeName) as TypeAssertionSetValue;\n                    if (z.resolved) {\n                        return z.ty;\n                    }\n                }\n            }\n\n            const baseSymlinks = ty.baseTypes?.filter(x => x.kind === 'symlink') as AssertionSymlink[];\n            if (baseSymlinks && baseSymlinks.length > 0 && !ctx.isDeserialization) {\n                const exts = baseSymlinks\n                    .map(x => resolveSymbols(schema, x, ctx2))\n                    .filter(x => x.kind === 'object');\n                // TODO: if x.kind !== 'object' items exist -> error?\n                const d2 = resolveSymbols(\n                    schema,\n                    operators.derived({\n                        ...ty,\n                        ...(ty.baseTypes ? {\n                            baseTypes: ty.baseTypes.filter(x => x.kind !== 'symlink'),\n                        } : {}),\n                    }, ...exts),\n                    ty.typeName ?\n                        {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2,\n                );\n                return updateSchema(ty, schema, {\n                    ...ty,\n                    ...d2,\n                }, ty.typeName);\n            } else {\n                return updateSchema(ty, schema, {\n                    ...{\n                        ...ty,\n                        members: ty.members\n                            .map(x => [\n                                x[0],\n                                resolveSymbols(schema, x[1], ty.typeName ?\n                                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2),\n                                ...x.slice(2),\n                            ] as any),\n                    },\n                    ...(ty.additionalProps && 0 < ty.additionalProps.length ? {\n                        additionalProps: ty.additionalProps\n                            .map(x => [\n                                x[0],\n                                resolveSymbols(schema, x[1], ty.typeName ?\n                                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2),\n                                ...x.slice(2),\n                            ] as any),\n                    } : {}),\n                    ...(ty.baseTypes && 0 < ty.baseTypes.length ? {\n                        baseTypes: ctx.isDeserialization ?\n                            ty.baseTypes\n                                .map(x => x.kind === 'symlink' ? resolveSymbols(schema, x, ctx2) : x)\n                                .filter(x => x.kind === 'object') as ObjectAssertion[] :\n                            ty.baseTypes,\n                    } : {}),\n                }, ty.typeName);\n            }\n        }\n    case 'operator':\n        if (ctx2.operators) {\n            const ctx3 = ty.typeName ?\n                {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2;\n            const operands = ty.operands.map(x => {\n                if (typeof x === 'object' && x.kind) {\n                    return resolveSymbols(schema, x, ctx3);\n                }\n                return x;\n            });\n            if (0 < operands.filter(x => x && typeof x === 'object' &&\n                    (x.kind === 'symlink' || x.kind === 'operator')).length) {\n                throw new Error(`Unresolved type operator is found: ${ty.operator}`);\n            }\n            if (! ctx2.operators[ty.operator]) {\n                throw new Error(`Undefined type operator is found: ${ty.operator}`);\n            }\n            const ty2 = {...ty};\n            delete (ty2 as any).operator; // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n            delete (ty2 as any).operands; // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n            return updateSchema(\n                ty, schema,\n                {\n                    ...ty2,\n                    ...resolveSymbols(schema, ctx2.operators[ty.operator](...operands), ctx3),\n                },\n                ty.typeName,\n            );\n        } else {\n            return ty;\n        }\n    default:\n        return ty;\n    }\n}\n\n\nconst resolverOps: SymbolResolverOperators = {\n    picked: operators.picked,\n    omit: operators.omit,\n    partial: operators.partial,\n    intersect: operators.intersect,\n    subtract: operators.subtract,\n};\n\n\nexport function resolveSchema(schema: TypeAssertionMap, opts?: ResolveSymbolOptions): TypeAssertionMap {\n    for (const ent of schema.entries()) {\n        const ty = resolveSymbols(schema, ent[1].ty, {...opts, nestLevel: 0, symlinkStack: [ent[0]], operators: resolverOps});\n        ent[1].ty = ty;\n    }\n\n    return schema;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\n\r\n// tslint:disable: no-shadowed-variable\r\n// tslint:disable: function-constructor\r\n\r\n\r\nexport const dummyTargetObject = {};\r\n\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\nexport const { g: globalObj, o: objConstructor, f: funConstructor } = (() => {\r\n    let globalObj = null;\r\n    try {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-implied-eval\r\n        globalObj = Function('return this')();\r\n    } catch (e) {\r\n        // Nothing to do.\r\n    }\r\n    if (! globalObj) {\r\n        // Fall back (for CSP, etc...)\r\n        if (typeof window === 'object' && window) {\r\n            globalObj = window;\r\n        } else if (typeof global === 'object' && global) {\r\n            globalObj = global;\r\n        } else if (typeof globalThis === 'object' && globalThis) {\r\n            globalObj = globalThis;\r\n        } else {\r\n            globalObj = dummyTargetObject;\r\n        }\r\n    }\r\n\r\n    // NOTE: ({}).constructor === Object\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n    let objConstructor: ObjectConstructor = null as any;\r\n    try {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        objConstructor = (({}).constructor ?? Object) as any;\r\n    } catch (e) {\r\n        // Nothing to do.\r\n    }\r\n    if (! objConstructor) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        objConstructor = dummyTargetObject as any;\r\n    }\r\n\r\n    // NOTE: ({}).toString.constructor === Function\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n    let funConstructor: FunctionConstructor = null as any;\r\n    try {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        funConstructor = (({}).toString.constructor ?? Function) as any;\r\n    } catch (e) {\r\n        // Nothing to do.\r\n    }\r\n    if (! funConstructor) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        funConstructor = dummyTargetObject as any;\r\n    }\r\n\r\n    return ({\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        g: globalObj, o: objConstructor, f: funConstructor\r\n    });\r\n})();\r\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ErrorTypes,\n         ErrorMessages,\n         TypeAssertionErrorMessageConstraints,\n         TypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         OptionalAssertion,\n         ValidationContext } from '../types';\nimport { escapeString }      from './escape';\nimport { nvl }               from './util';\n\n\nexport const errorTypeNames = [\n    '',\n    'InvalidDefinition',\n    'Required',\n    'TypeUnmatched',\n    'AdditionalPropUnmatched',\n    'RepeatQtyUnmatched',\n    'SequenceUnmatched',\n    'ValueRangeUnmatched',\n    'ValuePatternUnmatched',\n    'ValueLengthUnmatched',\n    'ValueUnmatched',\n];\n\n\nexport const defaultMessages: ErrorMessages = {\n    invalidDefinition:       '\"%{name}\" of \"%{parentType}\" type definition is invalid.',\n    required:                '\"%{name}\" of \"%{parentType}\" is required.',\n    typeUnmatched:           '\"%{name}\" of \"%{parentType}\" should be type \"%{expectedType}\".',\n    additionalPropUnmatched: '\"%{addtionalProps}\" of \"%{parentType}\" are not matched to additional property patterns.',\n    repeatQtyUnmatched:      '\"%{name}\" of \"%{parentType}\" should repeat %{repeatQty} times.',\n    sequenceUnmatched:       '\"%{name}\" of \"%{parentType}\" sequence is not matched',\n    valueRangeUnmatched:     '\"%{name}\" of \"%{parentType}\" value should be in the range %{minValue} to %{maxValue}.',\n    valuePatternUnmatched:   '\"%{name}\" of \"%{parentType}\" value should be matched to pattern \"%{pattern}\"',\n    valueLengthUnmatched:    '\"%{name}\" of \"%{parentType}\" length should be in the range %{minLength} to %{maxLength}.',\n    valueUnmatched:          '\"%{name}\" of \"%{parentType}\" value should be \"%{expectedValue}\".',\n};\n\n\ntype TopRepeatable = RepeatedAssertion | SpreadAssertion | OptionalAssertion | null;\n\n\ninterface ReportErrorArguments {\n    ctx: ValidationContext;\n    substitutions?: [[string, string]]; // addtional or overwritten substitution values\n}\n\n\nfunction getErrorMessage(errType: ErrorTypes, ...messages: ErrorMessages[]) {\n    for (const m of messages) {\n        switch (errType) {\n        case ErrorTypes.InvalidDefinition:\n            if (m.invalidDefinition) {\n                return m.invalidDefinition;\n            }\n            break;\n        case ErrorTypes.Required:\n            if (m.required) {\n                return m.required;\n            }\n            break;\n        case ErrorTypes.TypeUnmatched:\n            if (m.typeUnmatched) {\n                return m.typeUnmatched;\n            }\n            break;\n        case ErrorTypes.AdditionalPropUnmatched:\n            if (m.additionalPropUnmatched) {\n                return m.additionalPropUnmatched;\n            }\n            break;\n        case ErrorTypes.RepeatQtyUnmatched:\n            if (m.repeatQtyUnmatched) {\n                return m.repeatQtyUnmatched;\n            }\n            break;\n        case ErrorTypes.SequenceUnmatched:\n            if (m.sequenceUnmatched) {\n                return m.sequenceUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueRangeUnmatched:\n            if (m.valueRangeUnmatched) {\n                return m.valueRangeUnmatched;\n            }\n            break;\n        case ErrorTypes.ValuePatternUnmatched:\n            if (m.valuePatternUnmatched) {\n                return m.valuePatternUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueLengthUnmatched:\n            if (m.valueLengthUnmatched) {\n                return m.valueLengthUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueUnmatched:\n            if (m.valueUnmatched) {\n                return m.valueUnmatched;\n            }\n            break;\n        }\n    }\n    return '';\n}\n\n\nfunction findTopRepeatableAssertion(ctx: ValidationContext): TopRepeatable {\n    const ret = ctx.typeStack\n        .slice()\n        .reverse()\n        .map(x => Array.isArray(x) ? x[0] : x)\n        .find(x => x.kind === 'repeated' || x.kind === 'spread' || x.kind === 'optional'\n                ) as RepeatedAssertion | SpreadAssertion | OptionalAssertion || null;\n    return ret;\n}\n\n\nfunction getExpectedType(ty: TypeAssertion): string {\n    switch (ty.kind) {\n    case 'repeated':\n        return `(repeated ${getExpectedType(ty.repeated)})`;\n    case 'spread':\n        return getExpectedType(ty.spread);\n    case 'sequence':\n        return '(sequence)';\n    case 'primitive':\n        return ty.primitiveName;\n    case 'primitive-value':\n        return `(value ${\n            typeof ty.value === 'string' ?\n                `'${String(ty.value)}'` :\n                String(ty.value)})`;\n    case 'optional':\n        return getExpectedType(ty.optional);\n    case 'one-of':\n        return `(one of ${ty.oneOf.map(x => getExpectedType(x)).join(', ')})`;\n    case 'never': case 'any': case 'unknown':\n        return ty.kind;\n    case 'symlink':\n        return ty.symlinkTargetName;\n    default:\n        return ty.typeName ? ty.typeName : '?';\n    }\n}\n\n\nexport function formatErrorMessage(\n        msg: string, data: any, ty: TypeAssertion,\n        args: ReportErrorArguments,\n        values: {dataPath: string, topRepeatable: TopRepeatable, parentType: string, entryName: string}) {\n\n    let ret = msg;\n    // TODO: complex type object members' custom error messages are not displayed?\n    // TODO: escapeString() is needed?\n\n    const tr = values.topRepeatable;\n\n    const dict = new Map<string, string>([\n        ['expectedType',\n            ty.stereotype ?\n                ty.stereotype :\n            escapeString(getExpectedType(ty))],\n        ['type',\n            escapeString(typeof data)],\n        ['expectedValue',\n            escapeString(\n                ty.kind === 'primitive-value' ?\n                    String(ty.value) :\n                ty.kind === 'enum' ?\n                    ty.typeName ?\n                        `enum member of ${ty.typeName}` :\n                        '?' :\n                '?')],\n        ['value',\n            escapeString(String(data))],\n        ['repeatQty',\n            escapeString(\n                tr ?\n                    tr.kind !== 'optional' ? `${\n                        nvl(tr.min, '')}${\n                            (tr.min !== null && tr.min !== void 0) ||\n                            (tr.max !== null && tr.max !== void 0) ? '..' : ''}${\n                            nvl(tr.max, '')}` :\n                        '0..1' :\n                    '?')],\n        ['minValue',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.minValue, nvl(ty.greaterThanValue, '(smallest)'))}` : '?')],\n        ['maxValue',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.maxValue, nvl(ty.lessThanValue, '(biggest)'))}` : '?')],\n        ['pattern',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${ty.pattern ? `/${ty.pattern.source}/${ty.pattern.flags}` : '(pattern)'}` : '?')],\n        ['minLength',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.minLength, '0')}` : '?')],\n        ['maxLength',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.maxLength, '(biggest)')}` : '?')],\n        ['name',\n            escapeString(\n                `${ty.kind !== 'repeated' && values.dataPath.endsWith('repeated)') ?\n                    'repeated item of ' :\n                   ty.kind !== 'sequence' && values.dataPath.endsWith('sequence)') ?\n                    'sequence item of ' : ''}${\n                values.entryName || '?'}`)],\n        ['parentType',\n            escapeString(\n                values.parentType || '?')],\n        ['dataPath',\n            values.dataPath],\n\n        ...(args.substitutions || []),\n    ]);\n\n    for (const ent of dict.entries()) {\n        ret = ret.replace(new RegExp(`%{${ent[0]}}`), ent[1]);\n    }\n\n    return ret;\n}\n\n\ninterface DataPathEntry {\n    name: string;\n    kind: 'type' | 'key' | 'index';\n}\n\n\nexport function reportError(\n        errType: ErrorTypes, data: any, ty: TypeAssertion,\n        args: ReportErrorArguments) {\n\n    const messages: ErrorMessages[] = [];\n    if (ty.messages) {\n        messages.push(ty.messages);\n    }\n    if (args.ctx.errorMessages) {\n        messages.push(args.ctx.errorMessages);\n    }\n    messages.push(defaultMessages);\n\n    const dataPathEntryArray: DataPathEntry[] = [];\n\n    for (let i = 0; i < args.ctx.typeStack.length; i++) {\n        const p = args.ctx.typeStack[i];\n        const next = args.ctx.typeStack[i + 1];\n        const pt = Array.isArray(p) ? p[0] : p;\n        const pi = Array.isArray(next) ? next[1] : void 0;\n\n        let isSet = false;\n        if (pt.kind === 'repeated') {\n            if (i !== args.ctx.typeStack.length - 1) {\n                if (pt.name) {\n                    dataPathEntryArray.push({kind: 'key', name: pt.name});\n                }\n                dataPathEntryArray.push({kind: 'index', name: `(${pi !== void 0 ? `${pi}:` : ''}repeated)`});\n                isSet = true;\n            }\n        } else if (pt.kind === 'sequence') {\n            if (i !== args.ctx.typeStack.length - 1) {\n                if (pt.name) {\n                    dataPathEntryArray.push({kind: 'key', name: pt.name});\n                }\n                dataPathEntryArray.push({kind: 'index', name: `(${pi !== void 0 ? `${pi}:` : ''}sequence)`});\n                isSet = true;\n            }\n        }\n        if (! isSet) {\n            if (pt.name) {\n                if (i === 0) {\n                    if (pt.typeName) {\n                        dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n                    } else {\n                        dataPathEntryArray.push({kind: 'key', name: pt.name});\n                    }\n                } else {\n                    const len = dataPathEntryArray.length;\n                    if (len && dataPathEntryArray[len - 1].kind === 'type') {\n                        if (pt.kind === 'object' && next && pt.typeName) {\n                            dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n                        } else {\n                            dataPathEntryArray.push({kind: 'key', name: pt.name as string}); // NOTE: type inference failed\n                        }\n                    } else {\n                        if (pt.typeName) {\n                            dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n                        } else {\n                            dataPathEntryArray.push({kind: 'key', name: pt.name});\n                        }\n                    }\n                }\n            } else if (pt.typeName) {\n                dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n            }\n        }\n    }\n\n    let dataPath = '';\n    for (let i = 0; i < dataPathEntryArray.length; i++) {\n        const p = dataPathEntryArray[i];\n        dataPath += p.name;\n        if (i + 1 === dataPathEntryArray.length) {\n            break;\n        }\n        dataPath += p.kind === 'type' ? ':' : '.';\n    }\n\n    let parentType = '';\n    let entryName = '';\n    for (let i = dataPathEntryArray.length - 1; 0 <= i; i--) {\n        const p = dataPathEntryArray[i];\n        if (p.kind === 'type') {\n            if (i !== 0 && i === dataPathEntryArray.length - 1) {\n                const q = dataPathEntryArray[i - 1];\n                if (q.kind === 'index') {\n                    continue; // e.g.: \"File:acl.(0:repeated).ACL\"\n                }\n            }                 // else: \"File:acl.(0:repeated).ACL:target\"\n            parentType = p.name;\n            for (let j = i + 1; j < dataPathEntryArray.length; j++) {\n                const q = dataPathEntryArray[j];\n                if (q.kind === 'key') {\n                    entryName = q.name;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    if (! parentType) {\n        for (let i = args.ctx.typeStack.length - 1; 0 <= i; i--) {\n            const p = args.ctx.typeStack[i];\n            const pt = Array.isArray(p) ? p[0] : p;\n            if (pt.typeName) {\n                parentType = pt.typeName;\n            }\n        }\n    }\n\n    const topRepeatable: TopRepeatable = findTopRepeatableAssertion(args.ctx);\n    const values = {dataPath, topRepeatable, parentType, entryName};\n\n    const constraints: TypeAssertionErrorMessageConstraints = {};\n    const cSrces: TypeAssertionErrorMessageConstraints[] = [ty as any];\n\n    if (errType === ErrorTypes.RepeatQtyUnmatched && topRepeatable) {\n        cSrces.unshift(topRepeatable as any);\n    }\n\n    for (const cSrc of cSrces) {\n        if (nvl(cSrc.minValue, false)) {\n            constraints.minValue = cSrc.minValue;\n        }\n        if (nvl(cSrc.maxValue, false)) {\n            constraints.maxValue = cSrc.maxValue;\n        }\n        if (nvl(cSrc.greaterThanValue, false)) {\n            constraints.greaterThanValue = cSrc.greaterThanValue;\n        }\n        if (nvl(cSrc.lessThanValue, false)) {\n            constraints.lessThanValue = cSrc.lessThanValue;\n        }\n        if (nvl(cSrc.minLength, false)) {\n            constraints.minLength = cSrc.minLength;\n        }\n        if (nvl(cSrc.maxLength, false)) {\n            constraints.maxLength = cSrc.maxLength;\n        }\n        if (nvl(cSrc.pattern, false)) {\n            const pat = cSrc.pattern as any as RegExp;\n            constraints.pattern = `/${pat.source}/${pat.flags}`;\n        }\n        if (nvl(cSrc.min, false)) {\n            constraints.min = cSrc.min;\n        }\n        if (nvl(cSrc.max, false)) {\n            constraints.max = cSrc.max;\n        }\n    }\n\n    const val: {value?: any} = {};\n\n    switch (typeof data) {\n    case 'number': case 'bigint': case 'string': case 'boolean': case 'undefined':\n        val.value = data;\n        break;\n    case 'object':\n        if (data === null) {\n            val.value = data;\n        }\n    }\n\n    if (ty.messageId) {\n        args.ctx.errors.push({\n            code: `${ty.messageId}-${errorTypeNames[errType]}`,\n            message: formatErrorMessage(ty.message ?\n                ty.message :\n                getErrorMessage(errType, ...messages), data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    } else if (ty.message) {\n        args.ctx.errors.push({\n            code: `${errorTypeNames[errType]}`,\n            message: formatErrorMessage(ty.message, data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    } else {\n        args.ctx.errors.push({\n            code: `${errorTypeNames[errType]}`,\n            message: formatErrorMessage(getErrorMessage(errType, ...messages), data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    }\n}\n\n\nexport function reportErrorWithPush(\n        errType: ErrorTypes, data: any,\n        tyidx: [TypeAssertion, number | string | undefined],\n        args: ReportErrorArguments) {\n\n    try {\n        args.ctx.typeStack.push(tyidx);\n        reportError(errType, data, tyidx[0], args);\n    } finally {\n        args.ctx.typeStack.pop();\n    }\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { Stereotype } from '../types';\n\n\n\nexport const noopStereotype: Stereotype = {\n    tryParse: (value: any) => {\n        return ({ value });\n    },\n    evaluateFormula: (valueOrFormula: any) => {\n        return valueOrFormula;\n    },\n    compare: (a: any, b: any) => {\n        // NOTE: You should pass assertion value (schema value) into 'a'.\n        const tyA = typeof a;\n        const tyB = typeof b;\n        if (tyA !== tyB) {\n            return NaN;\n        }\n        switch (tyA) {\n        case 'number':\n            if (Number.isNaN(a) && Number.isNaN(b)) {\n                return 0;\n            } else {\n                return a - b;\n            }\n        default:\n            if (a === b) {\n                return 0;\n            } else if (a > b) {\n                return 1;\n            } else if (a < b) {\n                return -1;\n            } else {\n                return NaN;\n            }\n        }\n    },\n    doCast: false,\n};\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ErrorTypes,\n         NeverTypeAssertion,\n         AnyTypeAssertion,\n         UnknownTypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SequenceAssertion,\n         SpreadAssertion,\n         OptionalAssertion,\n         OneOfAssertion,\n         EnumAssertion,\n         ObjectAssertion,\n         TypeAssertion,\n         ValidationContext,\n         TypeAssertionMap,\n         Stereotype,\n         CustomConstraintInfo } from './types';\nimport { ValidationError }      from './lib/errors';\nimport { NumberPattern }        from './lib/util';\nimport { isUnsafeVarNames }     from './lib/protection';\nimport { reportError,\n         reportErrorWithPush }  from './lib/reporter';\nimport { resolveSymbols }       from './lib/resolver';\nimport { noopStereotype }       from './stereotypes/noop';\n\n\n\nfunction checkStereotypes(\n    data: any, ty: TypeAssertion, ctx: ValidationContext):\n        {value: any, stereotype: Stereotype} | null | false {\n\n    if (ty.stereotype && ctx.stereotypes) {\n        if (ctx.stereotypes.has(ty.stereotype)) {\n            const stereotype = ctx.stereotypes.get(ty.stereotype) as Stereotype;\n            const parsed = stereotype.tryParse(data);\n            if (parsed) {\n                return ({\n                    value: parsed.value,\n                    stereotype,\n                });\n            } else {\n                return null;\n            }\n        } else {\n            throw new Error(`Undefined stereotype is specified: ${ty.stereotype}`);\n        }\n    }\n    return false;\n}\n\n\nfunction forceCast(\n    targetType:\n        'number' | 'integer' | 'bigint' | 'string' | 'boolean' | 'undefined' | 'null' |\n        'symbol' | 'object' | 'function',\n    value: any) {\n\n    switch (targetType) {\n    case 'number':\n        if (typeof value === 'number') {\n            return value;\n        } else {\n            const a = Number.parseFloat(String(value));\n            if (Number.isNaN(a)) {\n                return Number(value ?? 0);\n            } else {\n                return a;\n            }\n        }\n    case 'integer':\n        if (typeof value === 'number' && Math.trunc(value) === value) {\n            return value;\n        } else {\n            let a = Number.parseFloat(String(value));\n            if (Number.isNaN(a)) {\n                a = Number(value ?? 0);\n            }\n            return Math.trunc(a);\n        }\n    case 'bigint':\n        try {\n            return BigInt(value ?? 0);\n        } catch {\n            return NaN;\n        }\n    case 'string':\n        return String(value);\n    case 'boolean':\n        return Boolean(value);\n    case 'undefined':\n        return void 0;\n    case 'null':\n        return null;\n    default:\n        return value;\n    }\n}\n\n\nfunction checkCustomConstraints(\n    data: any, ty: TypeAssertion, ctx: ValidationContext): boolean | null {\n\n    if (ty.customConstraints && ctx.customConstraints) {\n        for (const ccName of ty.customConstraints) {\n            if (ctx.customConstraints.has(ccName)) {\n                const cc = ctx.customConstraints.get(ccName) as CustomConstraintInfo;\n                if (cc.kinds && !cc.kinds.includes(ty.kind)) {\n                    return null;\n                }\n                if (! cc.check(data, ty.customConstraintsArgs && ty.customConstraintsArgs[ccName])) {\n                    return null;\n                }\n            } else {\n                throw new Error(`Undefined constraint is specified: ${ccName}`);\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\n\nfunction validateNeverTypeAssertion<T>(\n    data: any, ty: NeverTypeAssertion, ctx: ValidationContext): null {\n\n    reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n    return null;\n}\n\n\nfunction validateAnyTypeAssertion<T>(\n    data: any, ty: AnyTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let chkSt = checkStereotypes(data, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: data,\n            stereotype: noopStereotype,\n        };\n    }\n    const styp = chkSt.stereotype;\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    // always matched\n    return ({value: ctx.mapper\n        ? ctx.mapper(styp.doCast ? chkSt.value : data, ty)\n        :            styp.doCast ? chkSt.value : data});\n}\n\n\nfunction validateUnknownTypeAssertion<T>(\n    data: any, ty: UnknownTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let chkSt = checkStereotypes(data, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: data,\n            stereotype: noopStereotype,\n        };\n    }\n    const styp = chkSt.stereotype;\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    // always matched\n    return ({value: ctx.mapper\n        ? ctx.mapper(styp.doCast ? chkSt.value : data, ty)\n        :            styp.doCast ? chkSt.value : data});\n}\n\n\nfunction validatePrimitiveTypeAssertion<T>(\n    data: any, ty: PrimitiveTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    const chkTarget = ty.forceCast ? forceCast(ty.primitiveName, data) : data;\n\n    if (ty.primitiveName === 'null') {\n        if (chkTarget !== null) {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n    } else if (ty.primitiveName === 'integer') {\n        if (typeof chkTarget !== 'number') {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n        if (Math.trunc(chkTarget) !== chkTarget) {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n    } else if (typeof chkTarget !== ty.primitiveName) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    // TODO: Function, DateStr, DateTimeStr\n\n    let chkSt = checkStereotypes(chkTarget, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: chkTarget,\n            stereotype: ty.forceCast ? noopStereotype : noopStereotype,\n        };\n    }\n\n    const styVal = chkSt.value;\n    const styp = chkSt.stereotype;\n    let err = false;\n\n    let valueRangeErr = false;\n    switch (typeof ty.minValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.minValue)) < 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.maxValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.maxValue)) > 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.greaterThanValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.greaterThanValue)) <= 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.lessThanValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.lessThanValue)) >= 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n\n    let valueLengthErr = false;\n    switch (typeof ty.minLength) {\n    case 'number':\n        if (typeof styVal !== 'string' || styVal.length < ty.minLength) {\n            if (! valueLengthErr) {\n                reportError(ErrorTypes.ValueLengthUnmatched, data, ty, {ctx});\n            }\n            valueLengthErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.maxLength) {\n    case 'number':\n        if (typeof styVal !== 'string' || styVal.length > ty.maxLength) {\n            if (! valueLengthErr) {\n                reportError(ErrorTypes.ValueLengthUnmatched, data, ty, {ctx});\n            }\n            valueLengthErr = true;\n            err = true;\n        }\n    }\n\n    if (ty.pattern) {\n        if (typeof styVal !== 'string' || !ty.pattern.test(styVal)) {\n            reportError(ErrorTypes.ValuePatternUnmatched, data, ty, {ctx});\n            err = true;\n        }\n    }\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        err = true;\n    }\n\n    const ret = !err\n        ? {value: ctx.mapper\n            ? ctx.mapper(styp.doCast ? chkSt.value : chkTarget, ty)\n            :            styp.doCast ? chkSt.value : chkTarget}\n        : null;\n    return ret;\n}\n\n\nfunction validatePrimitiveValueTypeAssertion<T>(\n    data: any, ty: PrimitiveValueTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    const chkTarget = ty.forceCast ? forceCast(typeof ty.value, data) : data;\n\n    let chkSt = checkStereotypes(chkTarget, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: chkTarget,\n            stereotype: ty.forceCast ? noopStereotype : noopStereotype,\n        };\n    }\n    const styp = chkSt.stereotype;\n\n    let ret = styp.compare(chkSt.value, styp.evaluateFormula(ty.value)) === 0\n        ? {value: ctx.mapper\n            ? ctx.mapper(styp.doCast ? chkSt.value : chkTarget, ty)\n            :            styp.doCast ? chkSt.value : chkTarget}\n        : null;\n    if (! ret) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n    }\n\n    if (ret && checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        ret = null;\n    }\n\n    return ret;\n}\n\n\nfunction validateRepeatedAssertion<T>(\n    data: any, ty: RepeatedAssertion, ctx: ValidationContext): {value: T} | null {\n\n    if (! Array.isArray(data)) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    if (typeof ty.min === 'number' && data.length < ty.min) {\n        reportError(ErrorTypes.RepeatQtyUnmatched, data, ty, {ctx});\n        return null;\n    }\n    if (typeof ty.max === 'number' && data.length > ty.max) {\n        reportError(ErrorTypes.RepeatQtyUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    const retVals: any[] = [];\n    for (let i = 0; i < data.length; i++) {\n        const x = data[i];\n        const r = validateRoot<T>(x, ty.repeated, ctx, i);\n        if (! r) {\n            return null;\n        }\n        retVals.push(r.value);\n    }\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    return {value: retVals as any};\n}\n\n\nfunction validateSequenceAssertion<T>(\n    data: any, ty: SequenceAssertion, ctx: ValidationContext): {value: T} | null {\n\n    if (! Array.isArray(data)) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    let dIdx = 0, // index of data\n        sIdx = 0; // index of types\n    let spreadLen = 0;\n    let optionalOmitted = false;\n\n    const checkSpreadQuantity = (ts: SpreadAssertion, index: number) => {\n        if (typeof ts.min === 'number' && spreadLen < ts.min) {\n            reportErrorWithPush(\n                spreadLen === 0 ?\n                    ErrorTypes.TypeUnmatched :\n                    ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        if (typeof ts.max === 'number' && spreadLen > ts.max) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        return ts;\n    };\n\n    const checkOptionalQuantity = (ts: OptionalAssertion, index: number) => {\n        if (spreadLen === 0) {\n            // All subsequent 'optional' assertions should be 'spreadLen === 0'.\n            optionalOmitted = true;\n        } else if (optionalOmitted) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        } else if (spreadLen > 1) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        return ts;\n    };\n\n    const retVals: any[] = [];\n    while (dIdx < data.length && sIdx < ty.sequence.length) {\n        const ts = ty.sequence[sIdx];\n        if (ts.kind === 'spread') {\n            const savedErrLen = ctx.errors.length;\n            const r = validateRoot<T>(data[dIdx], ts.spread, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                spreadLen++;\n            } else {\n                // End of spreading\n                // rollback reported errors\n                ctx.errors.length = savedErrLen;\n                if (! checkSpreadQuantity(ts, dIdx)) {\n                    return null;\n                }\n                spreadLen = 0;\n                sIdx++;\n            }\n        } else if (ts.kind === 'optional') {\n            const savedErrLen = ctx.errors.length;\n            const r = validateRoot<T>(data[dIdx], ts.optional, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                spreadLen++;\n            } else {\n                // End of spreading\n                // rollback reported errors\n                ctx.errors.length = savedErrLen;\n                if (! checkOptionalQuantity(ts, dIdx)) {\n                    return null;\n                }\n                spreadLen = 0;\n                sIdx++;\n            }\n        } else {\n            const r = validateRoot<T>(data[dIdx], ts, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                sIdx++;\n            } else {\n                return null;\n            }\n        }\n    }\n    while (sIdx < ty.sequence.length) {\n        const ts = ty.sequence[sIdx];\n        if (ts.kind === 'spread') {\n            if (! checkSpreadQuantity(ts, dIdx)) {\n                return null;\n            }\n            spreadLen = 0;\n            sIdx++;\n        } else if (ts.kind === 'optional') {\n            if (! checkOptionalQuantity(ts, dIdx)) {\n                return null;\n            }\n            spreadLen = 0;\n            sIdx++;\n        } else {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, dIdx], {ctx});\n            return null;\n        }\n    }\n\n    const ret = data.length === dIdx ? {value: retVals as any} : null;\n    if (! ret) {\n        reportError(ErrorTypes.SequenceUnmatched, data, ty, {ctx});\n    }\n\n    if (ret && checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    return ret;\n}\n\n\nfunction validateOneOfAssertion<T>(\n    data: any, ty: OneOfAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let choosed = false;\n    const savedCtxRecordTypeFieldValidated = ctx.recordTypeFieldValidated;\n    ctx.recordTypeFieldValidated = false;\n\n    const savedErrLen = ctx.errors.length;\n    let count = 0;\n    let firstErrLen = savedErrLen;\n\n    for (const tyOne of ty.oneOf) {\n        const r = validateRoot<T>(data, tyOne, ctx);\n        if (r) {\n            // rollback reported errors\n            ctx.errors.length = savedErrLen;\n            ctx.recordTypeFieldValidated = savedCtxRecordTypeFieldValidated;\n            return r;\n        }\n\n        if (ctx.recordTypeFieldValidated) {\n            if (count !== 0) {\n                const e2 = ctx.errors.slice(firstErrLen);\n                ctx.errors.length = savedErrLen;\n                ctx.errors.push(...e2);\n            }\n            choosed = true;\n            break;\n        }\n\n        if (count === 0) {\n            firstErrLen = ctx.errors.length;\n        } else {\n            ctx.errors.length = firstErrLen;\n        }\n        count++;\n    }\n\n    if (! choosed) {\n        if (! ctx.checkAll) {\n            // rollback reported errors\n            ctx.errors.length = savedErrLen;\n        }\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n    }\n\n    ctx.recordTypeFieldValidated = savedCtxRecordTypeFieldValidated;\n    return null;\n}\n\n\nfunction validateEnumAssertion<T>(\n    data: any, ty: EnumAssertion, ctx: ValidationContext): {value: T} | null {\n\n    for (const v of ty.values) {\n        if (data === v[1]) {\n            return ({value: ctx.mapper ? ctx.mapper(data, ty) : data});\n        }\n    }\n    reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n    return null;\n}\n\n\nfunction validateObjectAssertion<T>(\n    data: any, ty: ObjectAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let retVal = Array.isArray(data) ? [...data] : {...data};\n    const revMembers = ty.members.slice().reverse();\n    for (const x of ty.members) {\n        if (ty.members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(\n                `Duplicated member is found: ${x[0]} in ${ty.name || '(unnamed)'}`, ty, ctx);\n        }\n    }\n\n    if (data === null || typeof data !== 'object') {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        if (ctx && ctx.checkAll) {\n            retVal = null;\n        } else {\n            return null;\n        }\n    } else {\n        const dataMembers = new Set<string>();\n        if (ctx.noAdditionalProps || ty.additionalProps && 0 < ty.additionalProps.length) {\n            if (! Array.isArray(data)) {\n                for (const m in data) {\n                    if (Object.prototype.hasOwnProperty.call(data, m)) {\n                        dataMembers.add(m);\n                    }\n                }\n            }\n        }\n        if (ctx.noAdditionalProps && Array.isArray(data) && 0 < data.length) {\n            const aps = ty.additionalProps || [];\n            if (aps.filter(x => x[0].includes('number')).length === 0) {\n                reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                    ctx,\n                    substitutions: [['addtionalProps', '[number]']],\n                });\n                if (ctx && ctx.checkAll) {\n                    retVal = null;\n                } else {\n                    return null;\n                }\n            }\n        }\n\n        for (const x of ty.members) {\n            dataMembers.delete(x[0]);\n            if (Object.prototype.hasOwnProperty.call(data, x[0])) {\n                const mt = x[1].kind === 'optional' ?  // TODO: set name at compile time\n                    {\n                        ...x[1].optional,\n                        name: x[0],\n                        message: x[1].message,\n                        messages: x[1].messages,\n                        messageId: x[1].messageId,\n                    } : x[1];\n                const ret = validateRoot<T>(data[x[0]], mt, ctx);\n\n                if (ret) {\n                    if (retVal) {\n                        if (isUnsafeVarNames(retVal, x[0])) {\n                            continue;\n                        }\n                        retVal[x[0]] = ret.value;\n                        if (mt.isRecordTypeField) {\n                            ctx.recordTypeFieldValidated = true;\n                        }\n                    }\n                } else {\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                if (x[1].kind !== 'optional') {\n                    reportErrorWithPush(ErrorTypes.Required, data, [x[1], void 0], {ctx});\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        if (ty.additionalProps && 0 < ty.additionalProps.length) {\n            function* getAdditionalMembers() {\n                for (const m of dataMembers.values()) {\n                    yield m;\n                }\n                if (Array.isArray(data)) {\n                    for (let i = 0; i < data.length; i++) {\n                        yield String(i);\n                    }\n                }\n            }\n            for (const m of getAdditionalMembers()) {\n                let allowImplicit = false;\n                const matchedAssertions: TypeAssertion[] = [];\n\n                for (const ap of ty.additionalProps) {\n                    for (const pt of ap[0]) {\n                        const at = ap[1];\n                        if (pt === 'number') {\n                            if (NumberPattern.test(m)) {\n                                matchedAssertions.push(at);\n                            }\n                        } else if (pt === 'string') {\n                            matchedAssertions.push(at);\n                        } else {\n                            if (pt.test(m)) {\n                                matchedAssertions.push(at);\n                            }\n                        }\n                        if (at.kind === 'optional') {\n                            allowImplicit = true;\n                        }\n                    }\n                }\n                if (matchedAssertions.length === 0) {\n                    if (allowImplicit) {\n                        continue;\n                    }\n                    reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                        ctx,\n                        substitutions: [['addtionalProps', m]],\n                    });\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                        continue;\n                    } else {\n                        return null;\n                    }\n                }\n\n                dataMembers.delete(m);\n                let hasError = false;\n                const savedErrLen = ctx.errors.length;\n\n                for (const at of matchedAssertions) {\n                    const ret = validateRoot<T>(data[m], at.kind === 'optional' ?\n                        {\n                            ...at.optional,\n                            message: at.message,\n                            messages: at.messages,\n                            messageId: at.messageId,\n                            name: m,\n                        } : {\n                            ...at,\n                            name: m,\n                        }, ctx);\n                    if (ret) {\n                        if (retVal) {\n                            hasError = false;\n                            ctx.errors.length = savedErrLen;\n                            if (isUnsafeVarNames(retVal, m)) {\n                                continue;\n                            }\n                            retVal[m] = ret.value;\n                        }\n                        break;\n                    } else {\n                        hasError = true;\n                    }\n                }\n                if (hasError) {\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        if (ctx.noAdditionalProps && 0 < dataMembers.size) {\n            reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                ctx,\n                substitutions: [['addtionalProps', Array.from(dataMembers.values()).join(', ')]],\n            });\n            if (ctx && ctx.checkAll) {\n                retVal = null;\n            } else {\n                return null;\n            }\n        }\n    }\n    if (! retVal) {\n        // TODO: Child is unmatched. reportError?\n        // TODO: report object's custom error message\n    }\n\n    if (retVal && checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    return retVal ? {value: (ctx && ctx.mapper) ? ctx.mapper(retVal, ty) : retVal} : null;\n}\n\n\nexport function validateRoot<T>(\n    data: any, ty: TypeAssertion, ctx: ValidationContext, dataIndex?: number | string): {value: T} | null {\n\n    try {\n        ctx.typeStack.push(\n            typeof dataIndex === 'number' || typeof dataIndex === 'string' ?\n            [ty, dataIndex] : ty);\n\n        switch (ty.kind) {\n        case 'never':\n            return validateNeverTypeAssertion(data, ty, ctx);\n        case 'any':\n            return validateAnyTypeAssertion(data, ty, ctx);\n        case 'unknown':\n            return validateUnknownTypeAssertion(data, ty, ctx);\n        case 'primitive':\n            return validatePrimitiveTypeAssertion(data, ty, ctx);\n        case 'primitive-value':\n            return validatePrimitiveValueTypeAssertion(data, ty, ctx);\n        case 'repeated':\n            return validateRepeatedAssertion(data, ty, ctx);\n        case 'sequence':\n            return validateSequenceAssertion(data, ty, ctx);\n        case 'one-of':\n            return validateOneOfAssertion(data, ty, ctx);\n        case 'enum':\n            return validateEnumAssertion(data, ty, ctx);\n        case 'object':\n            return validateObjectAssertion(data, ty, ctx);\n        case 'symlink':\n            if (ctx.schema) {\n                return validateRoot<T>(data, resolveSymbols(ctx.schema, ty, {nestLevel: 0, symlinkStack: []}), ctx);\n            }\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unresolved symbol '${ty.symlinkTargetName}' is appeared.`, ty, ctx);\n        case 'operator':\n            if (ctx.schema) {\n                return validateRoot<T>(data, resolveSymbols(ctx.schema, ty, {nestLevel: 0, symlinkStack: []}), ctx);\n            }\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unresolved type operator is found: ${ty.operator}`, ty, ctx);\n        case 'spread': case 'optional':\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unexpected type assertion: ${(ty as any).kind}`, ty, ctx);\n        default:\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unknown type assertion: ${(ty as any).kind}`, ty, ctx);\n        }\n    } finally {\n        ctx.typeStack.pop();\n    }\n}\n\n\nexport function validate<T>(\n    data: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): {value: T} | null {\n\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n    };\n    try {\n        return validateRoot<T>(data, ty, ctx2);\n    } finally {\n        if (ctx) {\n            ctx.errors = ctx2.errors;\n        }\n    }\n}\n\n\nexport function isType<T>(\n    data: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): data is T {\n\n    return (!! validate<T>(data, ty, ctx));\n}\n\n\nexport function assertType<T>(\n    data: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): asserts data is T {\n\n    if (! validate<T>(data, ty, ctx)) {\n        throw new Error(`Assertion failed: Expected data should be of type \"${ty.typeName || ty.name || '?'}\".`);\n    }\n}\n\n\nexport function getType(schema: TypeAssertionMap, name: string): TypeAssertion {\n    if (schema.has(name)) {\n        return schema.get(name)?.ty as TypeAssertion;\n    }\n    throw new Error(`Undefined type name is referred: ${name}`);\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\n\r\nexport type SxMacro = (state: SxParserState, name: string, formalArgs?: SxSymbol[]) => (list: SxToken[]) => SxToken;\r\n\r\nexport interface SxMacroInfo {\r\n    name: string;\r\n    fn: SxMacro;\r\n\r\n    formalArgs?: SxSymbol[];\r\n    lastIsSpread?: boolean;\r\n    next?: SxMacroInfo;\r\n}\r\n\r\n\r\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\r\n\r\nexport interface SxFuncInfo {\r\n    name: string;\r\n    fn: SxFunc;\r\n\r\n    // TODO: overloading\r\n    // formalArgs?: SxSymbol[];\r\n    // lastIsSpread?: boolean;\r\n    // next?: SxFuncInfo;\r\n}\r\n\r\n\r\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\r\n\r\nexport interface SxSymbolInfo {\r\n    name: string;\r\n    fn: SxSymbolResolver;\r\n}\r\n\r\n\r\nexport interface CapturedScopes { [s: string]: { [s: string]: any; }; }\r\n\r\nexport interface SxScope {\r\n    isBlockLocal: boolean;\r\n    scope: any;           // { [s: string]: any; };\r\n    capturedScopes?: CapturedScopes;\r\n}\r\n\r\n\r\nexport interface SxReservedNames {\r\n    eval: string;\r\n    quote: string;\r\n    backquote: string;\r\n    unquote: string;\r\n    spread: string;\r\n    splice: string;\r\n\r\n    car: string;\r\n    cdr: string;\r\n    cons: string;\r\n    atom: string;\r\n    eq: string;\r\n    list: string;\r\n\r\n    let: string;\r\n    lambda: string;\r\n    self: string;\r\n    defun: string;\r\n    thiz: string;\r\n\r\n    if: string;\r\n    cond: string;\r\n\r\n    while: string;\r\n    doWhile: string;\r\n    until: string;\r\n    doUntil: string;\r\n\r\n    get: string;\r\n    defvar: string;\r\n    setq: string;\r\n    set: string;\r\n    call: string;\r\n\r\n    not: string;\r\n    and: string;\r\n    or: string;\r\n\r\n    isSymbol: string;\r\n    gensym: string;\r\n    raise: string;\r\n    catch: string;\r\n\r\n    Template: string;\r\n}\r\n\r\nexport interface SxParserConfig {\r\n    raiseOnUnresolvedSymbol: boolean;\r\n    enableEvaluate: boolean;\r\n    enableHereDoc: boolean;\r\n    enableSpread: boolean;\r\n    enableSplice: boolean;\r\n    enableShorthands: boolean;\r\n    enableVerbatimStringLiteral: boolean;\r\n    enableTailCallOptimization: boolean;\r\n    enableRegExpMatchOperators: boolean; // IMPORTANT: Turn off to prevent ReDoS when executing untrusted code\r\n    enableCompilationOperators: boolean; // IMPORTANT: Turn off to prevent DoS when executing untrusted code\r\n    stripComments: boolean;\r\n    wrapExternalValue: boolean;\r\n    reservedNames: SxReservedNames;\r\n    returnMultipleRoot: boolean;\r\n    maxEvalCount: number;                // IMPORTANT: Set positive value to prevent DoS when executing untrusted code\r\n\r\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\r\n    JsxFragment?: any;\r\n\r\n    funcs: SxFuncInfo[];\r\n    macros: SxMacroInfo[];\r\n    symbols: SxSymbolInfo[];\r\n\r\n    funcSymbolResolverFallback?: SxFunc;\r\n    valueSymbolResolverFallback?: SxSymbolResolver;\r\n}\r\n\r\nexport interface SxParserState {\r\n    strings: TemplateStringsArray | string[];\r\n    values: any[];\r\n\r\n    index: number;\r\n    pos: number;\r\n    line: number;\r\n\r\n    evalCount: number;\r\n\r\n    scopes: SxScope[];\r\n\r\n    macroMap: Map<string, SxMacroInfo>;\r\n    funcMap: Map<string, SxFuncInfo>;\r\n    symbolMap: Map<string, SxSymbolInfo>;\r\n\r\n    config: SxParserConfig;\r\n}\r\n\r\nexport interface SxEof {\r\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\r\n    eofSeq?: string;\r\n}\r\n\r\nexport interface SxExternalValue {\r\n    value: any;\r\n}\r\n\r\nexport interface SxSymbol {\r\n    'symbol': string;\r\n\r\n    // TODO: debug info\r\n    // _fileName?: string;\r\n    // _line?: number;\r\n    // _col?: number;\r\n}\r\n\r\nexport interface SxComment {\r\n    comment: string;\r\n}\r\n\r\nexport interface SxDottedPair {\r\n    car: SxToken; // left\r\n    cdr: SxToken; // right\r\n}\r\n\r\nexport interface SxDottedFragment {\r\n    dotted: SxToken; // right\r\n}\r\n\r\n\r\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\r\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\r\nexport type SxChar = string | SxEof | SxExternalValue;\r\nexport type SxAtom = SxSymbol | string | number | boolean | null;\r\nexport type SxList = SxDottedPair | SxAtom[];\r\n\r\n\r\n\r\nexport type CompilerOperator = (r: SxToken[], args: SxToken[]) => string;\r\n\r\n\r\nexport interface CompilerContext {\r\n    _$_vars: any[];\r\n    varsCount: number;\r\n    varNames: Map<string, string>;\r\n    varNamesCount: number;\r\n    varDefs: string;\r\n    ops: Map<string, CompilerOperator>;\r\n    makeScope: (scoped: () => void) => void;\r\n    compileToken: (body: any[], i: number) => string;\r\n}\r\n\r\n\r\nexport interface LsxConfig {\r\n    jsx: (comp: any, props: any, ...children: any[]) => any;\r\n    jsxFlagment: any;\r\n    components: object;\r\n}\r\n\r\n\r\nexport class FatalError extends Error {\r\n    public constructor(message?: string | undefined) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n\r\nexport class MaxEvaluationCountError extends FatalError {\r\n    public constructor() {\r\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\r\n    }\r\n}\r\n\r\n\r\nexport class ScriptTerminationError extends FatalError {\r\n    public constructor(where: string) {\r\n        super(`[SX] ${where}: Unexpected termination of script.`);\r\n    }\r\n}\r\n\r\n\r\nexport interface SExpressionRepl<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => R;\r\n}\r\n\r\n\r\nexport interface SExpressionTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    evaluateAST: (ast: SxToken[]) => R;\r\n    repl: () => SExpressionRepl<R>;\r\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionTemplateFn<R>;\r\n}\r\n\r\n\r\nexport interface SExpressionAsyncRepl<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => Promise<R>;\r\n}\r\n\r\n\r\nexport interface SExpressionAsyncTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    evaluateAST: (ast: SxToken[]) => Promise<R>;\r\n    repl: () => SExpressionAsyncRepl<R>;\r\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionAsyncTemplateFn<R>;\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { RecursivePartial,\n         TypeAssertion,\n         ValidationContext } from './types';\nimport { ValidationError }   from './lib/errors';\nimport { isUnsafeVarNames }  from './lib/protection';\nimport { validate }          from './validator';\n\n\n\nfunction pickMapper(value: any, ty: TypeAssertion) {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const ret = Array.isArray(value) ? [] : {};\n\n            const dataMembers = new Set<string>();\n            if (! Array.isArray(value)) {\n                for (const m in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, m)) {\n                        dataMembers.add(m);\n                    }\n                }\n            }\n\n            for (const x of ty.members) {\n                if (Object.hasOwnProperty.call(value, x[0])) {\n                    dataMembers.delete(x[0]);\n                    ret[x[0]] = value[x[0]];\n                }\n            }\n            if (ty.additionalProps && 0 < ty.additionalProps.length) {\n                function* getAdditionalMembers() {\n                    for (const m of dataMembers.values()) {\n                        yield m;\n                    }\n                    if (Array.isArray(value)) {\n                        for (let i = 0; i < value.length; i++) {\n                            yield String(i);\n                        }\n                    }\n                }\n                for (const m of getAdditionalMembers()) {\n                    ret[m] = value[m];\n                }\n            }\n            return ret;\n        }\n    default:\n        return value;\n    }\n}\n\n\nexport function pickRoot<T>(data: T, ty: TypeAssertion, ctx: ValidationContext): T {\n    switch (ty.kind) {\n    case 'never':\n        throw new ValidationError(`Type unmatched: ${(ty as any).kind}`, ty, ctx);\n    case 'any':\n        // FALL_THRU\n    case 'unknown':\n        // FALL_THRU\n    case 'primitive':\n        // FALL_THRU\n    case 'primitive-value':\n        // FALL_THRU\n    case 'repeated':\n        // FALL_THRU\n    case 'sequence':\n        // FALL_THRU\n    case 'one-of':\n        // FALL_THRU\n    case 'enum':\n        // FALL_THRU\n    case 'object':\n        {\n            const r = validate<T>(data, ty, ctx);\n            if (r) {\n                return r.value;\n            } else {\n                throw new ValidationError('Validation failed.', ty, ctx);\n            }\n        }\n    case 'spread': case 'optional': case 'symlink': case 'operator':\n        throw new ValidationError(`Unexpected type assertion: ${(ty as any).kind}`, ty, ctx);\n    default:\n        throw new ValidationError(`Unknown type assertion: ${(ty as any).kind}`, ty, ctx);\n    }\n}\n\n\nexport function pick<T>(data: T, ty: TypeAssertion, ctx?: Partial<ValidationContext>): RecursivePartial<T> {\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n        mapper: pickMapper,\n    };\n    try {\n        return pickRoot<T>(data, ty, ctx2);\n    } finally {\n        if (ctx) {\n            ctx.errors = ctx2.errors;\n        }\n    }\n}\n\n\nfunction merge(data: any, needle: any) {\n    if (data === null || data === void 0) {\n        return needle;\n    }\n    switch (typeof data) {\n    case 'object':\n        if (Array.isArray(data)) {\n            return [...needle];\n        } else {\n            const r: any = {...data};\n            for (const k in needle) {\n                if (Object.prototype.hasOwnProperty.call(needle, k)) {\n                    if (isUnsafeVarNames(r, k)) {\n                        continue;\n                    }\n                    r[k] = merge(r[k], needle[k]);\n                }\n            }\n            return r;\n        }\n    default:\n        return needle;\n    }\n}\n\n\nexport function patch<T>(data: T, needle: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): T {\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n    };\n    const validated = pick<T>(needle, ty, ctx2);\n    return merge(data, validated);\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { Stereotype }         from '../types';\nimport { DatePattern,\n         DateTimePattern,\n         DateTimeNoTzPattern } from '../lib/util';\n\n\n\nconst FyPattern = /^first-date-of-fy\\(([0-9]+)\\)$/;\nconst FormulaPattern = /^([-+@])([0-9]+)(yr|mo|day|days|hr|min|sec|ms)$/;\n\n\nclass UtcDate extends Date {\n    public constructor();\n    // tslint:disable-next-line: unified-signatures\n    public constructor(str: string);\n    public constructor(\n        year: number, month: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number)\n    public constructor(\n        year?: number | string, month?: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number) {\n\n        super();\n        if (year === void 0) {\n            return;\n        }\n        if (typeof year === 'string') {\n            if (DateTimePattern.test(year)) {\n                // string parameter is expected to be treated as specified TZ\n                this.setTime(Date.parse(year)); // returns date in specified TZ\n            } else if (DatePattern.test(year)) {\n                // string parameter is expected to be treated as UTC\n                const d = new Date(year);       // returns date in UTC TZ (getUTC??? returns string parameter's date & time digits)\n                this.setTime(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));\n            } else if (DateTimeNoTzPattern.test(year)) {\n                // string parameter is expected to be treated as UTC\n                const d = new Date(year);       // returns date in local TZ (get??? returns string parameter's date & time digits)\n                this.setTime(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(),\n                    d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));\n            } else {\n                this.setTime(NaN);\n            }\n            return;\n        }\n\n        this.setUTCDate(1);\n\n        this.setUTCFullYear(year);\n        this.setUTCMonth(typeof month === 'number' ? month : 0);\n        this.setUTCDate(typeof date === 'number' ? date : 1);\n        this.setUTCHours(typeof hours === 'number' ? hours : 0);\n        this.setUTCMinutes(typeof minutes === 'number' ? minutes : 0);\n        this.setUTCSeconds(typeof seconds === 'number' ? seconds : 0);\n        this.setUTCMilliseconds(typeof ms === 'number' ? ms : 0);\n    }\n\n    public getFullYear(): number {\n        return this.getUTCFullYear();\n    }\n\n    public getMonth(): number {\n        return this.getUTCMonth();\n    }\n\n    public getDate(): number {\n        return this.getUTCDate();\n    }\n\n    public getHours(): number {\n        return this.getUTCHours();\n    }\n\n    public getMinutes(): number {\n        return this.getUTCMinutes();\n    }\n\n    public getSeconds(): number {\n        return this.getUTCSeconds();\n    }\n\n    public getMilliseconds(): number {\n        return this.getUTCMilliseconds();\n    }\n\n    // NOTE: set???() are not overridden!\n}\n\n\nclass LcDate extends Date {\n    public constructor();\n    // tslint:disable-next-line: unified-signatures\n    public constructor(str: string);\n    public constructor(\n        year: number, month: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number)\n    public constructor(\n        year?: number | string, month?: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number) {\n\n        super();\n        if (year === void 0) {\n            return;\n        }\n        if (typeof year === 'string') {\n            if (DateTimePattern.test(year)) {\n                // string parameter is expected to be treated as specified TZ\n                this.setTime(Date.parse(year)); // returns date in specified TZ\n            } else if (DatePattern.test(year)) {\n                // string parameter is expected to be treated as local TZ\n                const d = new Date(year);       // returns date in UTC TZ (getUTC??? returns string parameter's date & time digits)\n                const l = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());\n                this.setTime(l.getTime());\n            } else if (DateTimeNoTzPattern.test(year)) {\n                // string parameter is expected to be treated as local TZ\n                const d = new Date(year);       // returns date in local TZ (get??? returns string parameter's date & time digits)\n                this.setTime(d.getTime());\n            } else {\n                this.setTime(NaN);\n            }\n            return;\n        }\n\n        this.setDate(1);\n\n        this.setFullYear(year);\n        this.setMonth(typeof month === 'number' ? month : 0);\n        this.setDate(typeof date === 'number' ? date : 1);\n        this.setHours(typeof hours === 'number' ? hours : 0);\n        this.setMinutes(typeof minutes === 'number' ? minutes : 0);\n        this.setSeconds(typeof seconds === 'number' ? seconds : 0);\n        this.setMilliseconds(typeof ms === 'number' ? ms : 0);\n    }\n}\n\n\ninterface DateConstructor {\n    new (): Date;\n    // tslint:disable-next-line: unified-signatures\n    new (str: string): Date;\n    new (year: number, month: number, date?: number,\n         hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\n}\n\n\nfunction evaluateFormulaBase(dateCtor: DateConstructor, valueOrFormula: string): Date {\n    const errMsg = `evaluateFormula: invalid parameter ${valueOrFormula}`;\n    if (typeof valueOrFormula !== 'string') {\n        throw new Error(errMsg);\n    }\n    if (valueOrFormula.startsWith('=')) {\n        const formula = valueOrFormula.slice(1).split(' ');\n        let d = new dateCtor();\n        const now = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());\n        const today = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate());\n        d = now;\n        for (const f of formula) {\n            switch (f) {\n            case 'current': case 'now':\n                d = now;\n                break;\n            case 'today':\n                d = today;\n                break;\n            case 'first-date-of-yr': case 'first-date-of-fy(1)':\n                d = new dateCtor(d.getFullYear(), 0, 1);\n                break;\n            case 'last-date-of-yr':\n                d = new dateCtor(d.getFullYear(), 11, 31);\n                break;\n            case 'first-date-of-mo':\n                d = new dateCtor(d.getFullYear(), d.getMonth(), 1);\n                break;\n            case 'last-date-of-mo':\n                d = new dateCtor(d.getFullYear(), d.getMonth() + 1, 0);\n                break;\n            default:\n                if (f.startsWith('first-date-of-fy(')) {\n                    const m = FyPattern.exec(f);\n                    if (m) {\n                        const n = Number.parseInt(m[1], 10);\n                        if (0 < n && n <= 12) {\n                            const mo = d.getMonth() + 1;\n                            let yr = d.getFullYear();\n                            if (mo < n) {\n                                yr--;\n                            }\n                            d = new dateCtor(yr, n - 1, 1);\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    } else {\n                        throw new Error(errMsg);\n                    }\n                } else {\n                    const m = FormulaPattern.exec(f);\n                    if (m) {\n                        let n = Number.parseInt(m[2], 10);\n                        switch (m[3]) {\n                        case 'yr':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getFullYear() + n;\n                                break;\n                            case '-':\n                                n = d.getFullYear() - n;\n                                break;\n                            }\n                            d = new dateCtor(n, d.getMonth(), d.getDate(),\n                                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'mo':\n                            switch (m[1]) {\n                            case '@':\n                                n -= 1;\n                                break;\n                            case '+':\n                                n = d.getMonth() + n;\n                                break;\n                            case '-':\n                                n = d.getMonth() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), n, d.getDate(),\n                                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'day': case 'days':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getDate() + n;\n                                break;\n                            case '-':\n                                n = d.getDate() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), n,\n                                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'hr':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getHours() + n;\n                                break;\n                            case '-':\n                                n = d.getHours() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                n, d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'min':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getMinutes() + n;\n                                break;\n                            case '-':\n                                n = d.getMinutes() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                d.getHours(), n, d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'sec':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getSeconds() + n;\n                                break;\n                            case '-':\n                                n = d.getSeconds() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                d.getHours(), d.getMinutes(), n, d.getMilliseconds());\n                            break;\n                        case 'ms':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getMilliseconds() + n;\n                                break;\n                            case '-':\n                                n = d.getMilliseconds() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                d.getHours(), d.getMinutes(), d.getSeconds(), n);\n                            break;\n                        default:\n                            throw new Error(errMsg);\n                        }\n                    } else {\n                        if (!(DatePattern.test(f) || DateTimePattern.test(f) || DateTimeNoTzPattern.test(f))) {\n                            throw new Error(errMsg);\n                        }\n                        d = new dateCtor(f);\n                    }\n                }\n            }\n        }\n        return d;\n    } else {\n        if (! DatePattern.test(valueOrFormula)) {\n            throw new Error(errMsg);\n        }\n        return new dateCtor(valueOrFormula);\n    }\n}\n\n\nexport const dateStereotype: Stereotype = {\n    tryParse: (value: unknown) => {\n        return (\n            typeof value === 'string' && DatePattern.test(value)\n                ? { value: (new UtcDate(value)).getTime() }\n                : null\n        );\n    },\n    evaluateFormula: valueOrFormula => {\n        const d = evaluateFormulaBase(UtcDate, valueOrFormula);\n        return (new UtcDate(d.getFullYear(), d.getMonth(), d.getDate())).getTime();\n    },\n    compare: (a: number, b: number) => a - b,\n    doCast: false,\n};\n\n\nexport const lcDateStereotype: Stereotype = {\n    ...dateStereotype,\n    tryParse: (value: unknown) => {\n        if (typeof value === 'string' && DatePattern.test(value)) {\n            return ({ value: (new LcDate(value)).getTime() });\n        } else {\n            return null;\n        }\n    },\n    evaluateFormula: valueOrFormula => {\n        const d = evaluateFormulaBase(LcDate, valueOrFormula);\n        return (new LcDate(d.getFullYear(), d.getMonth(), d.getDate())).getTime();\n    },\n}\n\n\nexport const datetimeStereotype: Stereotype = {\n    tryParse: (value: unknown) => {\n        return (\n            typeof value === 'string' && (DateTimePattern.test(value) || DateTimeNoTzPattern.test(value))\n                ? { value: (new UtcDate(value)).getTime() } // If timezone is not specified, it is local time\n                : null\n        );\n    },\n    evaluateFormula: valueOrFormula => evaluateFormulaBase(UtcDate, valueOrFormula).getTime(),\n    compare: (a: number, b: number) => a - b,\n    doCast: false,\n};\n\n\nexport const lcDatetimeStereotype: Stereotype = {\n    ...datetimeStereotype,\n    tryParse: (value: unknown) => {\n        return (\n            typeof value === 'string' && (DateTimePattern.test(value) || DateTimeNoTzPattern.test(value))\n                ? { value: (new LcDate(value)).getTime() }\n                : null\n        );\n    },\n    evaluateFormula: valueOrFormula => evaluateFormulaBase(LcDate, valueOrFormula).getTime(),\n}\n\n\nexport const stereotypes: Array<[string, Stereotype]> = [\n    ['date', dateStereotype],\n    ['lcdate', lcDateStereotype],\n    ['datetime', datetimeStereotype],\n    ['lcdatetime', lcDatetimeStereotype],\n];\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { CustomConstraintInfo } from '../types';\nimport { dummyTargetObject,\n         isUnsafeVarNames }     from '../lib/protection';\n\n\n\ntype MapperFn = (data: any, fields: string[]) => any[];\nconst mapperErrMsg = 'Unsafe symbol name is appeared in unique constraint assertion:';\n\n\nconst normalMapper: MapperFn = (data: any, fields: string[]) => {\n    const ret: any[] = [];\n    if (0 < fields.length) {\n        for (const field of fields) {\n            if (isUnsafeVarNames(dummyTargetObject, field)) {\n                throw new Error(`${mapperErrMsg} ${field}`);\n            }\n            ret.push(data[field]);\n        }\n    } else {\n        ret.push(data);\n    }\n    return ret;\n};\n\n\nconst nonNullMapper: MapperFn = (data: any, fields: string[]) => {\n    const ret: any[] = [];\n    if (0 < fields.length) {\n        for (const field of fields) {\n            if (isUnsafeVarNames(dummyTargetObject, field)) {\n                throw new Error(`${mapperErrMsg} ${field}`);\n            }\n            ret.push(data[field] ?? NaN);\n        }\n    } else {\n        ret.push(data);\n    }\n    return ret;\n};\n\n\nconst checkerGen = (mapper: MapperFn) => {\n    return ((data: any, args: any) => {\n        const errMsg = `evaluateFormula: invalid parameter ${args}`;\n        if (! Array.isArray(data)) {\n            throw new Error(errMsg);\n        }\n\n        const fields: string[] = [];\n        if (typeof args === 'string') {\n            fields.push(args);\n        } else if (Array.isArray(args)) {\n            for (const z of args) {\n                if (typeof z !== 'string') {\n                    throw new Error(errMsg);\n                }\n            }\n            fields.push(...args);\n        }\n\n        const mapped = data.map(x => mapper(x, fields));\n        for (let i = 0; i < mapped.length; i++) {\n            CMP: for (let j = 0; j < mapped.length; j++) {\n                if (i === j) {\n                    continue;\n                }\n                const a = mapped[i];\n                const b = mapped[j];\n                for (let k = 0; k < a.length; k++) { // TODO: this is slow! more better checking\n                    if (a[k] !== b[k]) {\n                        continue CMP;\n                    }\n                }\n                return false;\n            }\n        }\n\n        return true;\n    });\n};\n\n\nexport const constraints: Array<[string, CustomConstraintInfo]> = [\n    ['unique', {\n        kinds: ['repeated', 'sequence'],\n        check: checkerGen(normalMapper),\n    }],\n    ['unique-non-null', {\n        kinds: ['repeated', 'sequence'],\n        check: checkerGen(nonNullMapper),\n    }],\n];\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         SxFuncInfo,\r\n         CompilerOperator,\r\n         CompilerContext  }           from './types';\r\nimport { isSymbol }                   from './ast';\r\nimport { getCapturedScopes,\r\n         optimizeTailCall }           from './evaluate';\r\nimport { checkUnsafeVarNamesEx }      from './errors';\r\nimport { applyMacros,\r\n         stripQuoteOrPass,\r\n         resolveValueSymbol_dynamic } from './compile.ops/helpers';\r\nimport { registerOperators }          from './compile.ops';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nfunction compileCore(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[], _$_vars: any[]) {\r\n\r\n    function makeScope(scoped: () => void) {\r\n        const varNamesCopy = new Map<string, string>();\r\n        for (const x of ctx.varNames.entries()) {\r\n            varNamesCopy.set(x[0], x[1]);\r\n        }\r\n        scoped();\r\n        ctx.varNames = varNamesCopy;\r\n    }\r\n\r\n\r\n    function compileValue(b: any) {\r\n        let compFnBody = '';\r\n        if (b === null) {\r\n            compFnBody += '(null)';\r\n        } else if (b === void 0) {\r\n            compFnBody += '(void 0)';\r\n        } else switch (typeof b) {\r\n        case 'boolean': case 'number':\r\n            compFnBody += `(${String(b)})`;\r\n            break;\r\n        case 'object':\r\n            if (isSymbol(b)) {\r\n                const sym = b as SxSymbol;\r\n                checkUnsafeVarNamesEx('(compiler)compileValue', ctx.varNames, sym.symbol);\r\n                if (ctx.varNames.has(sym.symbol)) {\r\n                    compFnBody += `(${ctx.varNames.get(sym.symbol)})`;\r\n                } else {\r\n                    _$_vars[ctx.varsCount] = sym.symbol;\r\n                    compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\r\n                }\r\n                break;\r\n            } else {}\r\n            // FALL_THRU\r\n        default:\r\n            _$_vars[ctx.varsCount] = b;\r\n            compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\r\n            break;\r\n        }\r\n        return compFnBody;\r\n    }\r\n\r\n\r\n    function compileToken(body: any[], i: number) {\r\n        let compFnBody = '';\r\n        const b = body[i];\r\n        if (Array.isArray(b)) {\r\n            if (0 < b.length) {\r\n                const r: SxToken = applyMacros(state, b);\r\n                if (Array.isArray(r)) {\r\n                    if (0 < r.length) {\r\n                        if (isSymbol(r[0])) {\r\n                            const sym = r[0] as SxSymbol;\r\n                            const args = r.slice(1);\r\n                            checkUnsafeVarNamesEx('(compiler)compileToken', ops, sym.symbol);\r\n                            if (ops.has(sym.symbol)) {\r\n                                compFnBody += (ops.get(sym.symbol) as CompilerOperator)(r, args);\r\n                            } else {\r\n                                if (sym.symbol === state.config.reservedNames.spread) {\r\n                                    compFnBody += `...(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\r\n                                } else if (state.funcMap.has(sym.symbol)) {\r\n                                    _$_vars[ctx.varsCount] = (state.funcMap.get(sym.symbol) as SxFuncInfo).fn(state, '');\r\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n                                } else if (ctx.varNames.has(sym.symbol)) {\r\n                                    compFnBody += `(${String(ctx.varNames.get(sym.symbol))})(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\r\n                                } else {\r\n                                    _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, sym.symbol);\r\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])()(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            switch (typeof r[0]) {\r\n                            case 'function':\r\n                                _$_vars[ctx.varsCount] = r[0];\r\n                                compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\r\n                                    r.slice(1).map((x, idx, arr) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n                                break;\r\n                            default:\r\n                                throw new Error(`[SX] compileToken: First item of list is not a function: ${JSON.stringify(r[0])}.`);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        compFnBody += '([])';\r\n                    }\r\n                } else {\r\n                    compFnBody += compileValue(b);\r\n                }\r\n            } else {\r\n                compFnBody += '([])';\r\n            }\r\n        } else {\r\n            compFnBody += compileValue(b);\r\n        }\r\n        return compFnBody;\r\n    }\r\n\r\n\r\n    const ctx: CompilerContext = {\r\n        _$_vars,\r\n        varsCount: 1,\r\n        varNames: new Map<string, string>(),\r\n        varNamesCount: 0,\r\n        varDefs: 'var x0;',\r\n        ops: new Map<string, CompilerOperator>(),\r\n        makeScope,\r\n        compileToken,\r\n    };\r\n\r\n    registerOperators(state, ctx);\r\n    const ops = ctx.ops;\r\n\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    // set 'this' object\r\n    ctx.varNames.set(state.config.reservedNames.thiz, `(this===(Function('return this')())?null:(this===void 0?null:this))`);\r\n\r\n    const capturedScopes = getCapturedScopes(state);\r\n    if (capturedScopes) {\r\n        for (const x in capturedScopes) {\r\n            if (Object.prototype.hasOwnProperty.call(capturedScopes, x)) {\r\n                _$_vars[ctx.varsCount++] = x;\r\n                _$_vars[ctx.varsCount] = capturedScopes[x];\r\n                ctx.varNames.set(x, `(_$_vars[${String(ctx.varsCount)}][_$_vars[${String(ctx.varsCount - 1)}]])`);\r\n                ctx.varsCount++;\r\n            }\r\n        }\r\n    }\r\n\r\n    const compFormalArgs = `${formalArgs.map((x, i) => {\r\n        ctx.varNames.set(formalArgs[i].symbol, 'a' + i);\r\n        return `${(lastIsSpread && i === formalArgs.length - 1) ? '...' : ''}a${i}`;\r\n    }).join(',')}`;\r\n\r\n    const compFnBodyRoot = `return(${fnBody.map((x, i) => compileToken(fnBody, i)).join(',')})`;\r\n    return `(function(${compFormalArgs}){\"strict\";${ctx.varDefs}${compFnBodyRoot}})`;\r\n}\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nfunction evalCompiledLambda(_$_state: SxParserState, _$_vars: any[], code: string) {\r\n    // tslint:disable-next-line:no-eval\r\n    _$_vars[0] = eval(code);\r\n    return _$_vars[0];\r\n}\r\n\r\n\r\nexport function compileLambda(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[]) {\r\n    // tslint:disable-next-line:variable-name\r\n    const _$_vars: any[] = [];\r\n    return evalCompiledLambda(state, _$_vars, compileCore(state, formalArgs, lastIsSpread, fnBody, _$_vars));\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         CompilerContext }             from '../types';\r\nimport { isSymbol }                    from '../ast';\r\nimport { checkParamsLength,\r\n         checkUnsafeVarNamesEx,\r\n         checkUnsafeVarNames }         from '../errors';\r\nimport { stripQuote,\r\n         stripQuoteOrPass,\r\n         getScope_stateApplied,\r\n         resolveValueSymbol_dynamic,\r\n         checkUnsafeVarNames_dynamic } from './helpers';\r\n\r\n\r\n\r\nexport function registerOperators(state: SxParserState, ctx: CompilerContext) {\r\n    const {\r\n        _$_vars,\r\n        ops,\r\n        makeScope,\r\n        compileToken,\r\n    } = ctx;\r\n\r\n\r\n    ops.set(state.config.reservedNames.quote, function(r: SxToken[], args: SxToken[]) {\r\n        let compFnBody = '';\r\n        _$_vars[ctx.varsCount] = r[1];\r\n        compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set(state.config.reservedNames.self, function(r: SxToken[], args: SxToken[]) {\r\n        let compFnBody = '';\r\n        compFnBody += `((_$_vars[0])(${\r\n            args.map(x => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__if', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__if condition 't-expr 'f-expr)\r\n        //  -> (if condition is true ) S expr  : t-expr\r\n        //  -> (if condition is false) S expr  : f-expr\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__if', args, 2, 3);\r\n        compFnBody += `(${compileToken(r, 1)}?(${\r\n            compileToken([stripQuote(state, r[2])], 0)}):(${\r\n            compileToken([stripQuote(state, r[3])], 0)}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__if-null', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__if-null condition 'null-expr)\r\n        //  -> (if condition is not null ) S expr  : condition\r\n        //  -> (if condition is null)      S expr  : null-expr\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__if-null', args, 2, 2);\r\n        compFnBody += `((()=>{let _$_rv=${compileToken(r, 1)};return _$_rv?_$_rv:(${\r\n            compileToken([stripQuote(state, r[2])], 0)}});})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__cond', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        //  -> (if (eval condI) is true ) S expr  : exprI\r\n        //  -> (if no matched)            S expr  : null\r\n        let compFnBody = '';\r\n        {\r\n            checkParamsLength('compileToken:$__cond', args, 1);\r\n            compFnBody += `(`;\r\n            for (let p = 0; p < args.length; p += 2) {\r\n                compFnBody += `${compileToken([stripQuote(state, args[p])], 0)}?(${\r\n                    compileToken([stripQuote(state, args[p + 1])], 0)}):(`;\r\n            }\r\n            compFnBody += `null`;\r\n            for (let p = 0; p < args.length; p += 2) {\r\n                compFnBody += `)`;\r\n            }\r\n            compFnBody += `)`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__while', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__while', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;while(${\r\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n            }}return _$_rv})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__do-while', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__do-until', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(${\r\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__until', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__until', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;while(!${\r\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n            }}return _$_rv})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__do-until', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__do-until', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(!${\r\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__repeat', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n        //  -> (if n > 0) S expr  : exprN\r\n        //  -> (else)     S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__repeat', args, 2);\r\n        if (! isSymbol(args[0])) {\r\n            throw new Error(`[SX] compileToken: $__repeat : args[0] is not symbol.`);\r\n        }\r\n        makeScope(() => {\r\n            const name = 'v' + ctx.varNamesCount++;\r\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\r\n            compFnBody += `(((_$_n)=>{let _$_rv=null;for(let ${name}=0;${name}<_$_n;${name}++){_$_rv=${\r\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n                }}return _$_rv})(${compileToken(args, 1)}))`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__for', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n        //  -> (if list.length > 0) S expr  : exprN\r\n        //  -> (else)               S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__for', args, 2);\r\n        if (! isSymbol(args[0])) {\r\n            throw new Error(`[SX] compileToken: $__for : args[0] is not symbol.`);\r\n        }\r\n        makeScope(() => {\r\n            const name = 'v' + ctx.varNamesCount++;\r\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\r\n            compFnBody += `(((_$_l)=>{let _$_rv=null;for(const ${name} of _$_l){_$_rv=${\r\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n                }}return _$_rv})(${compileToken(args, 1)}))`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__scope', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n        //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n        //  -> (else)               S expr  : exprN\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__scope', args, 2);\r\n        // r[1]: isBlockLocal\r\n        // r[2]: returnMultiple\r\n        if (! Array.isArray(r[3])) {\r\n            throw new Error(`[SX] compileToken: $__scope : args[2] is not array.`);\r\n        }\r\n        makeScope(() => {\r\n            for (const x of stripQuote(state, r[3]) as any[]) {\r\n                let name = '';\r\n                if (Array.isArray(x)) {\r\n                    if (x.length < 1) {\r\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is too short.`);\r\n                    }\r\n                    if (! isSymbol(x[0])) {\r\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?][0] is not symbol.`);\r\n                    }\r\n                    name = x[0].symbol;\r\n                    compFnBody += `(${'v' + ctx.varNamesCount}=${compileToken(x, 1)})`;\r\n                } else {\r\n                    if (! isSymbol(x)) {\r\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is not symbol.`);\r\n                    }\r\n                    name = x.symbol;\r\n                }\r\n                ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\r\n                ctx.varNames.set(name, 'v' + ctx.varNamesCount++);\r\n            }\r\n            const s = `${r.slice(4).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}`;\r\n            compFnBody += r[2] ? `[${s}]` : `(${s})`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__try', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__try 'expr 'catch-expr)\r\n        //  ->                               S expr  : expr\r\n        //  -> (if error is raised in expr)  S expr  : catch-expr\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__try', args, 1, 2);\r\n        compFnBody += `((()=>{try{${\r\n            compileToken([stripQuote(state, r[1])], 0)}}catch(e${\r\n            ctx.varNamesCount}){let e${ctx.varNamesCount + 1}=(_$_vars[${String(ctx.varsCount)}])();`;\r\n        _$_vars[ctx.varsCount++] = getScope_stateApplied(state);\r\n        makeScope(() => {\r\n            ctx.varNames.set('$error', 'e' + ctx.varNamesCount++);\r\n            ctx.varNames.set('$parent', 'e' + ctx.varNamesCount++);\r\n            compFnBody += `${\r\n                compileToken([stripQuote(state, r[2])], 0)}}})())`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set(state.config.reservedNames.raise, function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($raise 'expr)\r\n        //  -> S expr  : -\r\n        let compFnBody = '';\r\n        compFnBody += `((()=>{throw ${\r\n            compileToken([stripQuoteOrPass(state, r[1])], 0)}})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$boolean', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($boolean any)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$boolean', args, 1, 1);\r\n        compFnBody += `((x0=${compileToken(args, 0)\r\n            }),(Array.isArray(x0)&&x0.length===0?false:boolean(x0)))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__get', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        //  -> S expr  : any\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__get', args, 1);\r\n        const quoted = stripQuote(state, r[1]);\r\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\r\n        if (typeof name !== 'string') {\r\n            throw new Error(`[SX] compileToken: $__get : operand is not symbol: ${JSON.stringify(r[1])}.`);\r\n        }\r\n        let vName = '';\r\n        if (ctx.varNames.has(name)) {\r\n            vName = ctx.varNames.get(name) as string;\r\n        } else {\r\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\r\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\r\n        }\r\n        const regToVars = (symName: string) => {\r\n            _$_vars[ctx.varsCount] = symName;\r\n            return `_$_vars[${String(ctx.varsCount++)}]`;\r\n        };\r\n        compFnBody += `((${vName})${r.slice(2).map((x, idx, arr) => `[${\r\n            isSymbol(arr[idx]) ?\r\n                regToVars((arr as any)[idx].symbol) :\r\n                compileToken(arr, idx)}]`).join('')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__let', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__let 'nameStrOrSymbol expr)\r\n        //  -> S expr  : any\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__let', args, 2, 2);\r\n        const quoted = stripQuote(state, r[1]);\r\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\r\n        if (typeof name !== 'string') {\r\n            throw new Error(`[SX] compileToken: $__let : operand is not rvalue: ${JSON.stringify(r[1])}.`);\r\n        }\r\n        if (! ctx.varNames.has(name)) {\r\n            ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\r\n            ctx.varNames.set(name, 'v' + ctx.varNamesCount++);\r\n        }\r\n        compFnBody += `(${ctx.varNames.get(name)}=${compileToken(r, 2)})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__set', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : any\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__set', args, 2);\r\n        const quoted = stripQuote(state, r[1]);\r\n        const name = isSymbol(quoted) ?\r\n            quoted.symbol :\r\n            (typeof quoted === 'string' ?\r\n                quoted :\r\n                (Array.isArray(quoted) ?\r\n                    (isSymbol(quoted[0]) ?\r\n                        quoted[0].symbol :\r\n                        (typeof quoted[0] === 'string' ? quoted[0] : null)\r\n                    ) :\r\n                    null\r\n                )\r\n            );\r\n        if (typeof name !== 'string') {\r\n            throw new Error(`[SX] compileToken: $__set : operand is not rvalue: ${JSON.stringify(r[1])}.`);\r\n        }\r\n        let vName = '';\r\n        if (ctx.varNames.has(name)) {\r\n            vName = ctx.varNames.get(name) as string;\r\n        } else {\r\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\r\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\r\n        }\r\n        const regToVars = (symName: string) => {\r\n            _$_vars[ctx.varsCount] = checkUnsafeVarNames('compileToken:$__set', symName);\r\n            return `_$_vars[${String(ctx.varsCount++)}]`;\r\n        };\r\n        let checkNameCalled = false;\r\n        let checkNamePos = '';\r\n        const checkName = (str: string) => {\r\n            if (! checkNameCalled) {\r\n                _$_vars[ctx.varsCount] = checkUnsafeVarNames_dynamic('compileToken:$__set');\r\n                checkNamePos = String(ctx.varsCount++);\r\n                checkNameCalled = true;\r\n            }\r\n            return `(_$_vars[${checkNamePos}](${str}))`;\r\n        };\r\n        compFnBody += `((${vName})${(Array.isArray(quoted) ? quoted.slice(1) : []).map((x, idx, arr) => `[${\r\n            isSymbol(arr[idx]) ?\r\n                regToVars((arr as any)[idx].symbol) :\r\n                checkName(compileToken(arr, idx))}]`).join('')}=${compileToken(r, 2)})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set(state.config.reservedNames.not, function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($not any)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$not', args, 1, 1);\r\n        compFnBody += `(!${compileToken(args, 0)})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__and', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__and 'expr1 ... 'exprN)\r\n        //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n        //  -> (else)                                                     S expr  : expr-i (false left most)\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__and', args, 1);\r\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('&&')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__or', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__or 'expr1 ... 'exprN)\r\n        //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n        //  -> (else)                                                  S expr  : expr-i (false right most)\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__or', args, 1);\r\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('||')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('===', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($eq arg1 arg2)\r\n        //  -> (if arg1 === arg2)  S expr  : true\r\n        //  -> (else)              S expr  : false\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:===', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('===')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('!==', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($not-eq arg1 arg2)\r\n        //  -> (if arg1 !== arg2)  S expr  : true\r\n        //  -> (else)              S expr  : false\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:!==', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!==')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('==', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (== a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:==', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('==')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('!=', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (!= a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:!=', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!=')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('<', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (< a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('<=', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (<= a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<=', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<=')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (> a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:>', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>=', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (>= a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<=', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>=')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$concat', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($concat listOrString1 ... listOrStringN)\r\n        //  -> S expr  : listOrString\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$concat', args, 1);\r\n        let w1 = '';\r\n        if (Array.isArray(args[0]) && isSymbol((args[0] as any)[0], state.config.reservedNames.spread)) {\r\n            const w0 = compileToken(args[0] as any, 1);\r\n            w1 = `(${w0}[0]).concat((${w0}.length>1?${w0}[1]:(typeof ${w0}[0]==='string'?'':[])),`;\r\n        } else {\r\n            w1 = `${compileToken(args as any, 0)}.concat(`;\r\n        }\r\n        compFnBody += `(${w1}${\r\n            args.slice(1).map((x, idx, arr) => compileToken(arr, idx)).join(',')}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('+', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (+ number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:+', args, 1);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n            };return _$_rv.reduce((x,y)=>x+y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('+')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('-', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (- number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:-', args, 1);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return (_$_rv.length>1?(_$_rv.reduce((x,y)=>x-y)):(_$_rv.length>0?-_$_rv[0]:NaN));})())`;\r\n        } else {\r\n            compFnBody += `(${r.length > 2 ?\r\n                args.map((x, idx, arr) => compileToken(arr, idx)).join('-') :\r\n                `-(${String(compileToken(r, 1))})`})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('*', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (* number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:*', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x*y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('*')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('**', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (** number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:**', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x**y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('**')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('/', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (/ number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:/', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x/y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('/')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('%', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (% number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:%', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x%y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('%')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('<<', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (<< number shift)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<<', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<<')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>>', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (>> number shift)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:>>', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>>>', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (>>> number shift)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:>>>', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>>')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-not', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-not number)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-not', args, 1, 1);\r\n        compFnBody += `(~(${compileToken(r, 1)}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-and', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-and numberA numberB)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-and', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('&')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-or', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-or numberA numberB)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-or', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('|')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-xor', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-xor numberA numberB)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-xor', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('^')})`;\r\n        return compFnBody;\r\n    });\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport interface ParserInputWithCtx<T extends ArrayLike<T[number]>, C> {\r\n    src: T;\r\n    start: number;\r\n    end: number;\r\n    context: C;\r\n    templateArgs?: any[];       // For \"template strings\". NOTE: For backword compatibility, this is optional.\r\n    templateArgsPos?: number[]; // For \"template strings\". NOTE: For backword compatibility, this is optional.\r\n}\r\nexport type ParserInput<T extends ArrayLike<T[number]>> = ParserInputWithCtx<T, undefined>;\r\nexport type StringParserInputWithCtx<C> = ParserInputWithCtx<string, C>;\r\nexport type StringParserInput = StringParserInputWithCtx<undefined>;\r\n\r\nexport class ParseError<T extends ArrayLike<T[number]>, C, R> extends Error {\r\n    public result: ParserFnFailedResult<T, C, R>;\r\n    constructor(result: ParserFnFailedResult<T, C, R>) {\r\n        super(result.message);\r\n        this.result = result;\r\n    }\r\n}\r\n\r\n\r\nexport function parserInput<T extends ArrayLike<T[number]>>(src: T): ParserInputWithCtx<T, undefined>;\r\nexport function parserInput<T extends ArrayLike<T[number]>, C>(src: T, context: C): ParserInputWithCtx<T, C>;\r\nexport function parserInput<T extends ArrayLike<T[number]>, C>(src: T, context?: C): ParserInputWithCtx<T, C> {\r\n    return ({\r\n        src,\r\n        start: 0,\r\n        end: src.length,\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        context: context as any,\r\n        templateArgs: [],\r\n        templateArgsPos: [],\r\n    });\r\n}\r\n\r\n\r\nexport function templateStringsParserInput<C>(strings: TemplateStringsArray, values: any[], context?: C): ParserInputWithCtx<string, C> {\r\n    const templateArgsPos: number[] = [];\r\n    let pos = 0;\r\n    if (values.length) {\r\n        for (let i = 0; i < strings.length; i++) {\r\n            const x = strings[i];\r\n            if (i < values.length) {\r\n                templateArgsPos.push(pos + x.length);\r\n                pos += x.length + 1;\r\n            }\r\n        }\r\n    }\r\n    const joined = strings.join('\\x00');\r\n    return ({\r\n        src: joined,\r\n        start: 0,\r\n        end: joined.length,\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        context: context as any,\r\n        templateArgs: values,\r\n        templateArgsPos,\r\n    });\r\n}\r\n\r\n\r\n// tslint:disable-next-line: interface-over-type-literal\r\nexport type ParserFnSucceededResult<T extends ArrayLike<T[number]>, C, R> =\r\n    {succeeded: true, next: ParserInputWithCtx<T, C>, tokens: R[]};\r\n\r\n// tslint:disable-next-line: interface-over-type-literal\r\nexport type ParserFnFailedResult<T extends ArrayLike<T[number]>, C, R> =\r\n    {succeeded: false, error: boolean, src: T, pos: number, message: string};\r\n\r\nexport type ParserFnWithCtx<T extends ArrayLike<T[number]>, C, R> =\r\n    (input: ParserInputWithCtx<T, C>) =>\r\n        ParserFnSucceededResult<T, C, R> |\r\n        ParserFnFailedResult<T, C, R>;\r\n\r\nexport type ParserFn<T extends ArrayLike<T[number]>, R> = ParserFnWithCtx<T, undefined, R>;\r\nexport type StringParserFnWithCtx<C, R> = ParserFnWithCtx<string, C, R>;\r\nexport type StringParserFn<R> = StringParserFnWithCtx<undefined, R>;\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { ParserInputWithCtx,\r\n         ParseError,\r\n         parserInput,\r\n         ParserFnFailedResult,\r\n         ParserFnWithCtx } from './types';\r\n\r\n\r\n\r\nfunction getLineAndCol(src: string, pos: number) {\r\n    let line = 1;\r\n    let col = 1;\r\n\r\n    for (let i = 0; i <= pos; i++) {\r\n        switch (src[i]) {\r\n        case '\\r':\r\n            if (src[i + 1] === '\\n') {\r\n                i++;\r\n            }\r\n            // Fall Throught\r\n        case '\\n':\r\n            line++;\r\n            col = 1;\r\n            break;\r\n        default:\r\n            col++;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return ({\r\n        line,\r\n        col,\r\n    });\r\n}\r\n\r\n\r\nexport function formatErrorMessage<T extends ArrayLike<T[number]>, C, R>(\r\n    result: ParserFnFailedResult<T, C, R>): string {\r\n\r\n    let msg = '';\r\n    let src = '';\r\n    if (typeof result.src === 'string') {\r\n        src = (result.src as string).slice(Math.max(result.pos - 5, 0), result.pos + 55); // NOTE: (TS>=4.0) TS2339: Property 'slice' does not exist on type 'never'.\r\n\r\n        let ar = src.split(/\\r\\n|\\n|\\r/);\r\n        ar = ar.slice(0, 1)\r\n            .concat('          ^~~~~~~~')\r\n            .concat(...ar.slice(1));\r\n        src = ar.join('\\n') + '\\n\\n';\r\n\r\n        const lineAndCol = getLineAndCol(result.src, result.pos);\r\n        msg =  (`parse failed at position:${\r\n            result.pos} line:${lineAndCol.line} col:${lineAndCol.col} ${\r\n            result.message ? ` ${result.message}` : ''}\\n     ${src}`);\r\n    } else {\r\n        src = '     (object)\\n          ^~~~~~~~';\r\n        try {\r\n            src = '     ' +\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\r\n                JSON.stringify((result.src as any).slice(Math.max(result.pos - 10, 0), result.pos)) + '\\n          ' +\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\r\n                JSON.stringify((result.src as any).slice(result.pos, result.pos + 1)) + '\\n          ' +\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\r\n                JSON.stringify((result.src as any).slice(result.pos + 1, result.pos + 10));\r\n\r\n            let ar = src.split(/\\r\\n|\\n|\\r/);\r\n            ar = ar.slice(0, 2)\r\n                .concat('          ^~~~~~~~')\r\n                .concat(...ar.slice(2));\r\n            src = ar.join('\\n') + '\\n\\n';\r\n        } catch (e) {\r\n            // Nothing to do.\r\n        }\r\n\r\n        msg = (`parse failed at position:${\r\n            result.pos} ${\r\n            result.message ? ` ${result.message}` : ''}\\n     ${src}`);\r\n    }\r\n    return msg;\r\n}\r\n\r\n\r\nexport function zeroWidth<T extends ArrayLike<T[number]>, C, R>(\r\n        helper?: () => R\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        return ({\r\n            succeeded: true,\r\n            next: {\r\n                src: input.src,\r\n                start: input.start,\r\n                end: input.end,\r\n                context: input.context,\r\n                templateArgs: input.templateArgs,\r\n                templateArgsPos: input.templateArgsPos,\r\n            },\r\n            tokens: helper ? [helper()] : [],\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function zeroWidthError<T extends ArrayLike<T[number]>, C, R>(\r\n        message: string\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        throw new ParseError({\r\n            succeeded: false,\r\n            error: true,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: message || '',\r\n        });\r\n        // return ({\r\n        //     succeeded: false,\r\n        //     error: true,\r\n        //     src: input.src,\r\n        //     pos: input.start,\r\n        //     message: message || '',\r\n        // });\r\n    });\r\n}\r\n\r\n\r\nexport function beginning<T extends ArrayLike<T[number]>, C, R>(\r\n        helper?: () => R\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        return (input.start === 0 ? {\r\n            succeeded: true,\r\n            next: {\r\n                src: input.src,\r\n                start: input.start,\r\n                end: input.end,\r\n                context: input.context,\r\n                templateArgs: input.templateArgs,\r\n                templateArgsPos: input.templateArgsPos,\r\n            },\r\n            tokens: helper ? [helper()] : [],\r\n        } : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: 'operator \"beginning\"',\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function end<T extends ArrayLike<T[number]>, C, R>(\r\n        helper?: () => R\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        return (input.start === input.end ? {\r\n            succeeded: true,\r\n            next: {\r\n                src: input.src,\r\n                start: input.start,\r\n                end: input.end,\r\n                context: input.context,\r\n                templateArgs: input.templateArgs,\r\n                templateArgsPos: input.templateArgsPos,\r\n            },\r\n            tokens: helper ? [helper()] : [],\r\n        } : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: 'operator \"end\"',\r\n        });\r\n    });\r\n}\r\n\r\n// TODO: match by callback function parser\r\n// TODO: `nesting` parser\r\n\r\n\r\nexport function quantify<T extends ArrayLike<T[number]>, C, R>(\r\n        min?: number, max?: number\r\n        ): (parser: ParserFnWithCtx<T, C, R>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    min = min || 0;\r\n    return (parser => {\r\n        return (input => {\r\n            let next = input;\r\n            const matched: Array<{next: ParserInputWithCtx<T, C>, tokens: R[]}> = [];\r\n\r\n            for (;;) {\r\n                const x = parser(next);\r\n                if (x.succeeded) {\r\n                    next = x.next;\r\n                    matched.push({next: x.next, tokens: x.tokens});\r\n                    if (max && max === matched.length) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (x.error) {\r\n                        return x;\r\n                    }\r\n                    if (matched.length >= (min as number)) {\r\n                        break;\r\n                    } else {\r\n                        return ({\r\n                            succeeded: false,\r\n                            error: false,\r\n                            src: next.src,\r\n                            pos: next.start,\r\n                            message: 'operator \"quantify\"',\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (matched.length > 0) {\r\n                const r: R[] = [];\r\n                for (const x of matched) {\r\n                    r.push(...x.tokens);\r\n                }\r\n                return ({\r\n                    succeeded: true,\r\n                    next: (matched[matched.length - 1]).next,\r\n                    tokens: r,\r\n                });\r\n            } else {\r\n                return ({\r\n                    succeeded: true,\r\n                    next: {\r\n                        src: input.src,\r\n                        start: input.start,\r\n                        end: input.end,\r\n                        context: input.context,\r\n                        templateArgs: input.templateArgs,\r\n                        templateArgsPos: input.templateArgsPos,\r\n                    },\r\n                    tokens: [],\r\n                });\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function first<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        let matched: {next: ParserInputWithCtx<T, C>, tokens: R[]} | null = null;\r\n\r\n        let last: ParserFnFailedResult<T, C, R> | null = null;\r\n        for (const parser of parsers) {\r\n            const x = parser(input);\r\n            if (x.succeeded) {\r\n                matched = {next: x.next, tokens: x.tokens};\r\n                break;\r\n            }\r\n            if (last) {\r\n                if (x.error) {\r\n                    if (!last.error || last.pos < x.pos) {\r\n                        last = x;\r\n                    }\r\n                } else if (last.pos < x.pos) {\r\n                    last = x;\r\n                }\r\n            } else {\r\n                last = x;\r\n            }\r\n        }\r\n\r\n        return (matched ? {\r\n            succeeded: true, next: matched.next, tokens: matched.tokens\r\n        } : last ? last : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: 'operator \"first\"',\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function or<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        const matched: Array<{next: ParserInputWithCtx<T, C>, tokens: R[]}> = [];\r\n\r\n        let last: ParserFnFailedResult<T, C, R> | null = null;\r\n        for (const parser of parsers) {\r\n            const x = parser(input);\r\n            if (x.succeeded) {\r\n                matched.push({next: x.next, tokens: x.tokens});\r\n            } else {\r\n                if (last) {\r\n                    if (x.error) {\r\n                        if (!last.error || last.pos < x.pos) {\r\n                            last = x;\r\n                        }\r\n                    } else if (last.pos < x.pos) {\r\n                        last = x;\r\n                    }\r\n                } else {\r\n                    last = x;\r\n                }\r\n            }\r\n        }\r\n        if (matched.length > 0) {\r\n            const z = matched.reduce((a, b) => a.next.start >= b.next.start ? a : b);\r\n            return ({succeeded: true, next: z.next, tokens: z.tokens});\r\n        }\r\n\r\n        return (last ? last : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: 'operator \"or\"',\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function transform<T extends ArrayLike<T[number]>, C, R>(\r\n        trans?: ((tokens: R[], input: ParserInputWithCtx<T, C>) => R[]), ctxTrans?: ((context: C) => C)\r\n        ): (...parsers: Array<ParserFnWithCtx<T, C, R>>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return ((...parsers) => {\r\n        return (input => {\r\n            let next = input;\r\n            const tokens: R[] = [];\r\n\r\n            for (const parser of parsers) {\r\n                const x = parser(next);\r\n                if (! x.succeeded) {\r\n                    return x;\r\n                }\r\n                next = x.next;\r\n                tokens.push(...x.tokens);\r\n            }\r\n\r\n            // TODO: report errors while transforming\r\n            const t2 = trans ? trans(tokens, input) : tokens;\r\n            return ({\r\n                succeeded: true,\r\n                next: ctxTrans ? {\r\n                    src: next.src,\r\n                    start: next.start,\r\n                    end: next.end,\r\n                    context: ctxTrans(next.context),\r\n                    templateArgs: next.templateArgs,\r\n                    templateArgsPos: next.templateArgsPos,\r\n                } : next,\r\n                tokens: t2,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function combine<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return transform<T, C, R>()(...parsers);\r\n}\r\n\r\n\r\nexport function lookAhead<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        let next = input;\r\n\r\n        for (const parser of parsers) {\r\n            const x = parser(next);\r\n            if (! x.succeeded) {\r\n                return x;\r\n            }\r\n            next = x.next;\r\n        }\r\n\r\n        return ({\r\n            succeeded: true,\r\n            next: input,\r\n            tokens: [],\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function lookBehind<T extends ArrayLike<T[number]>, C, R>(\r\n        n: number, helper?: () => R): (\r\n            ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n            ) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return ((...parsers) => {\r\n        return (input => {\r\n            if (input.start - n < 0) {\r\n                return ({\r\n                    succeeded: false,\r\n                    error: false,\r\n                    src: input.src,\r\n                    pos: input.start,\r\n                    message: 'lookBehind: src is too short',\r\n                });\r\n            }\r\n            let next: ParserInputWithCtx<T, C> = {\r\n                src: input.src,\r\n                start: input.start - n,\r\n                end: input.end,\r\n                context: input.context,\r\n                templateArgs: input.templateArgs,\r\n                templateArgsPos: input.templateArgsPos,\r\n            };\r\n\r\n            for (const parser of parsers) {\r\n                const x = parser(next);\r\n                if (! x.succeeded) {\r\n                    return x;\r\n                }\r\n                next = x.next;\r\n            }\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: input,\r\n                tokens: helper ? [helper()] : [],\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\n// tslint:disable-next-line: interface-over-type-literal\r\nexport type ApplyProductionRulesArg<T extends ArrayLike<T[number]>, C, R> = {\r\n    rules: Array<ParserFnWithCtx<R[], C, R> |\r\n           {parser: ParserFnWithCtx<R[], C, R>, rtol: boolean}>,\r\n    maxApply?: number,\r\n    check: ParserFnWithCtx<R[], C, R>,\r\n};\r\n\r\nexport function applyProductionRules<T extends ArrayLike<T[number]>, C, R>(\r\n        args: ApplyProductionRulesArg<T, C, R>\r\n        ): (lexer: ParserFnWithCtx<T, C, R>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return (lexer => {\r\n        return (lexerInput => {\r\n            const lexResult = lexer(lexerInput);\r\n            if (! lexResult.succeeded) {\r\n                return lexResult;\r\n            }\r\n\r\n            const input = parserInput<R[], C>(lexResult.tokens, lexerInput.context);\r\n            let next = input;\r\n            let completed = false;\r\n\r\n            if (args.check(next).succeeded) {\r\n                return ({\r\n                    succeeded: true,\r\n                    next: lexResult.next,\r\n                    tokens: lexResult.tokens,\r\n                });\r\n            }\r\n\r\n            completed: for (let i = 0;\r\n                    args.maxApply !== void 0 ? i < args.maxApply : true; i++) {\r\n                let matched = false;\r\n\r\n                rules: for (const rule of args.rules) {\r\n                    const {parser, rtol} =\r\n                        typeof rule === 'function' ?\r\n                            {parser: rule, rtol: false} : rule;\r\n                    const len = next.src.length;\r\n\r\n                    for (let s = 0; s <= len; s++) {\r\n                        const x = parser({\r\n                            src: next.src,\r\n                            start: rtol ? len - s : s,\r\n                            end: next.src.length,\r\n                            context: next.context,\r\n                            templateArgs: next.templateArgs,\r\n                            templateArgsPos: next.templateArgsPos,\r\n                        });\r\n                        if (x.succeeded) {\r\n                            matched = true;\r\n                            const nextSrc = next.src.slice(0, rtol ? len - s : s);\r\n                            nextSrc.push(...x.tokens);\r\n                            nextSrc.push(...next.src.slice(x.next.start));\r\n                            next = {\r\n                                src: nextSrc,\r\n                                start: 0,\r\n                                end: nextSrc.length,\r\n                                context: x.next.context,\r\n                                templateArgs: x.next.templateArgs,\r\n                                templateArgsPos: x.next.templateArgsPos,\r\n                            };\r\n                            if (args.check(next).succeeded) {\r\n                                completed = true;\r\n                                break completed;\r\n                            }\r\n                            break rules;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (! matched) {\r\n                    break;\r\n                }\r\n            }\r\n            if (! completed) {\r\n                if (! args.check(next).succeeded) {\r\n                    throw new ParseError({\r\n                        succeeded: false,\r\n                        error: true,\r\n                        src: input.src,\r\n                        pos: input.start,\r\n                        message: 'The application of production rules was not finished',\r\n                    });\r\n                }\r\n            }\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: lexResult.next,\r\n                tokens: next.src,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function makeProgram<T extends ArrayLike<T[number]>, C, R>(\r\n    parser: ParserFnWithCtx<T, C, R>): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        try {\r\n            return parser(input);\r\n        } catch (e) {\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n            if (e.result) {\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\r\n                return e.result;\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    });\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         FatalError,\r\n         CapturedScopes,\r\n         SxMacroInfo }           from '../../types';\r\nimport { globalObj }             from '../../global-this';\r\nimport { isSymbol,\r\n         quote }                 from '../../ast';\r\nimport { evaluate,\r\n         resolveValueSymbolScope,\r\n         collectCapturedVariables,\r\n         getCapturedScopes,\r\n         getScope,\r\n         getGlobalScope,\r\n         installScope,\r\n         uninstallScope,\r\n         optimizeTailCall,\r\n         toNumber }              from '../../evaluate';\r\nimport { compileLambda }         from '../../compile';\r\nimport { checkParamsLength,\r\n         checkUnsafeVarNamesEx } from '../../errors';\r\n\r\n\r\n\r\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car '(first second ... last))\r\n    //  -> S expr  : first\r\n    checkParamsLength('$car', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car[0];\r\n};\r\nexport const $$car = $car(null as any, null as any);\r\n\r\n\r\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cdr '(first second ... last))\r\n    //  -> S expr  : (second ... last)\r\n    checkParamsLength('$cdr', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car.slice(1);\r\n};\r\nexport const $$cdr = $cdr(null as any, null as any);\r\n\r\n\r\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\r\n    //  -> S expr  : (arg1 arg2-item1 ...)\r\n    // S expression: ($cons arg1 nilOrNull ... argN)\r\n    //  -> S expr  : (arg1)\r\n    // S expression: ($cons arg1 arg2 ... argN)\r\n    //  -> S expr  : arg1.arg2\r\n    checkParamsLength('$cons', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (car === null) {\r\n        car = [];\r\n    }\r\n    if (cdr === null) {\r\n        cdr = [];\r\n    }\r\n\r\n    if (Array.isArray(cdr)) {\r\n        cdr = cdr.slice(0);\r\n        cdr.unshift(car);\r\n        return cdr;\r\n    } else {\r\n        return {car, cdr};\r\n    }\r\n};\r\nexport const $$cons = $cons(null as any, null as any);\r\n\r\n\r\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first first second ... last)\r\n    //  -> S expr  : first\r\n    // S expression: ($first)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(0, 1);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$first = $first(null as any, null as any);\r\n\r\n\r\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($second first second ... last)\r\n    //  -> S expr  : second\r\n    // S expression: ($second first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1, 2);\r\n    return (cdr.length === 1) ? cdr[0] : null;\r\n};\r\nexport const $$second = $second(null as any, null as any);\r\n\r\n\r\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($last first second ... last)\r\n    //  -> S expr  : last\r\n    // S expression: ($last)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(args.length - 1, args.length);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$last = $last(null as any, null as any);\r\n\r\n\r\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($rest first second ... last)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($rest first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1);\r\n    return (0 < cdr.length) ? cdr : null;\r\n};\r\nexport const $$rest = $rest(null as any, null as any);\r\n\r\n\r\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first-and-second first second ... last)\r\n    //  -> S expr  : first.second\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    return {car, cdr};\r\n};\r\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\r\n\r\n\r\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($atom arg1 ...)\r\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\r\n    //  -> (if arg1 is nil or anything else) S expr  : true\r\n    checkParamsLength('$atom', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n\r\n    if (car === null || car === void 0) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(car)) {\r\n        if (car.length === 0) return  true;\r\n        else                  return false;\r\n    }\r\n\r\n    switch (typeof car) {\r\n    case 'number': case 'string': case 'function': case 'boolean':\r\n        return true;\r\n    case 'object':\r\n        return isSymbol(car) ? true : false;\r\n    }\r\n    return false;\r\n};\r\nexport const $$atom = $atom(null as any, null as any);\r\n\r\n\r\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($eq arg1 arg2)\r\n    //  -> (if arg1 === arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$eq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car === cdr;\r\n};\r\nexport const $$eq = $eq(null as any, null as any);\r\n\r\n\r\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not-eq arg1 arg2)\r\n    //  -> (if arg1 !== arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$notEq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car !== cdr;\r\n};\r\nexport const $$notEq = $notEq(null as any, null as any);\r\n\r\n\r\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    // S expression: ($list arg1 ... argN)\r\n    //  -> S expr  : (arg1 ... argN)\r\n    args.slice(0);\r\nexport const $$list = $list(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__scope = (state: SxParserState, name: string, capturedScopes?: CapturedScopes) => (...args: any[]) => {\r\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__scope', args, 3);\r\n\r\n    const isBlockLocal = $$first(...args);\r\n    const returnMultiple = $$second(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n\r\n    const scope: any = {};\r\n    if (Array.isArray(car)) {\r\n        for (const x of car) {\r\n            if (Array.isArray(x)) {\r\n                const kv = $$firstAndSecond(...x);\r\n                const kvSym = isSymbol(kv.car);\r\n                const kvName = kvSym ? kvSym.symbol : String(kv.car);\r\n                checkUnsafeVarNamesEx('$__scope', scope, kvName);\r\n                scope[kvName] = evaluate(state, kv.cdr);\r\n            } else {\r\n                const xSym = isSymbol(x);\r\n                const xName = xSym ? xSym.symbol : String(x);\r\n                checkUnsafeVarNamesEx('$__scope', scope, xName);\r\n                scope[xName] = null;\r\n            }\r\n        }\r\n    }\r\n    installScope(state, scope, isBlockLocal, capturedScopes);\r\n\r\n    try {\r\n        if (4 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(3)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(3)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__globalScope', args, 1);\r\n\r\n    const returnMultiple = $$first(...args);\r\n    const cdr = $$second(...args);\r\n    let r: SxToken = null;\r\n\r\n    installScope(state, getGlobalScope(state).scope, true);\r\n    try {\r\n        if (2 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(1)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(1)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__capture = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__capture '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : exprN\r\n    checkParamsLength('$__capture', args, 1);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let r: SxToken = null;\r\n\r\n    const capturedScopes = collectCapturedVariables(state, formalArgs);\r\n    installScope(state, {}, true, capturedScopes);\r\n    try {\r\n        for (const x of args.slice(1)) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    let fnBody = args.slice(1);\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const capturedScopes = getCapturedScopes(state);\r\n\r\n    const fn = function(this: any, ...actualArgs: any[]) {\r\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n            throw new Error(`[SX] func call: Actual args too short: actual ${\r\n                actualArgs.length} / formal ${formalArgs.length}.`);\r\n        }\r\n        // TODO: add type checking\r\n        return $__scope(state, name, capturedScopes)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            [state.config.reservedNames.thiz, this === globalObj || this === void 0 ? null : quote(state, this)],\r\n            ...(formalArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === formalArgs.length - 1) ?\r\n                        actualArgs.slice(index) : actualArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $comp$__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $$__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    const fnBody = args.slice(1);\r\n    return compileLambda(state, formalArgs, lastIsSpread, fnBody);\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $__lambda(state, name)(...args.slice(1));\r\n\r\n    checkUnsafeVarNamesEx('$__defun', state.funcMap, car.symbol);\r\n    // TODO: overloading\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn,\r\n        // formalArgs: ,\r\n        // lastIsSpread: ,\r\n        // next: ,\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $comp$__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $comp$__lambda(state, name)(...args.slice(1));\r\n\r\n    checkUnsafeVarNamesEx('$$__defun', state.funcMap, car.symbol);\r\n    // TODO: overloading\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn,\r\n        // formalArgs: ,\r\n        // lastIsSpread: ,\r\n        // next: ,\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__refun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($refun 'name)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__refun', args, 1, 1);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n\r\n    checkUnsafeVarNamesEx('$__refun', state.funcMap, car.symbol);\r\n    const info = state.funcMap.get(car.symbol);\r\n    if (!info) {\r\n        throw new Error(`[SX] $__refun: function ${car.symbol} is not defined.`);\r\n    }\r\n    return info.fn(state, car.symbol);\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defmacro = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defmacro', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const formalArgs: SxSymbol[] = args[1];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__defmacro: Invalid argument(s): args[1] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    const fnBody = args.slice(2);\r\n    const capturedScopes = getCapturedScopes(state);\r\n\r\n    const fn = (fArgs: SxSymbol[]) => (...aArgs: any[]) => {\r\n        return $__scope(state, name, capturedScopes)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(fArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === fArgs.length - 1) ?\r\n                        aArgs.slice(index) : aArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n\r\n    const m: SxMacroInfo = {\r\n        name: car.symbol,\r\n        fn: (st: SxParserState, nm: string, fArgs: SxSymbol[]) => (list: SxToken[]) => fn(fArgs)(...(list.slice(1))),\r\n        formalArgs,\r\n        lastIsSpread,\r\n    };\r\n\r\n    checkUnsafeVarNamesEx('$__defmacro', state.macroMap, car.symbol);\r\n\r\n    if (state.macroMap.has(car.symbol)) {\r\n        let curr = state.macroMap.get(car.symbol);\r\n        (curr as SxMacroInfo).next = m;\r\n        if (curr && curr.formalArgs) {\r\n            if (curr.formalArgs.length < formalArgs.length) {\r\n                state.macroMap.set(car.symbol, m);\r\n                m.next = curr;\r\n            } else {\r\n                let prev = curr;\r\n                curr = curr.next;\r\n                while (curr) {\r\n                    if (curr.formalArgs) {\r\n                        if (curr.formalArgs.length < formalArgs.length) {\r\n                            prev.next = m;\r\n                            m.next = curr;\r\n                            break;\r\n                        }\r\n                    }\r\n                    prev = curr;\r\n                    curr = curr.next;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        state.macroMap.set(car.symbol, m);\r\n    }\r\n    return fn;\r\n};\r\n\r\n\r\nexport const $apply = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($apply fn arg1 ... argN)\r\n    //  -> S expr  : fn'\r\n    checkParamsLength('$apply', args, 1);\r\n\r\n    const car: () => any = $$first(...args);\r\n    if (typeof car !== 'function') {\r\n        throw new Error(`[SX] $apply: Invalid argument(s): args[0] is not function.`);\r\n    }\r\n\r\n    return (\r\n        (...p: any[]) => car.apply(null, args.slice(1).concat(p))\r\n    );\r\n};\r\nexport const $$apply = $apply(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__call = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__call thisArg 'symbol arg1 ... argN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__call', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const sym = isSymbol(cdr);\r\n    const xName = sym ? sym.symbol : evaluate(state, cdr) as any;\r\n\r\n    checkUnsafeVarNamesEx('$__call', car, xName);\r\n\r\n    return Function.prototype.apply.call(\r\n        car[xName],\r\n        car,\r\n        args.slice(2)\r\n    );\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__try 'expr 'catch-expr)\r\n    //  ->                               S expr  : expr\r\n    //  -> (if error is raised in expr)  S expr  : catch-expr\r\n    checkParamsLength('$__try', args, 1, 2);\r\n\r\n    let r: SxToken = [];\r\n    try {\r\n        r = evaluate(state, args[0]);\r\n    } catch (e) {\r\n        if (e instanceof FatalError) {\r\n            throw e;\r\n        }\r\n        if (1 < args.length) {\r\n            r = $__scope(state, name)(true, false, [\r\n                ['$error', quote(state, e)],\r\n                ['$parent', quote(state, getScope(state))],\r\n            ], args[1]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($raise 'expr)\r\n    //  -> S expr  : -\r\n    const car = $$first(...args);\r\n    throw car;\r\n};\r\nexport const $$raise = $raise(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if condition 't-expr 'f-expr)\r\n    //  -> (if condition is true ) S expr  : t-expr\r\n    //  -> (if condition is false) S expr  : f-expr\r\n    checkParamsLength('$__if', args, 2, 3);\r\n\r\n    const car = $$first(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        r = evaluate(state, args[1]);\r\n    } else {\r\n        if (2 < args.length) {\r\n            r = evaluate(state, args[2]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if-null condition 'null-expr)\r\n    //  -> (if condition is not null ) S expr  : condition\r\n    //  -> (if condition is null)      S expr  : null-expr\r\n    checkParamsLength('$__ifNull', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if (! $$ambiguousEq(car, null)) {\r\n        r = car;\r\n    } else {\r\n        r = evaluate(state, cdr);\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n    //  -> (if (eval condI) is true ) S expr  : exprI\r\n    //  -> (if no matched)            S expr  : null\r\n    checkParamsLength('$__cond', args, 1);\r\n\r\n    for (let i = 0; i < args.length - 1; i += 2) {\r\n        const c = args[i];\r\n        const x = args[i + 1];\r\n        if ($$boolean(evaluate(state, c))) {\r\n            return evaluate(state, x);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__while', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$boolean(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doWhile', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$boolean(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__until', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$not(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doUntil', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$not(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n    //  -> (if n > 0) S expr  : exprN\r\n    //  -> (else)     S expr  : null\r\n    checkParamsLength('$__repeat', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n\r\n    checkUnsafeVarNamesEx('$__repeat', {}, sym.symbol); // NOTE: pass dummy target object.\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const n = toNumber($$second(...args));\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (let i = 0; i < n; i++) {\r\n        scope[sym.symbol] = i;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n    //  -> (if list.length > 0) S expr  : exprN\r\n    //  -> (else)               S expr  : null\r\n    checkParamsLength('$__for', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n\r\n    checkUnsafeVarNamesEx('$__for', {}, sym.symbol); // NOTE: pass dummy target object.\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const list = $$second(...args);\r\n    if (! Array.isArray(list)) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\r\n    }\r\n\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (const q of list) {\r\n        scope[sym.symbol] = q;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get v fn1 ... fnN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$pipe', args, 1);\r\n\r\n    let v = args[0];\r\n    for (let i = 1; i < args.length; i++) {\r\n        v = args[i](v);\r\n    }\r\n    return v;\r\n};\r\nexport const $$pipe = $pipe(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__get', args, 1);\r\n\r\n    let v: any = null;\r\n    let sym = isSymbol(args[0]);\r\n\r\n    if (!sym) {\r\n        switch (typeof args[0]) {\r\n        case 'string': case 'number':\r\n            sym = {symbol: String(args[0])};\r\n            break;\r\n        default:\r\n            v = evaluate(state, args[0]);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (sym) {\r\n        const scope = resolveValueSymbolScope(state, sym, true);\r\n        if (! scope) {\r\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\r\n        }\r\n        v = scope[sym.symbol];\r\n    }\r\n\r\n    for (let i = 1; i < args.length; i++) {\r\n        let q: any = args[i];\r\n        let inprog = true;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                v = q(v);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = v.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                checkUnsafeVarNamesEx('$__get', v, q);\r\n                v = v[q];\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let 'nameStrOrSymbol expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__let', args, 2, 2);\r\n\r\n    let sym = isSymbol($$first(...args));\r\n\r\n    if (! sym) {\r\n        if (typeof args[0] === 'string') {\r\n            sym = {symbol: args[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    checkUnsafeVarNamesEx('$__let', {}, sym.symbol); // NOTE: pass dummy target object.\r\n\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n    scope[sym.symbol] = args[1];\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__set', args, 2, 2);\r\n\r\n    let path: any = [];\r\n\r\n    if (Array.isArray(args[0])) {\r\n        path = args[0];\r\n    } else {\r\n        path.push(args[0]);\r\n    }\r\n\r\n    let sym = isSymbol(path[0]);\r\n\r\n    if (! sym) {\r\n        if (typeof path[0] === 'string') {\r\n            checkUnsafeVarNamesEx('$__set', {}, path[0]); // NOTE: pass dummy target object.\r\n            sym = {symbol: path[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    let scope = resolveValueSymbolScope(state, sym, true);\r\n    if (scope === null) {\r\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\r\n    }\r\n\r\n    let subst = false;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        let q: any = path[i];\r\n        let inprog = true;\r\n        const last = i === path.length - 1;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                scope = q(scope);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = scope.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                checkUnsafeVarNamesEx('$__set', scope, q);\r\n                if (last) {\r\n                    scope[q] = args[1];\r\n                    subst = true;\r\n                } else {\r\n                    scope = scope[q];\r\n                }\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (! subst) {\r\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\r\n    }\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($boolean any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$boolean', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car) && car.length === 0) return false;\r\n    else return Boolean(car);\r\n};\r\nexport const $$boolean = $boolean(null as any, null as any);\r\n\r\n\r\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$not', args, 1, 1);\r\n\r\n    return ! $$boolean(...args);\r\n};\r\nexport const $$not = $not(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__and 'expr1 ... 'exprN)\r\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n    //  -> (else)                                                     S expr  : expr-i (false left most)\r\n    checkParamsLength('$__and', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if (! $$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__and = $__and(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__or 'expr1 ... 'exprN)\r\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n    //  -> (else)                                                  S expr  : expr-i (false right most)\r\n    checkParamsLength('$__or', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if ($$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__or = $__or(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (== a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ambiguousEq', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car) && car.length === 0) car = null;\r\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\r\n    if (car === void 0) car = null;\r\n    if (cdr === void 0) cdr = null;\r\n    // tslint:disable-next-line:triple-equals\r\n    return car == cdr;\r\n};\r\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (!= a b)\r\n    //  -> S expr  : boolean\r\n    return ! $$ambiguousEq(...args);\r\n};\r\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\r\n\r\n\r\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (< a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$lt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) < toNumber(cdr);\r\n};\r\nexport const $$lt = $lt(null as any, null as any);\r\n\r\n\r\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$le', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) <= toNumber(cdr);\r\n};\r\nexport const $$le = $le(null as any, null as any);\r\n\r\n\r\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (> a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$gt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) > toNumber(cdr);\r\n};\r\nexport const $$gt = $gt(null as any, null as any);\r\n\r\n\r\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ge', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) >= toNumber(cdr);\r\n};\r\nexport const $$ge = $ge(null as any, null as any);\r\n\r\n\r\nexport const $typeof = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($typeof x)\r\n    //  -> S expr  : 'null' | 'bigint' | 'boolean' | 'function' | 'number' | 'string' | 'undefined' |\r\n    //               'js-symbol' | 'list' | 'object'\r\n    checkParamsLength('$typeof', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (car === null) {\r\n        return 'null';\r\n    }\r\n    const tyName = typeof car;\r\n    switch (tyName) {\r\n    case 'object':\r\n        if (Array.isArray(car)) {\r\n            return 'list';\r\n        } else {\r\n            return 'object';\r\n        }\r\n    case 'symbol':\r\n        return 'js-symbol';\r\n    default:\r\n        return tyName;\r\n    }\r\n};\r\nexport const $$typeof = $typeof(null as any, null as any);\r\n\r\n\r\nexport const $symbol = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($symbol)\r\n    // S expression: ($symbol name)\r\n    //  -> S expr  : symbol\r\n    checkParamsLength('$symbol', args, 1, 1);\r\n\r\n    if (typeof args[0] === 'string') {\r\n        return {symbol: args[0]};\r\n    } else {\r\n        throw new Error(`[SX] $symbol: Invalid argument(s): item(s) of args[0] is not string.`);\r\n    }\r\n};\r\nexport const $$symbol = $symbol(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__gensym = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__gensym)\r\n    // S expression: ($__gensym name)\r\n    //  -> S expr  : symbol\r\n    checkParamsLength('$__gensym', args, 0, 1);\r\n\r\n    const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\r\n    const tempVarSym = ({symbol: `${varBaseName}_$gensym`});\r\n    if (args.length === 1) {\r\n        const a = isSymbol(args[0]);\r\n        if (a) {\r\n            $__let(state, '')(a, tempVarSym);\r\n        } else if (typeof args[0] === 'string') {\r\n            $__let(state, '')({symbol: args[0]}, tempVarSym);\r\n        } else {\r\n            throw new Error(`[SX] $__gensym: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n        }\r\n    }\r\n    return tempVarSym;\r\n};\r\n\r\n\r\nexport const $isSymbol = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-symbol x)\r\n    // S expression: ($is-symbol x name)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isSymbol', args, 1, 2);\r\n\r\n    if (args.length === 1) {\r\n        return (isSymbol(args[0]) ? true : false);\r\n    } else {\r\n        if (typeof args[1] === 'string') {\r\n            return (isSymbol(args[0], args[1]) ? true : false);\r\n        } else {\r\n            throw new Error(`[SX] $isSymbol: Invalid argument(s): item(s) of args[1] is not string.`);\r\n        }\r\n    }\r\n};\r\nexport const $$isSymbol = $isSymbol(null as any, null as any);\r\n\r\n\r\nexport const $isNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-null x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNull', args, 1, 1);\r\n\r\n    return $$first(...args) === null;\r\n};\r\nexport const $$isNull = $isNull(null as any, null as any);\r\n\r\n\r\nexport const $isNil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-nil x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNil', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    return Array.isArray(car) && car.length === 0;\r\n};\r\nexport const $$isNil = $isNil(null as any, null as any);\r\n\r\n\r\nexport const $isUndefined = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-undefined x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isUndefined', args, 1, 1);\r\n\r\n    return $$first(...args) === void 0;\r\n};\r\nexport const $$isUndefined = $isUndefined(null as any, null as any);\r\n\r\n\r\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-list x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isList', args, 1, 1);\r\n\r\n    return Array.isArray($$first(...args));\r\n};\r\nexport const $$isList = $isList(null as any, null as any);\r\n\r\n\r\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-string x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isString', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'string';\r\n};\r\nexport const $$isString = $isString(null as any, null as any);\r\n\r\n\r\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-number x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNumber', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'number';\r\n};\r\nexport const $$isNumber = $isNumber(null as any, null as any);\r\n\r\n\r\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-NaN x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNaN', args, 1, 1);\r\n\r\n    return Number.isNaN($$first(...args));\r\n};\r\nexport const $$isNaN = $isNaN(null as any, null as any);\r\n\r\n\r\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-finate x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isFinite', args, 1, 1);\r\n\r\n    return Number.isFinite($$first(...args));\r\n};\r\nexport const $$isFinite = $isFinite(null as any, null as any);\r\n\r\n\r\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-integer x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isInteger', args, 1, 1);\r\n\r\n    return Number.isInteger($$first(...args));\r\n};\r\nexport const $$isInteger = $isInteger(null as any, null as any);\r\n\r\n\r\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-string x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$toString', args, 1, 1);\r\n\r\n    return String($$first(...args));\r\n};\r\nexport const $$toString = $toString(null as any, null as any);\r\n\r\n\r\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-number x)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$toNumber', args, 1, 1);\r\n\r\n    return toNumber($$first(...args));\r\n};\r\nexport const $$toNumber = $toNumber(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__# '(name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n\r\n            checkUnsafeVarNamesEx('$__#', r, keyName);\r\n            if (x.length === 1) {\r\n                // S expression: (# ... (keyName) ...)\r\n                //  -> JSON    : {..., keyName: true, ...}\r\n                r[keyName] = true;\r\n            } else if (x.length === 2) {\r\n                // S expression: (# ... (keyName value) ...)\r\n                //  -> JSON    : {..., keyName: value, ...}\r\n                r[keyName] = evaluate(state, x[1]);\r\n            } else {\r\n                // S expression: (# ... (keyName value1 value2 ...) ...)\r\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                r[keyName] =\r\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                    .concat(x.slice(1)));\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nconst assignBlacklist = [\r\n    globalObj,\r\n    (Object as any).__proto__,\r\n    ({} as any).__proto__,\r\n    (Function as any).__proto__,\r\n];\r\n\r\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($object-assign x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$objectAssign', args, 1);\r\n\r\n    if (assignBlacklist.includes(args[0])) {\r\n        throw new Error(`[SX] $objectAssign: Invalid argument: args[0] is blacklisted object.`);\r\n    }\r\n    return Object.assign(args[0], ...(args.slice(1)));\r\n};\r\nexport const $$objectAssign = $objectAssign(null as any, null as any);\r\n\r\n\r\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-stringify x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$jsonStringify', args, 1, 1);\r\n\r\n    return JSON.stringify($$first(...args));\r\n};\r\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\r\n\r\n\r\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-parse x)\r\n    //  -> S expr  : object\r\n    checkParamsLength('$jsonParse', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    return JSON.parse(s);\r\n};\r\nexport const $$jsonParse = $jsonParse(null as any, null as any);\r\n\r\n\r\nexport const $now = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($now)\r\n    //  -> S expr  : number\r\n    return Date.now();\r\n};\r\nexport const $$now = $now(null as any, null as any);\r\n\r\n\r\nexport const $datetimeFromIso = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-from-iso str)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$datetimeFromIso', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $datetimeFromIso: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    if (! /^(?:(?:-[0-9]{6,})|[0-9]{4,})-(?:[0-1][0-9])-(?:[0-3][0-9])(?:T(?:[0-2][0-9])(?:[:](?:[0-6][0-9])(?:[:](?:[0-6][0-9])(?:.[0-9]{1,})?)?)?(?:Z|[-+][0-9]{2}(?:[:]?[0-6][0-9])?)?)?$/.test(s)) {\r\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime (pattern unmatched): ${s}.`);\r\n    }\r\n    const dt = new Date(s).getTime();\r\n    if (Number.isNaN(dt)) {\r\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime: ${s}.`);\r\n    }\r\n    return dt;\r\n};\r\nexport const $$datetimeFromIso = $datetimeFromIso(null as any, null as any);\r\n\r\n\r\nexport const $datetime = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime year month1-12 day)\r\n    // S expression: ($datetime year month1-12 day hours)\r\n    // S expression: ($datetime year month1-12 day hours minutes)\r\n    // S expression: ($datetime year month1-12 day hours minutes seconds)\r\n    // S expression: ($datetime year month1-12 day hours minutes seconds milliseconds)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$datetime', args, 3, 7);\r\n\r\n    let s = '';\r\n    const year = Number(args[0]);\r\n    if (year >= 0) {\r\n        s += String(year).padStart(4, '0');\r\n    } else {\r\n        s += '-' + String(-year).padStart(6, '0');\r\n    }\r\n    // month1\r\n    s += '-' + String(Number(args[1])).padStart(2, '0');\r\n    // day\r\n    s += '-' + String(Number(args[2])).padStart(2, '0');\r\n    // hours\r\n    if (args.length >= 4) {\r\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\r\n        // minutes\r\n        if (args.length >= 5) {\r\n            s += ':' + String(Number(args[4])).padStart(2, '0');\r\n        } else {\r\n            s += ':00';\r\n        }\r\n        // seconds\r\n        if (args.length >= 6) {\r\n            s += ':' + String(Number(args[5])).padStart(2, '0');\r\n        }\r\n        // milliseconds\r\n        if (args.length >= 7) {\r\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\r\n        }\r\n        s += 'Z';\r\n    }\r\n    const dt = new Date(s).getTime();\r\n    if (Number.isNaN(dt)) {\r\n        throw new Error(`[SX] $datetime: Invalid datetime: ${s}.`);\r\n    }\r\n    return dt;\r\n};\r\nexport const $$datetime = $datetime(null as any, null as any);\r\n\r\n\r\nexport const $datetimeLc = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-lc year month1-12 day)\r\n    // S expression: ($datetime-lc year month1-12 day hours)\r\n    // S expression: ($datetime-lc year month1-12 day hours minutes)\r\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds)\r\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds milliseconds)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$datetimeLc', args, 3, 7);\r\n\r\n    let s = '';\r\n    const year = Number(args[0]);\r\n    if (year >= 0) {\r\n        s += String(year).padStart(4, '0');\r\n    } else {\r\n        s += '-' + String(-year).padStart(6, '0');\r\n    }\r\n    // month1\r\n    s += '-' + String(Number(args[1])).padStart(2, '0');\r\n    // day\r\n    s += '-' + String(Number(args[2])).padStart(2, '0');\r\n    // hours\r\n    if (args.length >= 4) {\r\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\r\n        // minutes\r\n        if (args.length >= 5) {\r\n            s += ':' + String(Number(args[4])).padStart(2, '0');\r\n        } else {\r\n            s += ':00';\r\n        }\r\n        // seconds\r\n        if (args.length >= 6) {\r\n            s += ':' + String(Number(args[5])).padStart(2, '0');\r\n        }\r\n        // milliseconds\r\n        if (args.length >= 7) {\r\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\r\n        }\r\n    } else {\r\n        s += 'T00:00:00.000';\r\n    }\r\n    const dt = new Date(s).getTime();\r\n    if (Number.isNaN(dt)) {\r\n        throw new Error(`[SX] $datetimeLc: Invalid datetime: ${s}.`);\r\n    }\r\n    return dt;\r\n};\r\nexport const $$datetimeLc = $datetimeLc(null as any, null as any);\r\n\r\n\r\nexport const $datetimeToIsoString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-to-iso-string number)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$datetimeToIsoString', args, 1, 1);\r\n\r\n    const n = $$first(...args);\r\n    if (typeof n !== 'number') {\r\n        throw new Error(`[SX] $datetimeToIsoString: Invalid argument(s): args[0] is not number.`);\r\n    }\r\n    const dt = new Date(n);\r\n    if (Number.isNaN(dt.getTime())) {\r\n        throw new Error(`[SX] $datetimeToIsoString: Invalid datetime: ${n}.`);\r\n    }\r\n    return dt.toISOString();\r\n};\r\nexport const $$datetimeToIsoString = $datetimeToIsoString(null as any, null as any);\r\n\r\n\r\nexport const $datetimeToComponents = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-to-components number)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$datetimeToComponents', args, 1, 1);\r\n\r\n    const n = $$first(...args);\r\n    if (typeof n !== 'number') {\r\n        throw new Error(`[SX] $datetimeToComponents: Invalid argument(s): args[0] is not number.`);\r\n    }\r\n    const dt = new Date(n);\r\n    if (Number.isNaN(dt.getTime())) {\r\n        throw new Error(`[SX] $datetimeToComponents: Invalid datetime: ${n}.`);\r\n    }\r\n    return ([\r\n        dt.getUTCFullYear(),\r\n        dt.getUTCMonth() + 1,\r\n        dt.getUTCDate(),\r\n        dt.getUTCHours(),\r\n        dt.getUTCMinutes(),\r\n        dt.getUTCSeconds(),\r\n        dt.getUTCMilliseconds(),\r\n        0, // TZ\r\n        dt.getUTCDay(),\r\n    ]);\r\n};\r\nexport const $$datetimeToComponents = $datetimeToComponents(null as any, null as any);\r\n\r\n\r\nexport const $datetimeToComponentsLc = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-to-components-lc number)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$datetimeToComponentsLc', args, 1, 1);\r\n\r\n    const n = $$first(...args);\r\n    if (typeof n !== 'number') {\r\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid argument(s): args[0] is not number.`);\r\n    }\r\n    const dt = new Date(n);\r\n    if (Number.isNaN(dt.getTime())) {\r\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid datetime: ${n}.`);\r\n    }\r\n    return ([\r\n        dt.getFullYear(),\r\n        dt.getMonth() + 1,\r\n        dt.getDate(),\r\n        dt.getHours(),\r\n        dt.getMinutes(),\r\n        dt.getSeconds(),\r\n        dt.getMilliseconds(),\r\n        -dt.getTimezoneOffset(), // time difference between local time and UTC time, in minutes.\r\n                                 // If your time zone is UTC+2:00, +120 will be returned.\r\n        dt.getDay(),\r\n    ]);\r\n};\r\nexport const $$datetimeToComponentsLc = $datetimeToComponentsLc(null as any, null as any);\r\n\r\n\r\nexport const $match = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($match pattern-str string)\r\n    // S expression: ($match pattern-str options-str string)\r\n    //  -> S expr  : array\r\n    checkParamsLength('$match', args, 2, 3);\r\n\r\n    if (! state.config.enableRegExpMatchOperators) {\r\n        throw new Error(`[SX] $match: Operator is disabled by configuration.`);\r\n    }\r\n\r\n    if (args.length === 2) {\r\n        const m = new RegExp(args[0]);\r\n        return m.exec(args[1]);\r\n    } else {\r\n        const m = new RegExp(args[0], args[1]);\r\n        return m.exec(args[2]);\r\n    }\r\n};\r\nexport const $$match = $match(null as any, null as any);\r\n\r\n\r\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-log expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.log(...args);\r\n    return null;\r\n};\r\nexport const $$consoleLog = $consoleLog(null as any, null as any);\r\n\r\n\r\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-error expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.error(...args);\r\n    return null;\r\n};\r\nexport const $$consoleError = $consoleError(null as any, null as any);\r\n\r\n\r\nexport const $consoleTrace = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-trace expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.trace(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTrace = $consoleTrace(null as any, null as any);\r\n\r\n\r\nexport const $consoleTime = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-time)\r\n    // S expression: ($console-time label)\r\n    //  -> S expr  : null\r\n    console.time(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTime = $consoleTime(null as any, null as any);\r\n\r\n\r\nexport const $consoleTimeEnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-time-end)\r\n    // S expression: ($console-time-end label)\r\n    //  -> S expr  : null\r\n    console.timeEnd(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTimeEnd = $consoleTimeEnd(null as any, null as any);\r\n\r\n\r\nexport const $consoleTimeLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-time-log label)\r\n    // S expression: ($console-time-log label value ... value)\r\n    //  -> S expr  : null\r\n    (console as any).timeLog(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTimeLog = $consoleTimeLog(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './core.fn';\r\n\r\n\r\n\r\nexport const operators: SxFuncInfo[] = [{\r\n    name: '$car',\r\n    fn: ops.$car,\r\n}, {\r\n    name: '$cdr',\r\n    fn: ops.$cdr,\r\n}, {\r\n    name: '$cons',\r\n    fn: ops.$cons,\r\n}, {\r\n    name: '$first',\r\n    fn: ops.$first,\r\n}, {\r\n    name: '$second',\r\n    fn: ops.$second,\r\n}, {\r\n    name: '$last',\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$progn', // alias of $last\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$rest',\r\n    fn: ops.$rest,\r\n}, {\r\n    name: '$first-and-second',\r\n    fn: ops.$firstAndSecond,\r\n}, {\r\n    name: '$atom',\r\n    fn: ops.$atom,\r\n}, {\r\n    name: '$eq',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '===',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '$not-eq',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '!==',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '$list',\r\n    fn: ops.$list,\r\n}, {\r\n    name: '$__scope',\r\n    fn: ops.$__scope,\r\n}, {\r\n    name: '$__global',\r\n    fn: ops.$__globalScope,\r\n}, {\r\n    name: '$__capture',\r\n    fn: ops.$__capture,\r\n}, {\r\n    name: '$__lambda',\r\n    fn: ops.$__lambda,\r\n}, {\r\n    name: '$__defun',\r\n    fn: ops.$__defun,\r\n}, {\r\n    name: '$__refun',\r\n    fn: ops.$__refun,\r\n}, {\r\n    name: '$__defmacro',\r\n    fn: ops.$__defmacro,\r\n}, {\r\n    name: '$apply',\r\n    fn: ops.$apply,\r\n}, {\r\n    name: '$__call',\r\n    fn: ops.$__call,\r\n}, {\r\n    name: '$__try',\r\n    fn: ops.$__try,\r\n}, {\r\n    name: '$raise',\r\n    fn: ops.$raise,\r\n}, {\r\n    name: '$__if',\r\n    fn: ops.$__if,\r\n}, {\r\n    name: '$__if-null',\r\n    fn: ops.$__ifNull,\r\n}, {\r\n    name: '$__cond',\r\n    fn: ops.$__cond,\r\n}, {\r\n    name: '$__while',\r\n    fn: ops.$__while,\r\n}, {\r\n    name: '$__do-while',\r\n    fn: ops.$__doWhile,\r\n}, {\r\n    name: '$__until',\r\n    fn: ops.$__until,\r\n}, {\r\n    name: '$__do-until',\r\n    fn: ops.$__doUntil,\r\n}, {\r\n    name: '$__repeat',\r\n    fn: ops.$__repeat,\r\n}, {\r\n    name: '$__for',\r\n    fn: ops.$__for,\r\n}, {\r\n    name: '$pipe',\r\n    fn: ops.$pipe,\r\n}, {\r\n    name: '$__get',\r\n    fn: ops.$__get,\r\n}, {\r\n    name: '$__let',\r\n    fn: ops.$__let,\r\n}, {\r\n    name: '$__set',\r\n    fn: ops.$__set,\r\n}, {\r\n    name: '$boolean',\r\n    fn: ops.$boolean,\r\n}, {\r\n    name: '$not',\r\n    fn: ops.$not,\r\n}, {\r\n    name: '$__and',\r\n    fn: ops.$__and,\r\n}, {\r\n    name: '$__or',\r\n    fn: ops.$__or,\r\n}, {\r\n    name: '==',\r\n    fn: ops.$ambiguousEq,\r\n}, {\r\n    name: '!=',\r\n    fn: ops.$ambiguousNotEq,\r\n}, {\r\n    name: '<',\r\n    fn: ops.$lt,\r\n}, {\r\n    name: '<=',\r\n    fn: ops.$le,\r\n}, {\r\n    name: '>',\r\n    fn: ops.$gt,\r\n}, {\r\n    name: '>=',\r\n    fn: ops.$ge,\r\n}, {\r\n    name: '$typeof',\r\n    fn: ops.$typeof,\r\n}, {\r\n    name: '$symbol',\r\n    fn: ops.$symbol,\r\n}, {\r\n    name: '$__gensym',\r\n    fn: ops.$__gensym,\r\n}, {\r\n    name: '$is-symbol',\r\n    fn: ops.$isSymbol,\r\n}, {\r\n    name: '$is-null',\r\n    fn: ops.$isNull,\r\n}, {\r\n    name: '$is-nil',\r\n    fn: ops.$isNil,\r\n}, {\r\n    name: '$is-undefined',\r\n    fn: ops.$isUndefined,\r\n}, {\r\n    name: '$is-list',\r\n    fn: ops.$isList,\r\n}, {\r\n    name: '$is-string',\r\n    fn: ops.$isString,\r\n}, {\r\n    name: '$is-number',\r\n    fn: ops.$isNumber,\r\n}, {\r\n    name: '$is-NaN',\r\n    fn: ops.$isNaN,\r\n}, {\r\n    name: '$is-finite',\r\n    fn: ops.$isFinite,\r\n}, {\r\n    name: '$is-integer',\r\n    fn: ops.$isInteger,\r\n}, {\r\n    name: '$to-string',\r\n    fn: ops.$toString,\r\n}, {\r\n    name: '$to-number',\r\n    fn: ops.$toNumber,\r\n}, {\r\n    name: '$__#',\r\n    fn: ops.$__toObject,\r\n}, {\r\n    name: '$object-assign',\r\n    fn: ops.$objectAssign,\r\n}, {\r\n    name: '$json-stringify',\r\n    fn: ops.$jsonStringify,\r\n}, {\r\n    name: '$now',\r\n    fn: ops.$now,\r\n}, {\r\n    name: '$datetime-from-iso',\r\n    fn: ops.$datetimeFromIso,\r\n}, {\r\n    name: '$datetime',\r\n    fn: ops.$datetime,\r\n}, {\r\n    name: '$datetime-lc',\r\n    fn: ops.$datetimeLc,\r\n}, {\r\n    name: '$datetime-to-iso-string',\r\n    fn: ops.$datetimeToIsoString,\r\n}, {\r\n    name: '$datetime-to-components',\r\n    fn: ops.$datetimeToComponents,\r\n}, {\r\n    name: '$datetime-to-components-lc',\r\n    fn: ops.$datetimeToComponentsLc,\r\n}, {\r\n    name: '$json-parse',\r\n    fn: ops.$jsonParse,\r\n}, {\r\n    name: '$match',\r\n    fn: ops.$match,\r\n}, {\r\n    name: '$console-log',\r\n    fn: ops.$consoleLog,\r\n}, {\r\n    name: '$console-error',\r\n    fn: ops.$consoleError,\r\n}, {\r\n    name: '$console-trace',\r\n    fn: ops.$consoleTrace,\r\n}, {\r\n    name: '$console-time',\r\n    fn: ops.$consoleTime,\r\n}, {\r\n    name: '$console-time-end',\r\n    fn: ops.$consoleTimeEnd,\r\n}, {\r\n    name: '$console-time-log',\r\n    fn: ops.$consoleTimeLog,\r\n}];\r\n\r\n\r\nexport const compilationOperators: SxFuncInfo[] = [{\r\n    name: '$$__lambda',\r\n    fn: ops.$comp$__lambda,\r\n}, {\r\n    name: '$$__defun',\r\n    fn: ops.$comp$__defun,\r\n}];\r\n\r\n\r\n// for backword compatibility\r\nexport default ([] as SxFuncInfo[]).concat(operators, compilationOperators);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState }     from '../../types';\r\nimport { isSymbol,\r\n         quote }             from '../../ast';\r\nimport { checkParamsLength } from '../../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$scope',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            list[1],\r\n            list[2],\r\n            ...(list.slice(3).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$local',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($local ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$global',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($__global expr1 ... exprN)\r\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\r\n        return [{symbol: '$__global'},\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-let', // alias of $local\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$capture',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($capture (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__capture '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__capture'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$closure',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($__lambda '(sym1 ... symN) 'expr ... 'expr) )\r\n        const symUse = isSymbol(list[2], 'use');\r\n        if (! symUse) {\r\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\r\n        }\r\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$__lambda'},\r\n            quote(state, list[1]),\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ])];\r\n    },\r\n}, {\r\n    name: '|->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        return [{symbol: '$closure'},\r\n            ...list.slice(1),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$refun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($refun name)\r\n        //  -> S expr  : ($__refun 'name)\r\n        return [{symbol: '$__refun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '<-',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (<- name)\r\n        //  -> S expr  : ($__refun 'name)\r\n        return [{symbol: '$__refun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defmacro',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defmacro name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defmacro'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$call',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($call thisArg symbol arg1 ... argN)\r\n        //  -> S expr  : ($__call thisArg 'symbol arg1 ... argN)\r\n        checkParamsLength('$call', list, 3);\r\n\r\n        return [{symbol: '$__call'},\r\n            list[1],\r\n            quote(state, list[2]),\r\n            ...(list.slice(3)),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$try',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($try expr catch-expr)\r\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\r\n        return [{symbol: '$__try'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if cond t-expr f-expr)\r\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\r\n        return [{symbol: '$__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if-null',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if-null cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '??',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (?? cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$cond',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($cond cond1 expr1 ... condN exprN)\r\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        return [{symbol: '$__cond'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($while condition expr1 exprN)\r\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-while condition expr1 exprN)\r\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($until condition expr1 exprN)\r\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-until condition expr1 exprN)\r\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$repeat',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($repeat i of n-times expr1 exprN)\r\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__repeat'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($for x of list expr1 exprN)\r\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__for'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$get',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\r\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        return [{symbol: '$__get'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$let', list, 3, 3);\r\n\r\n        return [{symbol: '$__let'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-defvar',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$clisp-defvar', list, 3, 3);\r\n\r\n        return [{symbol: '$global'},\r\n            [{symbol: '$__let'},\r\n                quote(state, list[1]),\r\n                list[2]\r\n            ],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\r\n        checkParamsLength('$set', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-setq', // alias of $set\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-setq symbol expr)\r\n        //  -> S expr  : ($__set 'symbol expr)\r\n        checkParamsLength('$clisp-setq', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$and',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($and expr1 ... exprN)\r\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\r\n        return [{symbol: '$__and'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$or',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($or expr1 ... exprN)\r\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\r\n        return [{symbol: '$__or'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$gensym',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($gensym)\r\n        // S expression: ($gensym name)\r\n        //  -> S expr  : ($__gensym 'name)\r\n        return [\r\n            {symbol: '$__gensym'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '#',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (# (name value...)...)\r\n        //  -> S expr  : ($__# '(name value...)...)\r\n        return [\r\n            {symbol: '$__#'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport const compilationMacros: SxMacroInfo[] = [{\r\n    name: '$$closure',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($$__lambda '(sym1 ... symN) 'expr ... 'expr) )\r\n        const symUse = isSymbol(list[2], 'use');\r\n        if (! symUse) {\r\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\r\n        }\r\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$$__lambda'},\r\n            quote(state, list[1]),\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ])];\r\n    },\r\n}, {\r\n    name: '|=>',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        return [{symbol: '$$closure'},\r\n            ...list.slice(1),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '=>',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($$__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\n// for backword compatibility\r\nexport default ([] as SxMacroInfo[]).concat(macros, compilationMacros);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [\r\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\r\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\r\n\r\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\r\n\r\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\r\n\r\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\r\n\r\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\r\n\r\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\r\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\r\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\r\n\r\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\r\n];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxEof,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedFragment,\r\n         SxComment,\r\n         SxToken,\r\n         SxChar,\r\n         ScriptTerminationError } from './types';\r\nimport { quote,\r\n         backquote,\r\n         wrapByUnquote,\r\n         spread,\r\n         splice }                 from './ast';\r\n\r\n\r\n\r\nfunction isEOF(ch: SxChar): boolean {\r\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\r\n}\r\n\r\n\r\nfunction isSpace(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && ch.trim().length === 0;\r\n}\r\n\r\n\r\nfunction isNumberFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isSymbolFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' &&\r\n        !isSpace(ch) &&\r\n        !isNumberFirstChar(ch);\r\n}\r\n\r\n\r\n\r\nfunction lookCurrentLineHint(state: SxParserState): string {\r\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\r\n        state.strings.length > state.index ?\r\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\r\n}\r\n\r\n\r\nfunction getChar(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\r\n    if (state.strings.length <= state.index) {\r\n        return {eof: true};\r\n    }\r\n    if (state.strings[state.index].length <= state.pos) {\r\n        if ((! state.values) || (state.values.length <= state.index)) {\r\n            state.pos = 0;\r\n            state.index++;\r\n            return getChar(state);\r\n        } else {\r\n            const ch = {value: state.values[state.index]};\r\n            state.pos = 0;\r\n            state.index++;\r\n            return ch;\r\n        }\r\n    }\r\n    if (virtualEof) {\r\n        for (const v of virtualEof) {\r\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\r\n            if (ch === v) {\r\n                state.pos += v.length;\r\n                state.line += ch.split('\\n').length - 1;\r\n                return { eof: false , eofSeq: v };\r\n            }\r\n        }\r\n    }\r\n    {\r\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n        state.pos++;\r\n\r\n        if (ch === '\\n') {\r\n            state.line++;\r\n        }\r\n\r\n        if ((! disableEscape) && ch === '\\\\') {\r\n            if (state.strings[state.index].length <= state.pos) {\r\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n            state.pos++;\r\n\r\n            switch (ch) {\r\n            case 'b':\r\n                ch = '\\b';\r\n                break;\r\n            case 't':\r\n                ch = '\\t';\r\n                break;\r\n            case 'n':\r\n                ch = '\\n';\r\n                break;\r\n            case 'v':\r\n                ch = '\\v';\r\n                break;\r\n            case 'f':\r\n                ch = '\\f';\r\n                break;\r\n            case 'r':\r\n                ch = '\\r';\r\n                break;\r\n            case 'U': case 'u':\r\n                {\r\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\r\n                        let ch1 = '';\r\n                        for (let i = 0; i < 6; i++) {\r\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\r\n                            if (ch2 === '}') {\r\n                                if (i === 0) {\r\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                                }\r\n                                state.pos += i;\r\n                                break;\r\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\r\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            ch1 += ch2;\r\n                        }\r\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos++;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    } else {\r\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\r\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos += 4;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n}\r\n\r\n\r\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[], disableEscape?: boolean): SxChar[] {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    const chs: SxChar[] = [];\r\n\r\n    try {\r\n        for (let i = 0; i < n; i++) {\r\n            chs.push(getChar(state, virtualEof, disableEscape));\r\n        }\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return chs;\r\n}\r\n\r\n\r\nfunction lookAhead(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    let ch: SxChar;\r\n\r\n    try {\r\n        ch = getChar(state, virtualEof, disableEscape);\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return ch;\r\n}\r\n\r\n\r\nfunction skipWhitespaces(state: SxParserState): void {\r\n    let ch = lookAhead(state);\r\n    while (!isEOF(ch) && isSpace(ch)) {\r\n        getChar(state);\r\n        ch = lookAhead(state);\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (/^0[XxOoBb][0-9]*$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|(0[XxOoBb][0-9]+)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\r\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n    }\r\n    return Number(s);\r\n}\r\n\r\n\r\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (isSpace(ch)) {\r\n                break;\r\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\r\n                break;\r\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                getChar(state, virtualEof);\r\n                const v = (ch as SxExternalValue).value;\r\n                s += String(ch);\r\n            } else {\r\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (state.config.enableShorthands) {\r\n        let m: RegExpMatchArray | null = null;\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        if (m = s.match(/^:((?:\\:[^=:]+?)+?)=$/)) {\r\n            // ::foo:bar:baz= -> ($splice ($set (foo bar baz)))\r\n            const ws = m[1].slice(1).split(':');\r\n            const z =\r\n                [{symbol: state.config.reservedNames.splice},\r\n                    [{symbol: state.config.reservedNames.set},\r\n                        ws\r\n                    ]\r\n                ];\r\n            return z as any;\r\n        }\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        else if (m = s.match(/^:((?:\\:[^@:]+?)+?)@([^@:]+?)$/)) {\r\n            // ::foo:bar@baz -> ($splice ($call ($get foo bar) baz))\r\n            const ws = m[1].slice(1).split(':');\r\n            const z =\r\n                [{symbol: state.config.reservedNames.splice},\r\n                    [{symbol: state.config.reservedNames.call},\r\n                        [{symbol: state.config.reservedNames.get}, ...ws],\r\n                        {symbol: m[2]},\r\n                    ]\r\n                ];\r\n            return z as any;\r\n        }\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        else if (m = s.match(/^:((?:\\:[^:]+?)+?)$/)) {\r\n            // ::foo:bar:baz -> ($get foo bar baz)\r\n            const ws = m[1].slice(1).split(':');\r\n            const z = [{symbol: state.config.reservedNames.get}, ...ws];\r\n            return z as any;\r\n        }\r\n    }\r\n\r\n    return {symbol: s};\r\n}\r\n\r\n\r\nfunction parseStringOrComment(\r\n        state: SxParserState, eof: string[],\r\n        valuesStartSeq: string | null,\r\n        valuesStopChar: string,\r\n        disableEscape: boolean,\r\n        allowPhysicalEof: boolean,\r\n    ): { strings: string[], values: any[] } {\r\n\r\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\r\n    const strings: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (;;) {\r\n        let s = '';\r\n        let ch = lookAhead(state, eofSeqs, disableEscape);\r\n\r\n        while (! isEOF(ch)) {\r\n            if (typeof ch === 'string') {\r\n                getChar(state, eofSeqs, disableEscape);\r\n                s += ch;\r\n            } else {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state, eofSeqs, disableEscape);\r\n                    const v = (ch as SxExternalValue).value;\r\n                    s += String(ch);\r\n                } else {\r\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            }\r\n\r\n            ch = lookAhead(state, eofSeqs, disableEscape);\r\n        }\r\n\r\n        getChar(state, eofSeqs, disableEscape);\r\n\r\n        if ((ch as SxEof).eof === true) {\r\n            if (! allowPhysicalEof) {\r\n                throw new ScriptTerminationError('parseStringOrComment');\r\n            }\r\n        }\r\n\r\n        strings.push(s);\r\n\r\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\r\n            values.push(parseList(state, valuesStopChar, []));\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return { strings, values };\r\n}\r\n\r\n\r\nfunction parseString(state: SxParserState, disableEscape: boolean): string {\r\n    return parseStringOrComment(state, ['\"'], null, ')', disableEscape, false).strings[0];\r\n}\r\n\r\n\r\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\r\n    const q: SxToken[] = [symbol];\r\n\r\n    if (attrs) {\r\n        q.push(attrs);\r\n    }\r\n\r\n    const inner = parseStringOrComment(state, ['\"\"\"'], '%%%(', ')', false, false);\r\n    for (let i = 0; i < inner.strings.length; i++) {\r\n        q.push(inner.strings[i]);\r\n        if (i < inner.values.length) {\r\n            q.push(inner.values[i]);\r\n        }\r\n    }\r\n\r\n    return q;\r\n}\r\n\r\n\r\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')', false, true).strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['|#'], null, ')', false, false).strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseOneToken(state: SxParserState): SxToken {\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case ')':\r\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n\r\n        case '(':\r\n            getChar(state);\r\n            return parseList(state, ')', []);\r\n\r\n        case \"'\": case \"`\": case ',':\r\n            {\r\n                getChar(state);\r\n                const ahead = lookAhead(state);\r\n                let isSpliceUnquote = false;\r\n                if (ch === ',' && ahead === '@') {\r\n                    getChar(state);\r\n                    isSpliceUnquote = true;\r\n                }\r\n                skipWhitespaces(state);\r\n                const ret = (ch === \"'\" ?\r\n                        quote :\r\n                        (ch === \"`\" ? backquote : wrapByUnquote))\r\n                    (state, parseOneToken(state)\r\n                );\r\n                return (isSpliceUnquote ? splice(state, ret) : ret);\r\n            }\r\n\r\n        case \".\":\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 2);\r\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    skipWhitespaces(state);\r\n                    return spread(state, parseOneToken(state));\r\n                } else {\r\n                    skipWhitespaces(state);\r\n                    return {dotted: parseOneToken(state)};\r\n                }\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            return parseSingleLineComment(state);\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseMultiLineComment(state);\r\n                } else {\r\n                    return parseSymbol(state);\r\n                }\r\n            }\r\n\r\n        case '\"':\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 4);\r\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\r\n                    let isHereDoc = true;\r\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\r\n                        // here doc\r\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\r\n                        if (aheads[2] === '+' || aheads[2] === '-') {\r\n                            if (! isNumberAfterSignChar(aheads[3])) {\r\n                                isHereDoc = false;\r\n                            }\r\n                        }\r\n                        // here doc\r\n                    } else if (isSymbolFirstChar(aheads[2])) {\r\n                        isHereDoc = false;\r\n                    } else {\r\n                        // here doc\r\n                    }\r\n                    getChar(state);\r\n                    getChar(state);\r\n\r\n                    let sym: SxSymbol | number | null = null;\r\n                    let attrs: SxToken[] | null = null;\r\n                    if (isHereDoc) {\r\n                        sym = {symbol: state.config.reservedNames.Template};\r\n                    } else {\r\n                        sym = parseSymbol(state, ['@']);\r\n                        if (sym === null) {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        if (typeof sym === 'number') {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        const ahs = lookAheads(state, 2);\r\n                        if (ahs[0] === '@') {\r\n                            if (ahs[1] !== '{') {\r\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            getChar(state);\r\n                            getChar(state);\r\n                            const a = parseList(state, '}', [{symbol: '@'}]);\r\n                            if (Array.isArray(a)) {\r\n                                attrs = a;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return parseHereDoc(state, sym, attrs);\r\n                } else {\r\n                    return parseString(state, false);\r\n                }\r\n            }\r\n\r\n        case '@':\r\n            if (state.config.enableVerbatimStringLiteral) {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '\"') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseString(state, true);\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            if (typeof ch !== 'string') {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state);\r\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\r\n                } else {\r\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            } else if (isSpace(ch)) {\r\n                break;\r\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\r\n                if (ch === '+' || ch === '-') {\r\n                    const aheads = lookAheads(state, 2);\r\n                    if (! isNumberAfterSignChar(aheads[1])) {\r\n                        return parseSymbol(state);\r\n                    }\r\n                }\r\n                return parseNumber(state);\r\n            } else if (isSymbolFirstChar(ch)) {\r\n                return parseSymbol(state);\r\n            } else {\r\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseOneToken');\r\n}\r\n\r\n\r\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]): SxToken {\r\n    const r: SxToken[] = initialList.slice(0);\r\n    let dotted = false;\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case listStopChar:\r\n            getChar(state);\r\n            if (dotted) {\r\n                return r[0];\r\n            } else {\r\n                return r;\r\n            }\r\n\r\n        default:\r\n            {\r\n                const t = parseOneToken(state);\r\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\r\n                    if (r.length !== 1) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    dotted = true;\r\n                    if (Array.isArray(t)) {\r\n                        t.unshift(r.pop() as SxToken);\r\n                        r.push(t);\r\n                    } else {\r\n                        r.push({car: r.pop() as SxToken, cdr: (t as SxDottedFragment).dotted});\r\n                    }\r\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                    if (! state.config.stripComments) {\r\n                        r.push(t);\r\n                    }\r\n                } else {\r\n                    if (dotted) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    r.push(t);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseList');\r\n}\r\n\r\n\r\n\r\nexport function parse(state: SxParserState) {\r\n    const r: SxToken[] = [];\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case '(':\r\n            getChar(state);\r\n            r.push(parseList(state, ')', []));\r\n            break;\r\n\r\n        case \"'\": case \"`\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                for (;;) {\r\n                    const t = parseOneToken(state);\r\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                        if (! state.config.stripComments) {\r\n                            r.push(t);\r\n                        }\r\n                    } else {\r\n                        r.push((ch === \"'\" ? quote : backquote)(state, t));\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            if (state.config.stripComments) {\r\n                parseSingleLineComment(state);\r\n            } else {\r\n                r.push(parseSingleLineComment(state));\r\n            }\r\n            break;\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseMultiLineComment(state);\r\n                    } else {\r\n                        r.push(parseMultiLineComment(state));\r\n                    }\r\n                } else {\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseSingleLineComment(state);\r\n                    } else {\r\n                        r.push(parseSingleLineComment(state));\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case '\"':\r\n            {\r\n                const aheads = lookAheads(state, 3);\r\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\r\n                    r.push(parseOneToken(state));\r\n                    break;\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxReservedNames,\r\n         SxParserConfig } from './types';\r\n\r\n\r\n\r\nexport const defaultReservedNames: SxReservedNames = {\r\n    eval: '$eval',\r\n    quote: '$quote',\r\n    backquote: '$backquote',\r\n    unquote: '$unquote',\r\n    spread: '$spread',\r\n    splice: '$splice',\r\n\r\n    car: '$car',\r\n    cdr: '$cdr',\r\n    cons: '$cons',\r\n    atom: '$atom',\r\n    eq: '$eq',\r\n    list: '$list',\r\n\r\n    let: '$clisp-let',\r\n    lambda: '$lambda',\r\n    self: '$self',\r\n    defun: '$defun',\r\n    thiz: '$this',\r\n\r\n    if: '$if',\r\n    cond: '$cond',\r\n\r\n    while: '$while',\r\n    doWhile: '$do-while',\r\n    until: '$until',\r\n    doUntil: '$do-until',\r\n\r\n    get: '$get',\r\n    defvar: '$clisp-defvar',\r\n    setq: '$clisp-setq',\r\n    set: '$set',\r\n    call: '$call',\r\n\r\n    not: '$not',\r\n    and: '$and',\r\n    or: '$or',\r\n\r\n    isSymbol: '$is-symbol',\r\n    gensym: '$gensym',\r\n    raise: '$raise',\r\n    catch: '$catch',\r\n\r\n    Template: 'Template',\r\n};\r\n\r\nexport const defaultConfig: SxParserConfig = {\r\n    raiseOnUnresolvedSymbol: false,\r\n    enableEvaluate: true,\r\n    enableHereDoc: true,\r\n    enableSpread: true,\r\n    enableSplice: true,\r\n    enableShorthands: true,\r\n    enableVerbatimStringLiteral: true,\r\n    enableTailCallOptimization: true,\r\n    enableRegExpMatchOperators: true,\r\n    enableCompilationOperators: true,\r\n    stripComments: false,\r\n    wrapExternalValue: true,\r\n    returnMultipleRoot: false,\r\n    maxEvalCount: 0,\r\n\r\n    reservedNames: defaultReservedNames,\r\n    symbols: [],\r\n    macros: [],\r\n    funcs: [],\r\n};\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxFuncInfo,\r\n         SxSymbolInfo,\r\n         SxParserConfig,\r\n         SxParserState,\r\n         SxToken,\r\n         SExpressionTemplateFn,\r\n         SExpressionAsyncTemplateFn } from '../types';\r\nimport { parse }                      from '../parser';\r\nimport { evaluate }                   from '../evaluate';\r\nimport { defaultConfig }              from '../defaults';\r\n\r\n\r\n\r\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\r\n    return {\r\n        strings: typeof strings === 'string' ? [strings] : strings,\r\n        values: values || [],\r\n\r\n        index: 0,\r\n        pos: 0,\r\n        line: 0,\r\n\r\n        evalCount: 0,\r\n\r\n        scopes: [{isBlockLocal: false, scope: globals}],\r\n\r\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\r\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\r\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\r\n\r\n        config,\r\n    };\r\n}\r\n\r\n\r\nfunction resetState(state: SxParserState, strings: TemplateStringsArray | string, values?: any[]) {\r\n    state.strings = typeof strings === 'string' ? [strings] : strings;\r\n    state.values = values || [];\r\n    state.index = 0;\r\n    state.pos = 0;\r\n    state.line = 0;\r\n    state.evalCount = 0;\r\n    return state;\r\n}\r\n\r\n\r\nexport function SExpression(conf?: SxParserConfig): SExpressionTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    (f as any).repl = () => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        (fRepl as any).sync = fRepl;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\nexport function SExpressionAsync(conf?: SxParserConfig): SExpressionAsyncTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = async (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n\r\n                if (typeof s[i] === 'object' && s[i] !== null && typeof (s[i] as any).then === 'function') {\r\n                    s[i] = await s[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    (f as any).repl = () => {\r\n        const execSync = (stat: SxParserState, s: SxToken[]) => {\r\n            if (config.enableEvaluate) {\r\n                for (let i = 0; i < s.length; i++) {\r\n                    s[i] = evaluate(stat, s[i]);\r\n                }\r\n            }\r\n\r\n            if (config.returnMultipleRoot) {\r\n                return s.length === 1 ? s[0] : s;\r\n            } else {\r\n                return s[s.length - 1];\r\n            }\r\n        };\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        const fReplSync: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return execSync(state, parse(state));\r\n        }) as any;\r\n        (fRepl as any).sync = fReplSync;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { StringParserFnWithCtx } from './types';\r\nimport { zeroWidth,\r\n         zeroWidthError,\r\n         beginning,\r\n         end,\r\n         quantify,\r\n         first,\r\n         or,\r\n         transform,\r\n         lookAhead,\r\n         lookBehind,\r\n         ApplyProductionRulesArg,\r\n         applyProductionRules,\r\n         makeProgram } from './parser';\r\n\r\n\r\n\r\nexport function charSequence<C, R>(\r\n        helper: (token: string) => R\r\n        ): (needle: string) => StringParserFnWithCtx<C, R> {\r\n\r\n    return (needle => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n            return (src.startsWith(needle) ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + needle.length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(needle)],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"charSequence(${needle})\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function charClass<C, R>(\r\n        helper: (token: string) => R\r\n        ): (...needles: string[]) => StringParserFnWithCtx<C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n            let index = -1;\r\n\r\n            const succeeded = needles.some((needle, idx) => {\r\n                const matched = src.startsWith(needle);\r\n                if (matched) {\r\n                    index = idx;\r\n                    return true;\r\n                }\r\n            });\r\n\r\n            return (succeeded ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + needles[index].length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(needles[index])],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"charClass(${needles.join(',')})\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function charClassNot<C, R>(\r\n    helper: (token: string) => R\r\n    ): (...needles: string[]) => StringParserFnWithCtx<C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n\r\n            for (const needle of needles) {\r\n                const matched = src.startsWith(needle);\r\n                if (matched) {\r\n                    return ({\r\n                        succeeded: false,\r\n                        error: false,\r\n                        src: input.src,\r\n                        pos: input.start,\r\n                        message: `operator \"charClassNot(${needles.join(',')})\"`,\r\n                    });\r\n                }\r\n            }\r\n            const p = input.src.codePointAt(input.start);\r\n            if (p === void 0) {\r\n                return ({\r\n                    succeeded: false,\r\n                    error: false,\r\n                    src: input.src,\r\n                    pos: input.start,\r\n                    message: `operator \"charClassNot(${needles.join(',')})\"`,\r\n                });\r\n            }\r\n            const c = String.fromCodePoint(p);\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + c.length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(c)],\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function charClassByNeedleFn<C, R>(\r\n        helper: (token: string) => R\r\n        ): (needle: (src: string) => number) => StringParserFnWithCtx<C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    return (needle => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n            const len = needle(src);\r\n\r\n            return (len >= 0 ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + len,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(src.substring(0, len))],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"charClassByNeedleFn\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function templateStringsParam<C, R>(\r\n        criteria: (o: any) => boolean, conv?: (o: any) => any): StringParserFnWithCtx<C, R> {\r\n\r\n    return (input => {\r\n        const src = input.src.slice(input.start, input.start + 1);\r\n        if (src === '\\x00') {\r\n            if (input.templateArgsPos) {\r\n                let argIdx = -1;\r\n                const strIdx = input.templateArgsPos.findIndex((v, i) => {\r\n                    argIdx = i;\r\n                    return v === input.start;\r\n                });\r\n                if (0 <= strIdx) {\r\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion\r\n                    const o = input.templateArgs![argIdx];\r\n                    if (criteria(o)) {\r\n                        return ({\r\n                            succeeded: true,\r\n                            next: {\r\n                                src: input.src,\r\n                                start: input.start + 1,\r\n                                end: input.end,\r\n                                context: input.context,\r\n                                templateArgs: input.templateArgs,\r\n                                templateArgsPos: input.templateArgsPos,\r\n                            },\r\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n                            tokens: [(conv ? conv(o) : o)],\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ({\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: `operator \"stringTemplatesParam()\"`,\r\n        });\r\n    });\r\n}\r\n\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function getStringParsers<C, R>(\r\n        params: {\r\n            rawToToken: (rawToken: string) => R,\r\n            concatTokens: (tokens: R[]) => R[],\r\n        }) {\r\n\r\n    const seq = charSequence<C, R>(params.rawToToken);\r\n    const cls = charClass<C, R>(params.rawToToken);\r\n    const notCls = charClassNot<C, R>(params.rawToToken);\r\n    const clsFn = charClassByNeedleFn<C, R>(params.rawToToken);\r\n    const cat = transform<string, C, R>(params.concatTokens);\r\n    const once = quantify<string, C, R>(1, 1);\r\n    const repeat = quantify<string, C, R>();\r\n    // TODO: reduce unneccessary call for adding types.\r\n    const qty = (min?: number, max?: number) => quantify<string, C, R>(min, max);\r\n    const combine = transform<string, C, R>();\r\n    const erase = transform<string, C, R>(tokens => []);\r\n\r\n    const isAlpha = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            ('A' <= c && c <= 'Z') ||\r\n            ('a' <= c && c <= 'z')) ? c.length : -1);\r\n    });\r\n\r\n    const isUpper = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('A' <= c && c <= 'Z') ? c.length : -1);\r\n    });\r\n\r\n    const isLower = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('a' <= c && c <= 'z') ? c.length : -1);\r\n    });\r\n\r\n    const isNumber = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('0' <= c && c <= '9') ? c.length : -1);\r\n    });\r\n\r\n    const isNonZeroNumber = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('1' <= c && c <= '9') ? c.length : -1);\r\n    });\r\n\r\n    const isBinNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('0' <= c && c <= '1') ? c.length : -1);\r\n    });\r\n\r\n    const isOctNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('0' <= c && c <= '7') ? c.length : -1);\r\n    });\r\n\r\n    const isHexNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            ('A' <= c && c <= 'F') ||\r\n            ('a' <= c && c <= 'f') ||\r\n            ('0' <= c && c <= '9')) ? c.length : -1);\r\n    });\r\n\r\n    const isAlNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            ('A' <= c && c <= 'Z') ||\r\n            ('a' <= c && c <= 'z') ||\r\n            ('0' <= c && c <= '9')) ? c.length : -1);\r\n    });\r\n\r\n    const isSpace = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((' \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e' +\r\n            '\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a' +\r\n            '\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').includes(c) ? c.length : -1);\r\n    });\r\n\r\n    const isSpaceWithinSingleLine = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((' \\f\\t\\v\\u00a0\\u1680\\u180e' +\r\n            '\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a' +\r\n            '\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').includes(c) ? c.length : -1);\r\n    });\r\n\r\n    const isControl = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            (0x0000 <= p && p <= 0x001f) ||\r\n            (0x007f <= p && p <= 0x009f)) ? c.length : -1);\r\n    });\r\n\r\n    const isWord = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ((' \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e' +\r\n              '\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a' +\r\n              '\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').includes(c)) ||\r\n            ((0x0000 <= p && p <= 0x001f) ||\r\n             (0x007f <= p && p <= 0x009f)) ?\r\n            -1 : c.length);\r\n    });\r\n\r\n    const isNewline = cls('\\r\\n', '\\n', '\\r');\r\n\r\n    const isAny = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return c.length;\r\n    });\r\n\r\n\r\n    const binSep =\r\n        first(isBinNum, cls('_'));\r\n    const octSep =\r\n        first(isOctNum, cls('_'));\r\n    const hexSep =\r\n        first(isHexNum, cls('_'));\r\n\r\n    const binaryIntegerNumber = (...prefixes: Array<StringParserFnWithCtx<C, R>>) =>\r\n        combine(erase(first(...prefixes)),\r\n            cat(once(isBinNum), repeat(binSep)), );\r\n    const octalIntegerNumber = (...prefixes: Array<StringParserFnWithCtx<C, R>>) =>\r\n        combine(erase(first(...prefixes)),\r\n            cat(once(isOctNum), repeat(octSep)), );\r\n    const hexIntegerValue = (...prefixes: Array<StringParserFnWithCtx<C, R>>) =>\r\n        combine(erase(first(...prefixes)),\r\n            cat(once(isHexNum), repeat(hexSep)), );\r\n    const decimalIntegerNumber =\r\n        combine(cat(qty(0, 1)(cls('+', '-')),\r\n            first(combine(once(isNonZeroNumber), repeat(first(isNumber, cls('_')))),\r\n                seq('0'), )));\r\n    const bigDecimalIntegerNumber =\r\n        combine(cat(decimalIntegerNumber,\r\n            erase(seq('n')), ));\r\n    const floatingPointNumber =\r\n        combine(cat(qty(0, 1)(cls('+', '-')),\r\n            first(combine(once(isNonZeroNumber), repeat(first(isNumber, cls('_')))),\r\n                seq('0'), ),\r\n            qty(0, 1)(combine(seq('.'),\r\n                qty(1)(first(isNumber, cls('_'))), )),\r\n            qty(0, 1)(combine(cls('E', 'e'), qty(0, 1)(cls('+', '-')),\r\n                first(combine(once(isNonZeroNumber), repeat(isNumber)), seq('0')), ))));\r\n\r\n    // TODO: reduce unneccessary call for adding types.\r\n    return ({\r\n        seq,\r\n        cls,\r\n        notCls,\r\n        clsFn,\r\n        classes: {\r\n            alpha: isAlpha,\r\n            upper: isUpper,\r\n            lower: isLower,\r\n            num: isNumber,\r\n            nonzero: isNonZeroNumber,\r\n            bin: isBinNum,\r\n            oct: isOctNum,\r\n            hex: isHexNum,\r\n            alnum: isAlNum,\r\n            space: isSpace,\r\n            spaceWithinSingleLine: isSpaceWithinSingleLine,\r\n            ctrl: isControl,\r\n            newline: isNewline,\r\n            word: isWord,\r\n            any: isAny,\r\n        },\r\n        numbers: {\r\n            bin: binaryIntegerNumber,\r\n            oct: octalIntegerNumber,\r\n            hex: hexIntegerValue,\r\n            int: decimalIntegerNumber,\r\n            bigint: bigDecimalIntegerNumber,\r\n            float: floatingPointNumber,\r\n        },\r\n        isParam: templateStringsParam,\r\n        cat,\r\n        once,\r\n        repeat,\r\n        qty,\r\n        zeroWidth: (helper?: () => R) => zeroWidth<string, C, R>(helper), // TODO:\r\n        err: (message: string) => zeroWidthError<string, C, R>(message),  // TODO:\r\n        beginning: (helper?: () => R) => beginning<string, C, R>(helper), // TODO:\r\n        end: (helper?: () => R) => end<string, C, R>(helper),             // TODO:\r\n        first: (...parsers: Array<StringParserFnWithCtx<C, R>>) => first<string, C, R>(...parsers), // TODO:\r\n        or: (...parsers: Array<StringParserFnWithCtx<C, R>>) => or<string, C, R>(...parsers),       // TODO:\r\n        combine,\r\n        erase,\r\n        trans: (fn: (tokens: R[]) => R[]) => transform<string, C, R>(fn),                                 // TODO:\r\n        ahead: (...parsers: Array<StringParserFnWithCtx<C, R>>) => lookAhead<string, C, R>(...parsers),   // TODO:\r\n        behind: (n: number, helper?: () => R) => lookBehind<string, C, R>(n, helper),\r\n        rules: (args: ApplyProductionRulesArg<string, C, R>) => applyProductionRules<string, C, R>(args), // TODO:\r\n        makeProgram,\r\n    });\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { ParserFnWithCtx } from './types';\r\nimport { zeroWidth,\r\n         zeroWidthError,\r\n         beginning,\r\n         end,\r\n         quantify,\r\n         first,\r\n         or,\r\n         transform,\r\n         lookAhead,\r\n         lookBehind,\r\n         ApplyProductionRulesArg,\r\n         applyProductionRules,\r\n         makeProgram } from './parser';\r\n\r\n\r\n\r\nexport function objSequence<T extends ArrayLike<T[number]>, C, R>(\r\n        helper: (token: T[number]) => R,\r\n        comparator: (a: T[number], b: T[number]) => boolean,\r\n        ): (needle: T) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return (needle => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n            let matched = true;\r\n\r\n            if (len >= needle.length) {\r\n                for (let i = 0; i < needle.length; i++) {\r\n                    if (! comparator(input.src[input.start + i], needle[i])) {\r\n                        matched = false;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                matched = false;\r\n            }\r\n\r\n            return (matched ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + needle.length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(needle)],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\r\n                message: `operator \"objSequence(${needle})\"`, // TODO: BUG: `needle` is not stringify correctly.\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function objClass<T extends ArrayLike<T[number]>, C, R>(\r\n        helper: (token: T[number]) => R,\r\n        comparator: (a: T[number], b: T[number]) => boolean,\r\n        ): (...needles: Array<T[number]>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    // NOTE: <T> version `needles` type is `T`.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n            let index = -1;\r\n\r\n            const succeeded = len > 0 ? needles.some((needle, idx) => {\r\n                if (comparator(input.src[input.start], needle)) {\r\n                    index = idx;\r\n                    return true;\r\n                }\r\n            }) : false;\r\n\r\n            return (succeeded ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + 1,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(needles[index])],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"objClass(${needles.join(',')})\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function objClassNot<T extends ArrayLike<T[number]>, C, R>(\r\n    helper: (token: T[number]) => R,\r\n    comparator: (a: T[number], b: T[number]) => boolean,\r\n    ): (...needles: Array<T[number]>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    // NOTE: <T> version `needles` type is `T`.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n\r\n            if (len > 0) {\r\n                for (const needle of needles) {\r\n                    let matched = true;\r\n\r\n                    if (! comparator(input.src[input.start], needle)) {\r\n                        matched = false;\r\n                        break;\r\n                    }\r\n\r\n                    if (matched) {\r\n                        return ({\r\n                            succeeded: false,\r\n                            error: false,\r\n                            src: input.src,\r\n                            pos: input.start,\r\n                            message: `operator \"objClassNot(${needles.join(',')})\"`,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + 1,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(input.src[input.start])],\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function objClassByNeedleFn<T extends ArrayLike<T[number]>, C, R>(\r\n        helper: (token: T[number]) => R,\r\n        comparator: (a: T[number], b: T[number]) => boolean,\r\n        ): (needle: (src: T[number]) => boolean) => ParserFnWithCtx<T, C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    // NOTE: <T> version `needles` type is `T`.\r\n    return (needle => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n            const matched = len > 0 ? needle(input.src[input.start]) : false;\r\n\r\n            return (matched ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + 1,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                    templateArgs: input.templateArgs,\r\n                    templateArgsPos: input.templateArgsPos,\r\n                },\r\n                tokens: [helper(input.src[input.start])],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: `operator \"objClassByNeedleFn\"`,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function getObjectParsers<T extends ArrayLike<T[number]>, C, R>(\r\n        params: {\r\n            rawToToken: (rawToken: T[number]) => R,\r\n            concatTokens: (tokens: R[]) => R[],\r\n            comparator: (a: T[number], b: T[number]) => boolean,\r\n        }) {\r\n\r\n    const clsFn = objClassByNeedleFn<T, C, R>(params.rawToToken, params.comparator);\r\n\r\n    const isAny = clsFn(src => true);\r\n\r\n    // TODO: reduce unneccessary call for adding types.\r\n    return ({\r\n        seq: objSequence<T, C, R>(params.rawToToken, params.comparator),\r\n        cls: objClass<T, C, R>(params.rawToToken, params.comparator),\r\n        notCls: objClassNot<T, C, R>(params.rawToToken, params.comparator),\r\n        clsFn,\r\n        classes: {\r\n            any: isAny,\r\n        },\r\n        cat: transform<T, C, R>(params.concatTokens),\r\n        once: quantify<T, C, R>(1, 1),\r\n        repeat: quantify<T, C, R>(),\r\n        qty: (min?: number, max?: number) => quantify<T, C, R>(min, max), // TODO:\r\n        zeroWidth: (helper?: () => R) => zeroWidth<T, C, R>(helper),      // TODO:\r\n        err: (message: string) => zeroWidthError<T, C, R>(message),       // TODO:\r\n        beginning: (helper?: () => R) => beginning<T, C, R>(helper),      // TODO:\r\n        end: (helper?: () => R) => end<T, C, R>(helper),                  // TODO:\r\n        first: (...parsers: Array<ParserFnWithCtx<T, C, R>>) => first<T, C, R>(...parsers), // TODO:\r\n        or: (...parsers: Array<ParserFnWithCtx<T, C, R>>) => or<T, C, R>(...parsers),       // TODO:\r\n        combine: transform<T, C, R>(),\r\n        erase: transform<T, C, R>(tokens => []),\r\n        trans: (fn: (tokens: R[]) => R[]) => transform<T, C, R>(fn),                            // TODO:\r\n        ahead: (...parsers: Array<ParserFnWithCtx<T, C, R>>) => lookAhead<T, C, R>(...parsers), // TODO:\r\n        behind: (n: number, helper?: () => R) => lookBehind<T, C, R>(n, helper),\r\n        rules: (args: ApplyProductionRulesArg<T, C, R>) => applyProductionRules<T, C, R>(args), // TODO:\r\n        makeProgram,\r\n    });\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ParserInputWithCtx,\n         ParserFnWithCtx }       from 'fruitsconfits/modules/lib/types';\nimport { getStringParsers }      from 'fruitsconfits/modules/lib/string-parser';\nimport { getObjectParsers }      from 'fruitsconfits/modules/lib/object-parser';\nimport { SxTokenChild,\n         SxToken }               from 'liyad/modules/s-exp/types';\nimport { dummyTargetObject,\n         isUnsafeVarNames }      from './protection';\n\n\n\nexport interface SxOp {\n    'op': string;\n}\n\nexport type AstChild = SxTokenChild | SxOp | undefined;\nexport type Ast = SxToken | AstChild | SxOp | undefined;\n\n\ninterface Ctx {\n    docComment?: string;\n}\n\nconst $s = getStringParsers<Ctx, Ast>({\n    rawToToken: rawToken => rawToken,\n    concatTokens: tokens => (tokens.length ?\n        [tokens.reduce((a, b) => String(a) + b)] : []),\n});\n\nconst $o = getObjectParsers<Ast[], Ctx, Ast>({\n    rawToToken: rawToken => rawToken,\n    concatTokens: tokens => (tokens.length ?\n        [tokens.reduce((a, b) => String(a) + b)] : []),\n    comparator: (a, b) => a === b,\n});\n\nconst {seq, cls, notCls, clsFn, classes, numbers, cat,\n       once, repeat, qty, zeroWidth, err, beginning, end,\n       first, or, combine, erase, trans, ahead, rules,\n       makeProgram} = $s;\n\n\nconst directiveLineComment =\n    trans(tokens => [[{symbol: 'directive'}, ...tokens]])(\n        erase(qty(2)(cls('/'))),\n        erase(repeat(classes.space)),\n        cat(seq('@tynder-'), repeat(first(classes.alnum, cls('-')))), // [0]\n        erase(repeat(classes.space)),\n        cat(repeat(notCls('\\r\\n', '\\n', '\\r'))),                      // [1]\n        erase(first(classes.newline, ahead(end()))), );\n\nconst directiveBlockComment =\n    trans(tokens => [[{symbol: 'directive'}, ...tokens]])(\n        erase(seq('/*')),\n        erase(repeat(classes.space)),\n        cat(seq('@tynder-'), repeat(first(classes.alnum, cls('-')))), // [0]\n        erase(repeat(classes.space)),\n        cat(repeat(notCls('*/'))),                                    // [1]\n        erase(seq('*/')), );\n\n\nconst lineComment =\n    combine(\n        erase(qty(2)(cls('/'))),\n        first(\n            combine(\n                ahead(repeat(classes.space),\n                      notCls('@tynder-'), ),\n                repeat(notCls('\\r\\n', '\\n', '\\r')),\n                first(classes.newline, ahead(end())), ),\n            first(classes.newline, ahead(end())), ));\n\nconst hashLineComment =\n    combine(\n        seq('#'),\n        repeat(notCls('\\r\\n', '\\n', '\\r')),\n        first(classes.newline, ahead(end())), );\n\nconst docComment =\n    combine(\n        seq('/**'),\n        repeat(classes.space),\n        input => {\n            const ret = cat(repeat(notCls('*/')))(input);\n            if (ret.succeeded) {\n                // define a reducer\n                const ctx2 = {...ret.next.context}; // NOTE: context is immutable\n                ctx2.docComment = (ret.tokens[0] as string || '').trim();\n                ret.next.context = ctx2;\n            }\n            return ret;\n        },\n        seq('*/'), );\n\nconst blockComment =\n    combine(\n        seq('/*'),\n            ahead(repeat(classes.space),\n                  notCls('@tynder-'), ),\n            repeat(notCls('*/')),\n            seq('*/'), );\n\nconst commentOrSpace =\n    first(classes.space, lineComment, hashLineComment, docComment, blockComment);\n\n\nconst trueValue =\n    trans(tokens => [true])\n    (seq('true'));\n\nconst falseValue =\n    trans(tokens => [false])\n    (seq('false'));\n\nconst nullValue =\n    trans(tokens => [null])\n    (seq('null'));\n\nconst undefinedValue =\n    trans(tokens => [void 0])\n    (seq('undefined'));\n\nconst positiveInfinityValue =\n    trans(tokens => [Number.POSITIVE_INFINITY])\n    (qty(0, 1)(seq('+')), seq('Infinity'));\n\nconst negativeInfinityValue =\n    trans(tokens => [Number.NEGATIVE_INFINITY])\n    (seq('-Infinity'));\n\nconst nanValue =\n    trans(tokens => [Number.NaN])\n    (seq('NaN'));\n\n\nconst binaryIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 2)])\n    (numbers.bin(seq('0b')));\n\nconst octalIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 8)])\n    (numbers.oct(seq('0o'), seq('0')));\n\nconst hexIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 16)])\n    (numbers.hex(seq('0x'), seq('0X')));\n\nconst decimalIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 10)])\n    (numbers.int);\n\nconst bigDecimalIntegerValue =\n    trans(tokens => [BigInt((tokens as string[])[0].replace(/_/g, '')) as any])\n    (numbers.bigint);\n\nconst floatingPointNumberValue =\n    trans(tokens => [Number.parseFloat((tokens as string[])[0].replace(/_/g, ''))])\n    (numbers.float);\n\nconst numberValue =\n    first(octalIntegerValue,\n          hexIntegerValue,\n          binaryIntegerValue,\n          bigDecimalIntegerValue,\n          floatingPointNumberValue,\n          decimalIntegerValue,\n          positiveInfinityValue,\n          negativeInfinityValue,\n          nanValue, );\n\n\nconst stringEscapeSeq = first(\n    trans(t => ['\\''])(seq('\\\\\\'')),\n    trans(t => ['\\\"'])(seq('\\\\\"')),\n    trans(t => ['\\`'])(seq('\\\\`')),\n    trans(t => ['/'])(seq('\\\\/')),\n    trans(t => ['\\\\'])(seq('\\\\\\\\')),\n    trans(t => [''])(seq('\\\\\\r\\n')),\n    trans(t => [''])(seq('\\\\\\r')),\n    trans(t => [''])(seq('\\\\\\n')),\n    trans(t => ['\\n'])(seq('\\\\n')),\n    trans(t => ['\\r'])(seq('\\\\r')),\n    trans(t => ['\\v'])(seq('\\\\v')),\n    trans(t => ['\\t'])(seq('\\\\t')),\n    trans(t => ['\\b'])(seq('\\\\b')),\n    trans(t => ['\\f'])(seq('\\\\f')),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 16))])(\n        cat(erase(seq('\\\\u')),\n                qty(4, 4)(classes.hex), )),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 16))])(\n        cat(erase(seq('\\\\u{')),\n                qty(1, 6)(classes.hex),\n                erase(seq('}')), )),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 16))])(\n        cat(erase(seq('\\\\x')),\n                qty(2, 2)(classes.hex), )),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 8))])(\n        cat(erase(seq('\\\\')),\n                qty(3, 3)(classes.oct), )));\n\nconst signleQuotStringValue =\n    trans(tokens => [tokens[0] ?? ''])(\n        erase(seq(\"'\")),\n            cat(repeat(first(\n                stringEscapeSeq,\n                combine(cls('\\r', '\\n'), err('Line breaks within strings are not allowed.')),\n                notCls(\"'\"),\n            ))),\n        erase(seq(\"'\")), );\n\nconst doubleQuotStringValue =\n    trans(tokens => [tokens[0] ?? ''])(\n        erase(seq('\"')),\n            cat(repeat(first(\n                stringEscapeSeq,\n                combine(cls('\\r', '\\n'), err('Line breaks within strings are not allowed.')),\n                notCls('\"'),\n            ))),\n        erase(seq('\"')), );\n\nconst backQuotStringValue =\n    trans(tokens => [tokens[0] ?? ''])(\n        erase(seq('`')),\n            cat(repeat(first(\n                stringEscapeSeq,\n                notCls('`'),\n            ))),\n        erase(seq('`')), );\n\nconst stringValue =\n    first(signleQuotStringValue, doubleQuotStringValue, backQuotStringValue);\n\nconst regexpStringValue =\n    // TODO: '/' ']' '\\\\' in character class '[]' is not parsed correctly.\n    trans(tokens => [{value: tokens[1] ?\n            new RegExp((tokens[0] ?? '') as string, tokens[1] as string) :\n            new RegExp((tokens[0] ?? '') as string)}])(\n        erase(seq('/')),\n            cat(repeat(first(\n                stringEscapeSeq,\n                notCls('/'),\n            ))),\n        erase(seq('/')),\n        cat(qty(0)(cls('g', 'i', 'm', 's', 'u', 'y'))), );\n\n\nconst symbolName =\n    trans(tokens => tokens)\n    (cat(combine(\n        first(classes.alpha, cls('$', '_')),\n        repeat(first(classes.alnum, cls('$', '_'))), )));\n\nconst decoratorSymbolName =\n    trans(tokens => [{symbol: (tokens as string[])[0]}])\n    (cat(combine(\n        seq('@'),\n        first(classes.alpha, cls('$', '_')),\n        repeat(first(classes.alnum, cls('$', '_'))), )));\n\n\nconst simpleConstExpr =\n    first(trueValue, falseValue, nullValue, undefinedValue,\n          numberValue, stringValue, );\n\nconst objKey =\n    first(stringValue, symbolName);\n\nconst listValue = first(\n    trans(tokens => [[]])(erase(\n        seq('['),\n            repeat(commentOrSpace),\n        seq(']'), )),\n    trans(tokens => {\n        const ast: Ast = [{symbol: '$list'}];\n        for (const token of tokens) {\n            ast.push(token as any);\n        }\n        return [ast];\n    })(\n        erase(seq('[')),\n            combine(\n                erase(repeat(commentOrSpace)),\n                first(input => listValue(input),   // NOTE: recursive definitions\n                      input => objectValue(input), //       should place as lambda.\n                      simpleConstExpr,\n                      ),\n                erase(repeat(commentOrSpace)), ),\n            repeat(combine(\n                erase(repeat(commentOrSpace),\n                      seq(','),\n                      repeat(commentOrSpace)),\n                first(input => listValue(input),   // NOTE: recursive definitions\n                      input => objectValue(input), //       should place as lambda.\n                      simpleConstExpr,\n                      ),\n                erase(repeat(commentOrSpace)), )),\n            qty(0, 1)(erase(\n                seq(','),\n                repeat(commentOrSpace), )),\n            first(ahead(seq(']')), err('listValue: Unexpected token has appeared.')),\n        erase(seq(']')),\n    ), );\n\nconst objectKeyValuePair =\n    combine(\n        objKey,\n        erase(repeat(commentOrSpace),\n              first(seq(':'), err('\":\" is needed.')),\n              repeat(commentOrSpace)),\n        first(input => listValue(input),   // NOTE: recursive definitions\n              input => objectValue(input), //       should place as lambda.\n              simpleConstExpr,\n              err('object value is needed.')), );\n\nconst objectValue = first(\n    trans(tokens => [[{symbol: '#'}]])(erase(\n        seq('{'),\n            repeat(commentOrSpace),\n        seq('}'),\n    )),\n    trans(tokens => {\n        const ast: Ast = [{symbol: '#'}];\n        for (let i = 0; i < tokens.length; i += 2) {\n            if (isUnsafeVarNames(dummyTargetObject, tokens[i] as string)) {\n                throw new Error(`Unsafe symbol name is appeared in object literal: ${tokens[i]}`);\n            }\n            ast.push([tokens[i], tokens[i + 1]]);\n        }\n        return [ast];\n    })(\n        erase(seq('{')),\n            combine(\n                erase(repeat(commentOrSpace)),\n                objectKeyValuePair,\n                erase(repeat(commentOrSpace)), ),\n            repeat(combine(\n                erase(seq(','),\n                      repeat(commentOrSpace)),\n                objectKeyValuePair,\n                erase(repeat(commentOrSpace)), )),\n            qty(0, 1)(erase(\n                seq(','),\n                repeat(commentOrSpace), )),\n            first(ahead(seq('}')), err('objectValue: Unexpected token has appeared.')),\n        erase(seq('}')),\n    ), );\n\nconst constExpr =\n    first(simpleConstExpr,\n          listValue,\n          objectValue, );\n\n\n// const primitiveValue = trans(tokens => [[{symbol: 'primitiveValue'}, tokens[0]]])(\n//     first(trueValue, falseValue, nullValue, undefinedValue,\n//           numberValue, stringValue, ));\n\nconst primitiveValueNoNullUndefined =\n    trans(tokens => [[{symbol: 'primitiveValue'}, tokens[0]]])(\n        first(trueValue, falseValue,\n              numberValue, stringValue, ));\n\n\nconst primitiveTypeName =\n    trans(tokens => [[{symbol: 'primitive'}, tokens[0]]])(\n        first(seq('number?'), seq('integer?'), seq('bigint?'), seq('string?'), seq('boolean?'), // TODO: '?' is allowed in the sequence assertion\n              seq('number'), seq('integer'), seq('bigint'), seq('string'), seq('boolean'), ));  // TODO: function\n\nconst additionalPropPrimitiveTypeName =\n    first(seq('number'), seq('string'));\n\nconst nullUndefinedTypeName =\n    trans(tokens => [[{symbol: 'primitive'}, tokens[0]]])(\n        first(seq('null'), seq('undefined'), seq('any'), seq('unknown'), seq('never')), );\n\nconst simpleOrDottedTypeName =\n    first(primitiveTypeName,\n          nullUndefinedTypeName,\n          trans(tokens =>\n                [[{symbol: 'ref'}, ...tokens]])(\n            ahead(notCls('Array', 'Partial', 'Pick', 'Omit')),\n            combine(\n                symbolName,\n                repeat(combine(\n                    erase(repeat(commentOrSpace), seq('.'), repeat(commentOrSpace)),\n                    symbolName, )))));\n\n\nconst sequenceType =\n    trans(tokens => [[{symbol: 'sequenceOf'}, ...tokens]])(\n        combine(\n            erase(seq('[')),\n                combine(\n                    erase(repeat(commentOrSpace)),\n                    input => spreadOrComplexType(first(seq(','), seq(']')))(input),\n                    erase(repeat(commentOrSpace)), ),\n                repeat(combine(\n                    erase(seq(','),\n                        repeat(commentOrSpace)),\n                    input => spreadOrComplexType(first(seq(','), seq(']')))(input),\n                    erase(repeat(commentOrSpace)), )),\n                qty(0, 1)(erase(\n                    seq(','),\n                    repeat(commentOrSpace), )),\n                first(ahead(seq(']')), err('sequenceType: Unexpected token has appeared.')),\n            erase(seq(']')), ));\n\n\nconst arraySizeFactorInner =\n    first(\n        trans(tokens => [[{symbol: '#'}, ['max', tokens[0]]]])(\n            erase(seq('..')),\n            erase(repeat(commentOrSpace)),\n            decimalIntegerValue, ),\n        trans(tokens => [[{symbol: '#'}, ['min', tokens[0]], ['max', tokens[1]]]])(\n            decimalIntegerValue,\n            erase(repeat(commentOrSpace)),\n            erase(seq('..')),\n            erase(repeat(commentOrSpace)),\n            decimalIntegerValue, ),\n        trans(tokens => [[{symbol: '#'}, ['min', tokens[0]]]])(\n            decimalIntegerValue,\n            erase(repeat(commentOrSpace)),\n            erase(seq('..')), ),\n        trans(tokens => [[{symbol: '#'}, ['min', tokens[0]], ['max', tokens[0]]]])(\n            decimalIntegerValue, ));\n\nconst arraySizeFactor =\n    trans(tokens =>\n        tokens.length > 0 ?\n            tokens :\n            [[{symbol: '#'}]])(\n        erase(seq('[')),\n            erase(repeat(commentOrSpace)),\n            qty(0, 1)(arraySizeFactorInner),\n            erase(repeat(commentOrSpace)),\n        erase(seq(']')), );\n\nconst complexArrayType =\n    trans(tokens => [[{symbol: 'repeated'}, tokens[0], tokens[1]]])(\n        erase(seq('Array')),\n        erase(repeat(commentOrSpace)),\n        erase(seq('<')),\n            erase(repeat(commentOrSpace)),\n            first(input => complexType(first(seq(','), seq('>')))(input),\n                  err('type is expected in Array type.'), ),        // [0]\n            erase(repeat(commentOrSpace)),\n            qty(0, 1)(combine(\n                erase(seq(',')),\n                erase(repeat(commentOrSpace)),\n                first(arraySizeFactorInner,                         // [1]\n                      err('complexArrayType: Unexpected token has appeared. Expect array size.'), ),\n                erase(repeat(commentOrSpace)), )),\n        first(ahead(seq('>')),\n              err('\\'>\\' is expected in Array type.'), ),\n        erase(seq('>')), );\n\nconst partialType =\n    trans(tokens => [[{symbol: 'partial'}, tokens[0], tokens[1]]])(\n        erase(seq('Partial')),\n        erase(repeat(commentOrSpace)),\n        erase(seq('<')),\n            erase(repeat(commentOrSpace)),\n            first(input => complexType(first(seq(','), seq('>')))(input),\n                  err('type is expected in Partial type.'), ),      // [0]\n            erase(repeat(commentOrSpace)),\n        first(ahead(seq('>')),\n              err('\\'>\\' is expected in Partial type.'), ),\n        erase(seq('>')), );\n\nconst pickOrOmitType =\n    trans(tokens => [[{symbol: tokens[0] === 'Pick' ? 'picked' : 'omit'}, tokens[1], ...tokens.slice(2)]])(\n        first(seq('Pick'),\n              seq('Omit'), ),                                       // [0]\n        erase(repeat(commentOrSpace)),\n        erase(seq('<')),\n            erase(repeat(commentOrSpace)),\n            first(input => complexType(first(seq(','), seq('>')))(input),\n                  err('type is expected in Partial type.'), ),      // [1]\n            erase(repeat(commentOrSpace)),\n            combine(\n                erase(seq(',')),\n                erase(repeat(commentOrSpace)),\n                    stringValue,                                    // [2]\n                    qty(0)(combine(\n                        erase(repeat(commentOrSpace)),\n                        erase(seq('|')),\n                        erase(repeat(commentOrSpace)),\n                        stringValue, )),                            // [3],...\n                erase(repeat(commentOrSpace)), ),\n        first(ahead(seq('>')),\n              err('\\'>\\' is expected in Pick|Omit type.'), ),\n        erase(seq('>')), );\n\nconst genericOrSimpleType =\n    trans(tokens => [tokens[0]])(                     // remove generics parameters\n        simpleOrDottedTypeName,                       // [0]\n        erase(repeat(commentOrSpace)),\n        qty(0, 1)(combine(\n            erase(seq('<')),\n                combine(                              // [1]\n                    erase(repeat(commentOrSpace)),\n                    first(input => complexType(first(seq(','), seq('>')))(input),\n                          err('type is expected in generic type.'), ),\n                    erase(repeat(commentOrSpace)), ),\n                repeat(combine(                       // [2]...\n                    erase(seq(','),\n                          repeat(commentOrSpace)),\n                    first(input => complexType(first(seq(','), seq('>')))(input),\n                          err('type is expected in generic type.'), ),\n                    erase(repeat(commentOrSpace)), )),\n                qty(0, 1)(erase(\n                    seq(','),\n                    repeat(commentOrSpace), )),\n                first(ahead(seq('>')), err('genericType: Unexpected token has appeared.')),\n            erase(seq('>')), )));\n\nconst spreadType =\n    trans(tokens => [[{symbol: 'spread'}, tokens[0], tokens[1]]])(\n        erase(seq('...')),\n        erase(repeat(commentOrSpace)),\n        erase(seq('<')),\n            erase(repeat(commentOrSpace)),\n            input => complexType(first(seq(','), seq('>')))(input),\n            erase(repeat(commentOrSpace)),\n            qty(0, 1)(combine(\n                erase(seq(',')),\n                erase(repeat(commentOrSpace)),\n                first(arraySizeFactorInner,\n                      err('spreadType: Unexpected token has appeared. Expect array size.'), ),\n                erase(repeat(commentOrSpace)), )),\n            first(ahead(seq('>')), err('spreadType: Unexpected token has appeared.')),\n        erase(seq('>')), );\n\n\nconst decorator =\n    trans(tokens => [tokens])(\n        decoratorSymbolName,\n        qty(0, 1)(first(\n            combine(erase(\n                seq('('),\n                    repeat(commentOrSpace),\n                seq(')'), )),\n            combine(\n                erase(seq('(')),\n                    first(\n                        combine(\n                            combine(\n                                erase(repeat(commentOrSpace)),\n                                first(regexpStringValue, constExpr),\n                                erase(repeat(commentOrSpace)), ),\n                            repeat(combine(\n                                erase(repeat(commentOrSpace)),\n                                erase(seq(',')),\n                                erase(repeat(commentOrSpace)),\n                                first(regexpStringValue, constExpr),\n                                erase(repeat(commentOrSpace)), )),\n                            qty(0, 1)(erase(\n                                seq(','),\n                                repeat(commentOrSpace), )),\n                            first(ahead(seq(')')), err('decorator: Unexpected token has appeared. Expect \")\".')), ),\n                        err('decorator: Unexpected token has appeared.'), ),\n                erase(seq(')')),\n            ), )));\n\nconst decoratorsClause =\n    trans(tokens => tokens)(\n        repeat(combine(\n            decorator,\n            erase(repeat(commentOrSpace)), )));\n\n\nconst complexTypeInnerWOSinpleArrayType = (edge: ParserFnWithCtx<string, Ctx, Ast>) =>\n    first(primitiveValueNoNullUndefined,\n          genericOrSimpleType,\n          partialType,\n          pickOrOmitType,\n          complexArrayType,\n          sequenceType,\n          input => interfaceDefInner(first(seq(';'), seq(',')))(input), );\n\nconst complexTypeInnerRoot: (separator: ParserFnWithCtx<string, Ctx, Ast>) => ParserFnWithCtx<string, Ctx, Ast> =\n    (edge: ParserFnWithCtx<string, Ctx, Ast>) =>\n    trans(tokens => {\n            let ty = [{symbol: '$pipe'}, tokens[1], ...(tokens[0] as Ast[])];\n            if (tokens[2] !== null) {\n                for (const z of tokens[2] as Ast[]) {\n                    ty = [{symbol: 'repeated'}, ty, z];\n                }\n            }\n            return ([[\n                ty,\n                ...(tokens[3] ? [tokens[3]] : []),\n                ...tokens.slice(4),\n            ]]);\n        })(\n        trans(tokens => [tokens])(qty(0, 1)(decoratorsClause)),          // [0]\n        first(                                                           // [1]\n            input => complexTypeInnerWOSinpleArrayType(edge)(input),\n            combine(\n                erase(seq('(')),\n                    erase(repeat(commentOrSpace)),\n                    input => complexType(edge)(input),\n                    erase(repeat(commentOrSpace)),\n                erase(seq(')')), )),\n        combine(\n            trans(tokens => tokens[0] !== null ? [tokens] : [null])(     // [2]\n                first(\n                    qty(1)(combine(\n                        erase(repeat(commentOrSpace)),\n                        arraySizeFactor, )),\n                    zeroWidth(() => null), )),\n            combine(first(                                               // [3]...\n                trans(tokens => [tokens[0], ...(tokens[1] as Ast[])])(\n                    qty(1)(combine(\n                        erase(repeat(commentOrSpace)),\n                        trans(tokens => [{op: tokens[0]} as any])(or(seq('&'), seq('|'), seq('-'))),\n                        erase(repeat(commentOrSpace)),\n                        input => complexTypeInnerRoot(edge)(input), ))),\n                trans(tokens => [])(), ))));\n\n\nconst binaryOp = (op: string, op1: any, op2: any) => {\n    return [{symbol: op}, op1, op2];\n};\n\nconst isOperator = (v: any, op: string) => {\n    if (typeof v === 'object' && v.op === op) {\n        return true;\n    }\n    return false;\n};\n\nconst isValue = (v: any) => {\n    // TODO: check type\n    return true;\n};\n\n\n// production rules:\n//   S -> S \"&\" S\nconst complexTypeExprRule3 = $o.trans(tokens => [binaryOp('intersect', tokens[0], tokens[2])])(\n    $o.clsFn(t => isValue(t)),\n    $o.clsFn(t => isOperator(t, '&')),\n    $o.clsFn(t => isValue(t)),\n);\n\n// production rules:\n//   S -> S \"|\" S\nconst complexTypeExprRule2 = $o.trans(tokens => [binaryOp('oneOf', tokens[0], tokens[2])])(\n    $o.clsFn(t => isValue(t)),\n    $o.clsFn(t => isOperator(t, '|')),\n    $o.clsFn(t => isValue(t)),\n);\n\n// production rules:\n//   S -> S \"-\" S\nconst complexTypeExprRule1 = $o.trans(tokens => [binaryOp('subtract', tokens[0], tokens[2])])(\n    $o.clsFn(t => isValue(t)),\n    $o.clsFn(t => isOperator(t, '-')),\n    $o.clsFn(t => isValue(t)),\n);\n\nconst complexType = (edge: ParserFnWithCtx<string, Ctx, Ast>) => rules({\n    rules: [\n        complexTypeExprRule3,\n        complexTypeExprRule2,\n        complexTypeExprRule1,\n    ],\n    check: $o.combine($o.classes.any, $o.end()),\n})(trans(tokens => tokens[0] as Ast[])(complexTypeInnerRoot(edge)));\n\n\nconst spreadOrComplexType: (separator: ParserFnWithCtx<string, Ctx, Ast>) => ParserFnWithCtx<string, Ctx, Ast> =\n    (edge: ParserFnWithCtx<string, Ctx, Ast>) =>\n    first(spreadType, complexType(edge));\n\n\nconst setDocComment = (input: ParserInputWithCtx<string, Ctx>) => {\n    const ret = zeroWidth(() => [])(input);\n    if (ret.succeeded) {\n        const text = ret.next.context.docComment;\n        ret.next.context = {...ret.next.context};\n        delete ret.next.context.docComment;\n        ret.tokens.length = 0;\n        ret.tokens.push(text ? text : null);\n    }\n    return ret;\n};\n\n\nconst typeDef =\n    trans(tokens => [[{symbol: 'def'}, tokens[1], [{symbol: 'docComment'}, tokens[2], tokens[0] ] ]])(\n        erase(seq('type')),\n            setDocComment,                                           // [0]\n            erase(qty(1)(commentOrSpace)),\n            first(symbolName,                                        // [1]\n                  err('typeDef: Unexpected token has appeared. Expect symbol name.'), ),\n            erase(repeat(commentOrSpace)),\n        first(ahead(seq('=')), err('typeDef: Unexpected token has appeared. Expect \"=\".')),\n        erase(seq('=')),\n            first(\n                combine(erase(repeat(commentOrSpace)),\n                        input => complexType(first(seq(','), seq(';')))(input),  // [2]\n                        erase(repeat(commentOrSpace)), ),\n                err('typeDef: Unexpected token has appeared.'), ),\n        first(ahead(seq(';')), err('typeDef: Unexpected token has appeared. Expect \";\".')),\n        erase(seq(';')), );\n\n\nconst interfaceExtendsClause =\n    trans(tokens => [\n            [{symbol: '$list'},\n                ...tokens.map(x => [{symbol: 'ref'}, x])], ])(\n        erase(first(\n            seq('extends'),\n            combine(symbolName,\n                    err('interfaceExtendsClause: Unexpected token has appeared. Expect \"extends\" keyword.'), ))),\n        erase(qty(1)(commentOrSpace)),\n        first(symbolName,\n              err('interfaceExtendsClause: Unexpected token has appeared. Expect symbol name.'), ),\n        repeat(combine(\n            erase(repeat(commentOrSpace)),\n            erase(seq(',')),\n            erase(repeat(commentOrSpace)),\n            first(symbolName,\n                  err('interfaceExtendsClause: Unexpected token has appeared. Expect symbol name.'), ))));\n\nconst interfaceKey =\n    first(\n        trans(tokens => [[{symbol: '$list'}, ...tokens]])(\n            erase(seq('[')),\n                erase(repeat(commentOrSpace),\n                      objKey,\n                      repeat(commentOrSpace),\n                      first(seq(':'), err('\":\" is needed.')),\n                      repeat(commentOrSpace), ),\n                repeat(combine(\n                    first(regexpStringValue,\n                          additionalPropPrimitiveTypeName, ),\n                    erase(repeat(commentOrSpace),\n                          seq('|'),\n                          repeat(commentOrSpace), ))),\n                first(regexpStringValue,\n                      additionalPropPrimitiveTypeName, ),\n                erase(repeat(commentOrSpace)),\n                first(ahead(seq(']')), err('interfaceKey: Unexpected token has appeared. Expect \"]\".')),\n            erase(seq(']')), ),\n        objKey, );\n\nconst interfaceKeyTypePair = (separator: ParserFnWithCtx<string, Ctx, Ast>) =>\n    trans(tokens => [\n            [{symbol: '$list'},\n                tokens[2],\n                [{symbol: '$pipe'},\n                    tokens[3] === '?' ?\n                        [{symbol: 'optional'}, tokens[4]] :\n                        tokens[4], ...(tokens[0] as Ast[]), ],\n                tokens[1], ]])(\n        trans(tokens => [tokens])(first(\n            decoratorsClause,\n            zeroWidth(() => []), )),                // [0] decorators\n        setDocComment,                              // [1]\n        interfaceKey,                               // [2] key\n        first(                                      // [3] '?' | ''\n            combine(\n                erase(repeat(commentOrSpace)),\n                seq('?'),\n                erase(repeat(commentOrSpace)), ),\n            zeroWidth(() => ['']), ),\n        erase(repeat(commentOrSpace),\n            first(seq(':'), err('\":\" is needed.')),\n            repeat(commentOrSpace), ),\n        first(                                      // [4] type\n            input => complexType(first(separator, seq('}')))(input),\n            err('interface member type is needed.'), ));\n\nconst interfaceDefInner: (separator: ParserFnWithCtx<string, Ctx, Ast>) => ParserFnWithCtx<string, Ctx, Ast> =\n    (separator: ParserFnWithCtx<string, Ctx, Ast>) =>\n    trans(tokens => [[{symbol: 'objectType'}, ...tokens]])(\n        first(\n            combine(erase(\n                seq('{'),\n                    repeat(commentOrSpace),\n                seq('}'), )),\n            combine(\n                erase(seq('{')),\n                    combine(\n                        erase(repeat(commentOrSpace)),\n                        interfaceKeyTypePair(separator),\n                        erase(repeat(commentOrSpace)), ),\n                    repeat(combine(\n                        erase(separator,\n                              repeat(commentOrSpace)),\n                        interfaceKeyTypePair(separator),\n                        erase(repeat(commentOrSpace)), )),\n                    qty(0, 1)(erase(\n                        separator,\n                        repeat(commentOrSpace), )),\n                    first(ahead(seq('}')), err('interfaceDefInner: Unexpected token has appeared. Expect \"}\".')),\n                erase(seq('}')), )));\n\nconst interfaceDef =\n    trans(tokens => [\n        [{symbol: 'def'},\n            tokens[1],\n            [{symbol: 'docComment'},\n                [{symbol: 'derived'}, tokens[3], [{symbol: '$spread'}, tokens[2]]],\n                tokens[0], ]]])(\n    erase(seq('interface')),\n        setDocComment,                           // [0] base types\n        erase(qty(1)(commentOrSpace)),\n        first(symbolName,                        // [1] symbol\n              err('interfaceDef: Unexpected token has appeared. Expect symbol name.'), ),\n        erase(repeat(commentOrSpace)),\n        first(interfaceExtendsClause,            // [2]\n              zeroWidth(() => []), ),\n        erase(repeat(commentOrSpace)),\n    first(\n        input => interfaceDefInner(\n            first(seq(';'), seq(',')), )(input), // [3]\n        err('interfaceDef: Unexpected token has appeared.'), ),\n);\n\n\nconst enumKeyValue =\n    trans(tokens => [[{symbol: '$list'}, tokens[1], tokens[2], tokens[0]]])(\n        setDocComment,                           // [0]\n        symbolName,\n        erase(repeat(commentOrSpace)),\n        first(\n            combine(\n                erase(seq('=')),\n                first(\n                    combine(erase(repeat(commentOrSpace)),\n                            first(decimalIntegerValue,\n                                  stringValue, ),\n                            erase(repeat(commentOrSpace)), ),\n                    err('enumKeyValue: Unexpected token has appeared.'), )),\n            zeroWidth(() => null), ));\n\nconst enumDef =\n    trans(tokens => [\n        [{symbol: 'def'}, tokens[1],\n            [{symbol: 'docComment'},\n                [{symbol: 'enumType'}, ...tokens.slice(2)],\n                tokens[0], ]]])(\n    erase(seq('enum')),\n        setDocComment,                           // [0]\n        erase(qty(1)(commentOrSpace)),\n        first(symbolName,\n              err('enumDef: Unexpected token has appeared. Expect symbol name.'), ),\n        erase(repeat(commentOrSpace)),\n    first(\n        combine(erase(\n            seq('{'),\n                repeat(commentOrSpace),\n            seq('}'), )),\n        combine(\n            erase(seq('{')),\n                combine(\n                    erase(repeat(commentOrSpace)),\n                    enumKeyValue,\n                    erase(repeat(commentOrSpace)), ),\n                repeat(combine(\n                    erase(seq(','),\n                          repeat(commentOrSpace)),\n                    enumKeyValue,\n                    erase(repeat(commentOrSpace)), )),\n                qty(0, 1)(erase(\n                    seq(','),\n                    repeat(commentOrSpace), )),\n                first(ahead(seq('}')), err('enumDef: Unexpected token has appeared. Expect \"}\".')),\n            erase(seq('}')), ),\n        err('enumDef: Unexpected token has appeared.'), ));\n\n\nconst internalDef =\n    first(typeDef,\n          interfaceDef,\n          enumDef, );\n\n\nconst constDef =\n    trans(tokens => [[{symbol: 'asConst'}, tokens[0]]])(\n        erase(seq('const'),\n              qty(1)(commentOrSpace), ),\n        first(enumDef,\n              err('constDef: Unexpected token has appeared.'), ));\n\nconst constDefNoErr =\n    trans(tokens => [[{symbol: 'asConst'}, tokens[0]]])(\n        erase(seq('const'),\n              qty(1)(commentOrSpace), ),\n        first(enumDef), );\n\n\nconst exportedDef =\n    trans(tokens => [[{symbol: 'export'}, tokens[0]]])(\n        erase(seq('export'),\n              qty(1)(commentOrSpace), ),\n        first(constDef,\n              internalDef,\n              input => declareTypeAndEnumStatement(input),\n              input => declareVarStatement(input),\n              err('exportedDef: Unexpected token has appeared.'), ));\n\n\nconst defStatement =\n    trans(tokens => [\n        [{symbol: '$local'}, [\n                [{symbol: '_ty'}, tokens[1]],\n            ],\n            [{symbol: 'redef'},\n                {symbol: '_ty'},\n                [{symbol: '$pipe'}, {symbol: '_ty'}, ...(tokens[0] as Ast[])], ]]])(\n        trans(tokens => [tokens])(first(\n            decoratorsClause,\n            zeroWidth(() => []), )),      // [0] decorators\n        first(exportedDef,                // [1] body\n              input => declareTypeAndEnumStatement(input),\n              constDef,\n              internalDef, ));\n\n\nconst externalSymbolAndType =\n    trans(tokens => [[{symbol: '$list'}, ...tokens]])(\n        symbolName,\n        erase(repeat(commentOrSpace)),\n        qty(0, 1)(\n            combine(erase(seq(':')),\n                    erase(repeat(commentOrSpace)),\n                    input => complexType(first(seq(';'), seq(',')))(input), )));\n\n\nexport const externalTypeDef =\n    trans(tokens => [[{symbol: 'external'}, ...tokens]])(\n        erase(seq('external')),\n            erase(qty(1)(commentOrSpace)),\n            externalSymbolAndType,\n            repeat(combine(\n                erase(repeat(commentOrSpace)),\n                erase(cls(',')),\n                erase(repeat(commentOrSpace)),\n                first(externalSymbolAndType,\n                      err('externalTypeDef: Unexpected token has appeared. Expect symbol name.'), ),\n                erase(repeat(commentOrSpace)),\n            )),\n            erase(repeat(commentOrSpace)),\n        first(ahead(cls(';')), err('externalTypeDef: Unexpected token has appeared. Expect \";\".')),\n        erase(cls(';')), );\n\n\nconst declareTypeAndEnumStatement =\n    trans(tokens => [[{symbol: 'asDeclare'}, ...tokens]])(\n        erase(seq('declare')),\n        erase(qty(1)(commentOrSpace)),\n        first(constDefNoErr,  // NOTE: There is still the possibility of \"const varName\". -> `declareVarStatement` will be called.\n              internalDef), );\n\n\nconst declareVarStatement =\n    trans(tokens => [[{symbol: 'passthru'}, tokens[0], tokens[1]]])(\n        cat(seq('declare'),\n            qty(1)(commentOrSpace),\n            first(seq('var'),\n                  seq('let'),\n                  seq('const'),\n                  err('declareVarStatement: Unexpected token has appeared. Expect \"var|let|const\".') ),\n            qty(1)(commentOrSpace),\n            cat(repeat(notCls(';'))),\n            first(ahead(seq(';')), err('declareVarStatement: Unexpected token has appeared. Expect \";\".')),\n            cls(';'), ),\n        setDocComment, );       // [1]\n\n\nconst importStatement =\n    trans(tokens => [[{symbol: 'passthru'}, tokens[0]]])(\n        cat(seq('import'),\n            qty(1)(commentOrSpace),\n            cat(repeat(notCls(';'))),\n            first(ahead(seq(';')), err('importStatement: Unexpected token has appeared. Expect \";\".')),\n            cls(';'), ));\n\n\nconst definition =\n    first(directiveLineComment,\n          directiveBlockComment,\n          defStatement,\n          externalTypeDef,\n          declareVarStatement,\n          importStatement, );\n\nexport const program =\n    makeProgram(combine(\n        erase(repeat(commentOrSpace)),\n        repeat(combine(\n            definition,\n            erase(repeat(commentOrSpace)), )),\n        erase(repeat(commentOrSpace)),\n        first(ahead(end()), err('program: Unexpected token has appeared.')),\n        end(), ));\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { parserInput }           from 'fruitsconfits/modules/lib/types';\nimport { formatErrorMessage }    from 'fruitsconfits/modules/lib/parser';\nimport { SxToken,\n         SxSymbol,\n         SxParserConfig }        from 'liyad/modules/s-exp/types';\nimport installCore               from 'liyad/modules/s-exp/operators/core';\nimport { SExpression }           from 'liyad/modules/s-exp/interpreters';\nimport { defaultConfig }         from 'liyad/modules/s-exp/defaults';\nimport { TypeAssertion,\n         PrimitiveTypeAssertion,\n         ErrorMessages,\n         TypeAssertionSetValue,\n         TypeAssertionMap }      from './types';\nimport * as operators            from './operators';\nimport { resolveMemberNames,\n         resolveSchema }         from './lib/resolver';\nimport { dummyTargetObject,\n         isUnsafeVarNames }      from './lib/protection';\nimport { externalTypeDef,\n         program }               from './lib/compiler';\n\n\n\nfunction parseExternalDirective(s: string) {\n    const z = externalTypeDef(parserInput(s, {/* TODO: set initial state to the context */}));\n    if (! z.succeeded) {\n        throw new Error('Invalid external directive.');\n    }\n    return z.tokens;\n}\n\n\nexport function parse(s: string) {\n    const z = program(parserInput(s, {/* TODO: set initial state to the context */}));\n    if (! z.succeeded) {\n        throw new Error(formatErrorMessage(z));\n    }\n    return z.tokens;\n}\n\n\nconst lisp = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n    config = installCore(config);\n    config.stripComments = true;\n    return SExpression(config);\n})();\n\n\n// tslint:disable: object-literal-key-quotes\nexport function compile(s: string) {\n    const mapTyToTySet = new Map<TypeAssertion, TypeAssertionSetValue>();\n    const schema: TypeAssertionMap = new Map<string, TypeAssertionSetValue>();\n    let gensymCount = 0;\n\n    const def = (name: SxSymbol | string, ty: TypeAssertion): TypeAssertion => {\n        let ret = ty;\n\n        const sym = typeof name === 'string' ? name : name.symbol;\n        if (isUnsafeVarNames(dummyTargetObject, sym)) {\n            throw new Error(`Unsafe symbol name is appeared: ${sym}`);\n        }\n\n        if (! mapTyToTySet.has(ret)) {\n            const originalTypeName = ret.typeName;\n            ret = operators.withName(operators.withTypeName(\n                originalTypeName ?\n                    operators.withOriginalTypeName(ret, originalTypeName) :\n                    ret,\n                sym), sym);\n        }\n\n        const tySet = mapTyToTySet.has(ret) ?\n            mapTyToTySet.get(ret) as TypeAssertionSetValue :\n            {ty: ret, exported: false, isDeclare: false, resolved: false};\n\n        schema.set(sym, tySet);\n\n        if (! mapTyToTySet.has(ret)) {\n            // TODO: aliases are not exported correctly\n            mapTyToTySet.set(ret, tySet);\n        }\n        return ret;\n    };\n\n    const ref = (name: SxSymbol | string, ...memberNames: (SxSymbol | string)[]): TypeAssertion => {\n        const sym = typeof name === 'string' ? name : name.symbol;\n        if (isUnsafeVarNames(dummyTargetObject, sym)) {\n            throw new Error(`Unsafe symbol name is appeared: ${sym}`);\n        }\n\n        const memberTreeSymbols = memberNames.map(x => {\n            const ms = typeof x === 'string' ? x : x.symbol;\n            if (isUnsafeVarNames(dummyTargetObject, ms)) {\n                throw new Error(`Unsafe symbol name is appeared: ${ms}`);\n            }\n            return ms;\n        });\n\n        if (! schema.has(sym)) {\n            return ({\n                ...{\n                    kind: 'symlink',\n                    symlinkTargetName: sym,\n                    name: sym,\n                    typeName: sym,\n                },\n                ...(0 < memberTreeSymbols.length ? {\n                    memberTree: memberTreeSymbols,\n                } : {}),\n            });\n        }\n\n        let ty = resolveMemberNames(\n            (schema.get(sym) as TypeAssertionSetValue).ty,\n            sym, memberTreeSymbols,\n            0,\n        );\n\n        if (ty.noOutput) {\n            ty = {...ty};\n            delete ty.noOutput;\n        }\n        return ty;\n    };\n\n    const redef = (original: TypeAssertion, ty: TypeAssertion) => {\n        if (original === ty) {\n            return ty;\n        }\n        // NOTE: 'ty' should already be registered to 'mapTyToTySet' and 'schema'\n        const tySet = mapTyToTySet.has(original) ?\n            mapTyToTySet.get(original) as TypeAssertionSetValue :\n            {ty: original, exported: false, isDeclare: false, resolved: false};\n        tySet.ty = ty;\n        mapTyToTySet.set(tySet.ty, tySet);\n        if (ty.name) {\n            schema.set(ty.name, tySet);\n        }\n        return tySet.ty;\n    };\n\n    const exported = (ty: TypeAssertion) => {\n        if (ty.kind === 'never' && typeof ty.passThruCodeBlock === 'string') {\n            ty.passThruCodeBlock = `export ${ty.passThruCodeBlock}`;\n            return ty;\n        } else {\n            // NOTE: 'ty' should already be registered to 'mapTyToTySet' and 'schema'\n            const tySet = mapTyToTySet.has(ty) ?\n                mapTyToTySet.get(ty) as TypeAssertionSetValue :\n                {ty, exported: false, isDeclare: false, resolved: false};\n            tySet.exported = true;\n            return ty;\n        }\n    };\n\n    const external = (...names: (string | [string, TypeAssertion?])[]) => {\n        for (const name of names) {\n            let ty: TypeAssertion = null as any;\n            if (typeof name === 'string') {\n                ty = def(name, operators.primitive('any'));\n            } else {\n                ty = def(name[0], name[1] ? name[1] : operators.primitive('any'));\n            }\n            ty.noOutput = true;\n        }\n    };\n\n    const asConst = (ty: TypeAssertion) => {\n        switch (ty.kind) {\n        case 'enum':\n            // NOTE: `ty` may already `def`ed.\n            ty.isConst = true;\n            break;\n        default:\n            throw new Error(`It cannot set to const: ${ty.kind} ${ty.typeName || '(unnamed)'}`);\n        }\n        return ty;\n    };\n\n    const asDeclare = (ty: TypeAssertion) => {\n        // NOTE: 'ty' should already be registered to 'mapTyToTySet' and 'schema'\n        const tySet = mapTyToTySet.has(ty) ?\n            mapTyToTySet.get(ty) as TypeAssertionSetValue :\n            {ty, exported: false, isDeclare: false, resolved: false};\n        tySet.isDeclare = true;\n        return ty;\n    };\n\n    const passthru = (str: string, docCommentText?: string) => {\n        const ty: TypeAssertion = {\n            kind: 'never',\n            passThruCodeBlock: str || '',\n        };\n        if (docCommentText) {\n            ty.docComment = docCommentText;\n        }\n        schema.set(`__$$$gensym_${gensymCount++}$$$__`, {ty, exported: false, isDeclare: false, resolved: false});\n        return ty;\n    };\n\n    const directive = (name: string, body: string) => {\n        switch (name) {\n        case '@tynder-external':\n            lisp.evaluateAST(parseExternalDirective(`external ${body} ;`) as SxToken[]);\n            break;\n        case '@tynder-pass-through':\n            passthru(body);\n            break;\n        default:\n            throw new Error(`Unknown directive is appeared: ${name}`);\n        }\n        return [];\n    };\n\n    lisp.setGlobals({\n        picked: operators.picked,\n        omit: operators.omit,\n        partial: operators.partial,\n        intersect: operators.intersect,\n        oneOf: operators.oneOf,\n        subtract: operators.subtract,\n        primitive: operators.primitive,\n        primitiveValue: operators.primitiveValue,\n        optional: operators.optional,\n        repeated: operators.repeated,\n        sequenceOf: operators.sequenceOf,\n        spread: operators.spread,\n        enumType: operators.enumType,\n        objectType: operators.objectType,\n        derived: operators.derived,\n        def,\n        ref,\n        redef,\n        export: exported,\n        external,\n        asConst,\n        asDeclare,\n        passthru,\n        directive,\n        docComment: operators.withDocComment,\n        '@range': (minValue: number | string, maxValue: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withRange(minValue, maxValue)(ty),\n        '@minValue': (minValue: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMinValue(minValue)(ty),\n        '@maxValue': (maxValue: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMaxValue(maxValue)(ty),\n        '@greaterThan': (greaterThan: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withGreaterThan(greaterThan)(ty),\n        '@lessThan': (lessThan: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withLessThan(lessThan)(ty),\n        '@minLength': (minLength: number) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMinLength(minLength)(ty),\n        '@maxLength': (maxLength: number) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMaxLength(maxLength)(ty),\n        '@match': (pattern: RegExp) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMatch(pattern)(ty),\n        '@stereotype': (stereotype: string) => (ty: TypeAssertion) =>\n            operators.withStereotype(stereotype)(ty),\n        '@constraint': (name: string, args?: any) => (ty: TypeAssertion) =>\n            operators.withConstraint(name, args)(ty),\n        '@forceCast': () => (ty: TypeAssertion) =>\n            operators.withForceCast()(ty),\n        '@recordType': () => (ty: TypeAssertion) =>\n            operators.withRecordType()(ty),\n        '@meta': (meta: any) => (ty: TypeAssertion) =>\n            operators.withMeta(meta)(ty),\n        '@msg': (messages: string | ErrorMessages) => (ty: TypeAssertion) =>\n            operators.withMsg(messages)(ty),\n        '@msgId': (messageId: string) => (ty: TypeAssertion) =>\n            operators.withMsgId(messageId)(ty),\n    });\n\n    const z = parse(s);\n    lisp.evaluateAST(z as SxToken[]);\n\n    return resolveSchema(schema);\n}\n// tslint:enable: object-literal-key-quotes\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig }       from '../../types';\r\nimport { operators,\r\n         compilationOperators } from './core.operator';\r\nimport { macros,\r\n         compilationMacros }    from './core.macro';\r\nimport symbols                  from './core.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || [])\r\n        .concat(operators)\r\n        .concat(config.enableCompilationOperators ? compilationOperators : []);\r\n    config.macros = (config.macros || [])\r\n        .concat(macros)\r\n        .concat(config.enableCompilationOperators ? compilationMacros : []);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         OptionalAssertion,\n         EnumAssertion,\n         AdditionalPropsKey,\n         ObjectAssertion,\n         TypeAssertionMap,\n         CodegenContext } from '../../types';\nimport { escapeString }   from '../../lib/escape';\nimport { SymbolPattern }  from '../../lib/util';\n\n\n\nfunction formatTypeName(typeName: string) {\n    if (typeName.includes('.')) {\n        const z = typeName.split('.');\n        let s = z[0];\n        for (let i = 1; i < z.length; i++) {\n            s += `['${escapeString(z[i])}']`\n        }\n        return `(${s})`;\n    }\n    return typeName;\n}\n\n\nfunction formatTypeScriptCodeDocComment(ty: TypeAssertion | string, nestLevel: number) {\n    let code = '';\n    const indent = '    '.repeat(nestLevel);\n    const docComment = typeof ty === 'string' ? ty : ty.docComment;\n    if (docComment) {\n        if (0 <= docComment.indexOf('\\n')) {\n            code += `${indent}/**\\n${indent}  ${\n                docComment\n                    .split('\\n')\n                    .map(x => x.trimLeft())\n                    .join(`\\n${indent} `)}\\n${indent} */\\n`;\n        } else {\n            code += `${indent}/** ${docComment} */\\n`;\n        }\n    }\n    return code;\n}\n\n\nfunction generateTypeScriptCodePrimitive(ty: PrimitiveTypeAssertion, ctx: CodegenContext) {\n    // TODO: Function, DateStr, DateTimeStr\n    switch (ty.primitiveName) {\n    case 'integer':\n        return 'number';\n    default:\n        return ty.primitiveName;\n    }\n}\n\n\nfunction generateTypeScriptCodePrimitiveValue(ty: PrimitiveValueTypeAssertion, ctx: CodegenContext) {\n    if (ty.value === null) {\n        return 'null';\n    }\n    if (ty.value === void 0) {\n        return 'undefined';\n    }\n    switch (typeof ty.value) {\n    case 'string':\n        return `'${escapeString(ty.value)}'`;\n    case 'bigint':\n        return `${ty.value.toString()}n`;\n    default:\n        return ty.value.toString();\n    }\n}\n\n\nfunction generateTypeScriptCodeRepeated(ty: RepeatedAssertion, ctx: CodegenContext) {\n    return (ty.repeated.kind === 'primitive' ||\n            ty.repeated.kind === 'never' ||\n            ty.repeated.kind === 'any' ||\n            ty.repeated.kind === 'unknown' ||\n            ty.repeated.kind === 'object' ||\n            ty.repeated.kind === 'symlink' ||\n            (ty.repeated.kind === 'one-of' && ty.repeated.typeName) ?\n        `${ty.repeated.typeName ?\n            formatTypeName(ty.repeated.typeName) :\n            generateTypeScriptCodeInner(ty.repeated, false, ctx)}[]` :\n        `Array<${ty.repeated.typeName ?\n            formatTypeName(ty.repeated.typeName) :\n            generateTypeScriptCodeInner(ty.repeated, false, ctx)}>`\n    );\n}\n\n\nfunction generateTypeScriptCodeSpread(ty: SpreadAssertion, ctx: CodegenContext) {\n    return '';\n}\n\n\nfunction generateTypeScriptCodeSequence(ty: SequenceAssertion, ctx: CodegenContext) {\n    if (0 < ty.sequence.filter(x => x.kind === 'spread' || x.kind === 'optional').length) {\n        return 'any[]';\n    }\n    return `[${\n        ty.sequence\n            .filter(x => x.kind !== 'spread' && x.kind !== 'optional')\n            .map(x => x.typeName ?\n                formatTypeName(x.typeName) :\n                generateTypeScriptCodeInner(x, false, {...ctx, nestLevel: ctx.nestLevel + 1}))\n            .join(', ')}]`;\n}\n\n\nfunction generateTypeScriptCodeOneOf(ty: OneOfAssertion, ctx: CodegenContext) {\n    return `(${ty.oneOf\n        .map(x => x.typeName ?\n            formatTypeName(x.typeName) :\n            generateTypeScriptCodeInner(x, false, ctx)).join(' | ')})`;\n}\n\n\nfunction generateTypeScriptCodeOptional(ty: OptionalAssertion, ctx: CodegenContext) {\n    return generateTypeScriptCodeInner(ty.optional, false, ctx);\n}\n\n\nfunction generateTypeScriptCodeEnum(ty: EnumAssertion, ctx: CodegenContext) {\n    return `(${ty.values.map(x => `${x[1]}`).join(' | ')})`;\n}\n\n\nfunction formatAdditionalPropsName(ak: AdditionalPropsKey, i: number) {\n    return (`[propName${i}: ${ak.map(x => typeof x === 'string' ? x : 'string').join(' | ')}]`);\n}\n\n\nfunction generateTypeScriptCodeObject(ty: ObjectAssertion, isInterface: boolean, ctx: CodegenContext) {\n    if (ty.members.filter(x => !(x[2])).length === 0 &&\n        ty.additionalProps?.filter(x => !(x[2])).length === 0) {\n        return '{}';\n    }\n    // NOTE: Semicolon is always preferred.\n    // https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/member-delimiter-style.md\n    const sep = isInterface ? ';\\n' : ';\\n';\n\n    const memberLines =\n        ty.members.filter(x => !(x[2]))\n        .map(x =>\n            `${formatTypeScriptCodeDocComment(x[3] || '', ctx.nestLevel + 1)}${\n                '    '.repeat(ctx.nestLevel + 1)}${\n                SymbolPattern.test(x[0]) ? x[0] : `'${escapeString(x[0])}'`}${\n                    x[1].kind === 'optional' ? '?' : ''}: ${\n                x[1].typeName ?\n                    formatTypeName(x[1].typeName) :\n                    generateTypeScriptCodeInner(x[1], false, {...ctx, nestLevel: ctx.nestLevel + 1})}`);\n\n    const additionalPropsLines =\n        ty.additionalProps?.filter(x => !(x[2]))\n        .map((x, i) =>\n            `${formatTypeScriptCodeDocComment(x[3] || '', ctx.nestLevel + 1)}${\n                '    '.repeat(ctx.nestLevel + 1)}${\n                formatAdditionalPropsName(x[0], i)}${x[1].kind === 'optional' ? '?' : ''}: ${\n                x[1].typeName ?\n                    formatTypeName(x[1].typeName) :\n                    generateTypeScriptCodeInner(x[1], false, {...ctx, nestLevel: ctx.nestLevel + 1})}`) || [];\n\n    const propsLines = memberLines.concat(additionalPropsLines);\n    if (propsLines.length === 0) {\n        return '{}';\n    }\n    return (\n        `{\\n${propsLines.join(sep)}${sep}${'    '.repeat(ctx.nestLevel)}}`\n    );\n}\n\n\nfunction generateTypeScriptCodeInner(ty: TypeAssertion, isInterface: boolean, ctx: CodegenContext): string {\n    switch (ty.kind) {\n    case 'never':\n        return 'never';\n    case 'any':\n        return 'any';\n    case 'unknown':\n        return 'unknown';\n    case 'primitive':\n        return generateTypeScriptCodePrimitive(ty, ctx);\n    case 'primitive-value':\n        return generateTypeScriptCodePrimitiveValue(ty, ctx);\n    case 'repeated':\n        return generateTypeScriptCodeRepeated(ty, ctx);\n    case 'spread':\n        return generateTypeScriptCodeSpread(ty, ctx);\n    case 'sequence':\n        return generateTypeScriptCodeSequence(ty, ctx);\n    case 'one-of':\n        return generateTypeScriptCodeOneOf(ty, ctx);\n    case 'optional':\n        return generateTypeScriptCodeOptional(ty, ctx);\n    case 'enum':\n        return generateTypeScriptCodeEnum(ty, ctx);\n    case 'object':\n        return generateTypeScriptCodeObject(ty, isInterface, ctx);\n    case 'symlink':\n        return ty.symlinkTargetName;\n    case 'operator':\n        throw new Error(`Unexpected type assertion: ${(ty as any).kind}`);\n    default:\n        throw new Error(`Unknown type assertion: ${(ty as any).kind}`);\n    }\n}\n\n\nexport function generateTypeScriptCode(types: TypeAssertionMap): string {\n    let code = '';\n    const ctx = {nestLevel: 0};\n    for (const ty of types.entries()) {\n        if (ty[1].ty.noOutput) {\n            continue;\n        }\n        code += formatTypeScriptCodeDocComment(ty[1].ty, ctx.nestLevel);\n        if (ty[1].exported) {\n            code += 'export ';\n        }\n        if (ty[1].isDeclare) {\n            code += 'declare ';\n        }\n        if (ty[1].ty.kind === 'object') {\n            code += `interface ${ty[0]}${\n                ty[1].ty.baseTypes && ty[1].ty.baseTypes.length ? ` extends ${\n                    ty[1].ty.baseTypes\n                        .filter(x => x.typeName)\n                        .map(x => formatTypeName(x.typeName as string))\n                        .join(', ')}` : ''} ${\n                generateTypeScriptCodeInner(ty[1].ty, true, ctx)}\\n\\n`;\n        } else if (ty[1].ty.kind === 'enum') {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            let value: number | null = 0;\n            code += `${ty[1].ty.isConst ? 'const ' : ''}enum ${ty[0]} {\\n${\n                ty[1].ty.values\n                    .map(x => `${\n                        formatTypeScriptCodeDocComment(x[2] || '', ctx.nestLevel + 1)}${\n                        indent1}${(() => {\n                            if (value !== null && x[1] === value) {\n                                value++;\n                                return `${x[0]}`;\n                            } else {\n                                if (typeof x[1] === 'number') {\n                                    value = x[1] + 1;\n                                    return `${x[0]} = ${x[1]}`;\n                                } else {\n                                    return `${x[0]} = '${escapeString(x[1])}'`;\n                                }\n                            }\n                        })()},\\n`)\n                    .join('')}${indent0}}\\n\\n`;\n        } else if (ty[1].ty.kind === 'never' && ty[1].ty.passThruCodeBlock) {\n            code += `${ty[1].ty.passThruCodeBlock}\\n\\n`;\n        } else {\n            code += `type ${ty[0]} = ${\n                (ty[1].ty.originalTypeName ?\n                    formatTypeName(ty[1].ty.originalTypeName) :\n                    void 0) ||\n                generateTypeScriptCodeInner(ty[1].ty, false, ctx)};\\n\\n`;\n        }\n    }\n    return code;\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         TypeAssertionMap } from '../../types';\nimport * as JsonSchema      from '../../types/json-schema-types';\n\n\n\nfunction addMetaInfo(a: JsonSchema.JsonSchemaAssertion, ty: TypeAssertion) {\n    const a2 = {...a};\n    let changed = false;\n\n    if (ty.docComment) {\n        a2.description = ty.docComment;\n        changed = true;\n    }\n    switch (ty.kind) {\n    case 'repeated':\n        if (typeof ty.min === 'number') {\n            (a2 as JsonSchema.JsonSchemaArrayAssertion).minItems = ty.min;\n            changed = true;\n        }\n        if (typeof ty.max === 'number') {\n            (a2 as JsonSchema.JsonSchemaArrayAssertion).maxItems = ty.max;\n            changed = true;\n        }\n        break;\n    case 'primitive':\n        if (typeof ty.minValue === 'number') {\n            (a2 as JsonSchema.JsonSchemaNumberAssertion).minimum = ty.minValue;\n            changed = true;\n        }\n        if (typeof ty.maxValue === 'number') {\n            (a2 as JsonSchema.JsonSchemaNumberAssertion).maximum = ty.maxValue;\n            changed = true;\n        }\n        if (typeof ty.greaterThanValue === 'number') {\n            (a2 as JsonSchema.JsonSchemaNumberAssertion).exclusiveMinimum = ty.greaterThanValue;\n            changed = true;\n        }\n        if (typeof ty.lessThanValue === 'number') {\n            (a2 as JsonSchema.JsonSchemaNumberAssertion).exclusiveMaximum = ty.lessThanValue;\n            changed = true;\n        }\n        if (typeof ty.minLength === 'number') {\n            (a2 as JsonSchema.JsonSchemaStringAssertion).minLength = ty.minLength;\n            changed = true;\n        }\n        if (typeof ty.maxLength === 'number') {\n            (a2 as JsonSchema.JsonSchemaStringAssertion).maxLength = ty.maxLength;\n            changed = true;\n        }\n        if (ty.pattern) {\n            (a2 as JsonSchema.JsonSchemaStringAssertion).pattern = ty.pattern.source;\n            changed = true;\n        }\n        break;\n    }\n    return (changed ? a2 : a);\n}\n\nfunction generateJsonSchemaInner(schema: TypeAssertionMap, ty: TypeAssertion, nestLevel: number): JsonSchema.JsonSchemaAssertion {\n    if (0 < nestLevel && ty.typeName) {\n        const ret: JsonSchema.JsonSchemaRefAssertion = {\n            $ref: `#/definitions/${ty.typeName.replace(/\\./g, '/properties/')}`,\n        };\n        const r2 = addMetaInfo(ret, ty);\n        if (ret !== r2) {\n            // NOTE: `$ref` cannot have value constraints.\n            return generateJsonSchemaInner(schema, ty, 0);\n        } else {\n            return ret;\n        }\n    }\n\n    switch (ty.kind) {\n    case 'symlink':\n        {\n            const ret: JsonSchema.JsonSchemaRefAssertion = {\n                $ref: `#/definitions/${ty.symlinkTargetName}`,\n            };\n            const r2 = addMetaInfo(ret, ty);\n            if (ret !== r2) {\n                // NOTE: `$ref` cannot have value constraints.\n                const t2 = schema.get(ty.symlinkTargetName)?.ty;\n                if (t2) {\n                    return generateJsonSchemaInner(schema, t2, 0);\n                } else {\n                    // Drop constraints.\n                    return ret;\n                }\n            } else {\n                return ret;\n            }\n        }\n    case 'repeated':\n        {\n            const ret: JsonSchema.JsonSchemaArrayAssertion = {\n                type: 'array',\n                items: generateJsonSchemaInner(schema, ty.repeated, nestLevel + 1),\n            };\n            if (typeof ty.min === 'number') {\n                ret.minItems = ty.min;\n            }\n            if (typeof ty.max === 'number') {\n                ret.maxItems = ty.max;\n            }\n            return addMetaInfo(ret, ty);\n        }\n    case 'sequence':\n        {\n            const ret: JsonSchema.JsonSchemaArrayAssertion = {\n                type: 'array',\n                items: { anyOf: ty.sequence.map(x => generateJsonSchemaInner(schema, x, nestLevel + 1)) },\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'spread':\n        {\n            return generateJsonSchemaInner(schema, ty.spread, nestLevel + 1);\n        }\n    case 'one-of':\n        {\n            const ret: JsonSchema.JsonSchemaAnyOfAssertion = {\n                anyOf: ty.oneOf.map(x => generateJsonSchemaInner(schema, x, nestLevel + 1)),\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'optional':\n        {\n            const ret: JsonSchema.JsonSchemaOneOfAssertion = {\n                oneOf: [\n                    generateJsonSchemaInner(schema, ty.optional, nestLevel + 1),\n                    {type: 'null'},\n                ],\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'enum':\n        {\n            const ret: JsonSchema.JsonSchemaTsEnumAssertion = {\n                type: ['string', 'number'],\n                enum: ty.values.map(x => x[1]),\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'object':\n        {\n            const properties: JsonSchema.JsonSchemaObjectPropertyAssertion = {};\n            const patternProperties: JsonSchema.JsonSchemaObjectPropertyAssertion = {};\n            let patternPropsCount = 0;\n            const required: string[] = [];\n            for (const m of ty.members) {\n                const z = generateJsonSchemaInner(schema,\n                    m[1].kind === 'optional' ?\n                        m[1].optional :\n                        m[1],\n                    nestLevel + 1);\n\n                if (m[3]) {\n                    z.description = m[3];\n                } else {\n                    delete z.description;\n                }\n                properties[m[0]] = z;\n\n                if (m[1].kind !== 'optional') {\n                    required.push(m[0]);\n                }\n            }\n            for (const m of ty.additionalProps || []) {\n                const z = generateJsonSchemaInner(schema, m[1], nestLevel + 1);\n                if (m[3]) {\n                    z.description = m[3];\n                } else {\n                    delete z.description;\n                }\n                for (const k of m[0]) {\n                    patternPropsCount++;\n                    switch (k) {\n                    case 'number':\n                        patternProperties['^[0-9]+$'] = z;\n                        break;\n                    case 'string':\n                        patternProperties['^.*$'] = z;\n                        break;\n                    default:\n                        patternProperties[k.source] = z;\n                        break;\n                    }\n                }\n            }\n            const ret: JsonSchema.JsonSchemaObjectAssertion = {\n                type: 'object',\n                properties,\n                ...(0 < patternPropsCount ? {patternProperties} : {}),\n                ...(0 < required.length ? {required} : {}),\n                additionalProperties: false,\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'primitive':\n        {\n            switch (ty.primitiveName) {\n            case 'null': case 'undefined':\n                {\n                    const ret: JsonSchema.JsonSchemaNullAssertion = {\n                        type: 'null',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'number':\n                {\n                    const ret: JsonSchema.JsonSchemaNumberAssertion = {\n                        type: 'number',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'bigint':\n                {\n                    const ret: JsonSchema.JsonSchemaBigIntAssertion = {\n                        type: ['integer', 'string'],\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'integer':\n                {\n                    const ret: JsonSchema.JsonSchemaNumberAssertion = {\n                        type: 'integer',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'string':\n                {\n                    const ret: JsonSchema.JsonSchemaStringAssertion = {\n                        type: 'string',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'boolean':\n                {\n                    const ret: JsonSchema.JsonSchemaBooleanAssertion = {\n                        type: 'boolean',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            }\n            // TODO: Function, DateStr, DateTimeStr\n        }\n    case 'primitive-value':\n        {\n            switch (typeof ty.value) {\n            case 'number':\n                {\n                    const ret: JsonSchema.JsonSchemaNumberValueAssertion = {\n                        type: 'number',\n                        enum: [ty.value],\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'bigint':\n                {\n                    const ret: JsonSchema.JsonSchemaBigIntNumberValueAssertion = {\n                        type: ['integer', 'string'],\n                        enum: [ty.value.toString()],\n                    };\n                    if (BigInt(Number.MIN_SAFE_INTEGER) <= ty.value && ty.value <= BigInt(Number.MAX_SAFE_INTEGER)) {\n                        ret.enum.push(Number(ty.value));\n                    }\n                    return addMetaInfo(ret, ty);\n                }\n            case 'string':\n                {\n                    const ret: JsonSchema.JsonSchemaStringValueAssertion = {\n                        type: 'string',\n                        enum: [ty.value],\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'boolean':\n                {\n                    const ret: JsonSchema.JsonSchemaBooleanValueAssertion = {\n                        type: 'boolean',\n                        enum: [ty.value],\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            default:\n                throw new Error(`Unknown primitive-value assertion: ${typeof ty.value}`);\n            }\n        }\n    case 'never':\n        {\n            const ret: JsonSchema.JsonSchemaNullAssertion = {\n                type: 'null',\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'any': case 'unknown':\n        {\n            const ret: JsonSchema.JsonSchemaAnyAssertion = {\n                type: ['null', 'integer', 'number', 'string', 'boolean', 'array', 'object'],\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'operator':\n        throw new Error(`Unexpected type assertion: ${(ty as any).kind}`);\n    default:\n        throw new Error(`Unknown type assertion: ${(ty as any).kind}`);\n    }\n}\n\n\nexport function generateJsonSchemaObject(schema: TypeAssertionMap) {\n    const ret: JsonSchema.JsonSchemaRootAssertion = {\n        $schema: 'http://json-schema.org/draft-06/schema#',\n        definitions: {},\n    };\n    for (const ty of schema.entries()) {\n        if (ty[1].ty.kind === 'never' && ty[1].ty.passThruCodeBlock) {\n            continue;\n        }\n        (ret.definitions as object)[ty[0]] = generateJsonSchemaInner(schema, ty[1].ty, 0);\n    }\n    return ret;\n}\n\n\nexport function generateJsonSchema(schema: TypeAssertionMap, asTs?: boolean): string {\n    const ret = generateJsonSchemaObject(schema);\n\n    if (asTs) {\n        return (\n            `\\n// tslint:disable: object-literal-key-quotes\\n` +\n            `const schema = ${JSON.stringify(ret, null, 2)};\\nexport default schema;` +\n            `\\n// tslint:enable: object-literal-key-quotes\\n`\n        );\n    } else {\n        return JSON.stringify(ret, null, 2);\n    }\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         OptionalAssertion,\n         EnumAssertion,\n         ObjectAssertion,\n         TypeAssertionMap,\n         CodegenContext } from '../../types';\nimport { escapeString }   from '../../lib/escape';\n\n\n\nfunction formatTypeName(ty: TypeAssertion, ctx: CodegenContext, typeName: string) {\n    if (typeName.includes('.')) {\n        return generateProto3CodeInner(ty, false, ctx);\n    }\n    return typeName;\n}\n\n\nfunction formatProto3CodeDocComment(ty: TypeAssertion | string, nestLevel: number) {\n    let code = '';\n    const indent = '    '.repeat(nestLevel);\n    const docComment = typeof ty === 'string' ? ty : ty.docComment;\n    if (docComment) {\n        if (0 <= docComment.indexOf('\\n')) {\n            code += `${indent}/**\\n${indent}  ${\n                docComment\n                    .split('\\n')\n                    .map(x => x.trimLeft())\n                    .join(`\\n${indent} `)}\\n${indent} */\\n`;\n        } else {\n            code += `${indent}/** ${docComment} */\\n`;\n        }\n    }\n    return code;\n}\n\n\nfunction formatMemberType(ty: TypeAssertion, ctx: CodegenContext): string {\n    if (ty.typeName) {\n        return formatTypeName(ty, ctx, ty.typeName);\n    } else {\n        switch (ty.kind) {\n        case 'primitive':\n            return generateProto3CodePrimitive(ty, ctx);\n        case 'primitive-value':\n            return generateProto3CodePrimitiveValue(ty, ctx);\n        case 'repeated':\n            return generateProto3CodeRepeated(ty, ctx);\n        case 'one-of':\n            return generateProto3CodeOneOf(ty, ctx);\n        default:\n            return 'object';\n        }\n    }\n}\n\n\nfunction appendOptionalModifier(name: string) {\n    switch (name) {\n    case 'double':\n        return 'google.protobuf.DoubleValue';\n    case 'int64':\n        return 'google.protobuf.Int64Value';\n    case 'int32':\n        return 'google.protobuf.Int32Value';\n    case 'string':\n        return 'google.protobuf.StringValue';\n    case 'bool':\n        return 'google.protobuf.BoolValue';\n    default:\n        return name;\n    }\n}\n\n\nfunction isNullableOneOf(ty: OneOfAssertion, ctx: CodegenContext) {\n    const filtered = ty.oneOf.filter(x => !(\n        x.kind === 'primitive' && (x.primitiveName === 'null' || x.primitiveName === 'undefined') ||\n        x.kind === 'primitive-value' && (x.value === null || x.value === void 0)));\n    return (filtered.length === 1 && ty.oneOf.length !== 1 ? filtered[0] : null) ;\n}\n\n\nfunction generateProto3CodePrimitive(ty: PrimitiveTypeAssertion, ctx: CodegenContext) {\n    switch (ty.primitiveName) {\n    case 'number':\n        return 'double';\n    case 'integer':\n        return 'int32';\n    case 'bigint':\n        return 'string';\n    case 'string':\n        return 'string';\n    case 'boolean':\n        return 'bool';\n    case 'undefined': case 'null': default:\n        return 'google.protobuf.Any';\n    }\n    // TODO: Function, integer, DateStr, DateTimeStr\n}\n\n\nfunction generateProto3CodePrimitiveValue(ty: PrimitiveValueTypeAssertion, ctx: CodegenContext) {\n    if (ty.value === null) {\n        return 'google.protobuf.Any';\n    }\n    if (ty.value === void 0) {\n        return 'google.protobuf.Any';\n    }\n    switch (typeof ty.value) {\n    case 'number':\n        return 'double';\n    case 'bigint':\n        return 'string';\n    case 'string':\n        return 'string';\n    case 'boolean':\n        return 'bool';\n    default:\n        return 'google.protobuf.Any';\n    }\n}\n\n\nfunction generateProto3CodeRepeated(ty: RepeatedAssertion, ctx: CodegenContext) {\n    return (`repeated ${ty.repeated.typeName ?\n            formatTypeName(ty.repeated, ctx, ty.repeated.typeName) :\n            ty.repeated.kind === 'repeated' ?\n                'google.protobuf.Any' :\n                generateProto3CodeInner(ty.repeated, false, ctx)}`\n    );\n}\n\n\nfunction generateProto3CodeSpread(ty: SpreadAssertion, ctx: CodegenContext) {\n    return '';\n}\n\n\nfunction generateProto3CodeSequence(ty: SequenceAssertion, ctx: CodegenContext) {\n    return 'repeated google.protobuf.Any';\n}\n\n\nfunction generateProto3CodeOneOf(ty: OneOfAssertion, ctx: CodegenContext) {\n    const z = isNullableOneOf(ty, ctx);\n    if (z) {\n        return appendOptionalModifier(formatMemberType(z, ctx));\n    } else {\n        return 'google.protobuf.Any';\n    }\n}\n\n\nfunction generateProto3CodeOptional(ty: OptionalAssertion, ctx: CodegenContext) {\n    return appendOptionalModifier(generateProto3CodeInner(ty.optional, false, ctx));\n}\n\n\nfunction generateProto3CodeEnum(ty: EnumAssertion, ctx: CodegenContext) {\n    return (ty.typeName ?\n        formatTypeName(ty, ctx, ty.typeName) :\n        'google.protobuf.Any'\n    );\n}\n\n\nfunction generateProto3CodeObject(ty: ObjectAssertion, isInterface: boolean, ctx: CodegenContext) {\n    if (ty.members.length === 0) {\n        return '{}';\n    }\n    const sep = isInterface ? ';\\n' : ',\\n';\n    let count = 1;\n\n    const memberLines =\n        ty.members\n        .map(x =>\n            `${formatProto3CodeDocComment(x[3] || '', ctx.nestLevel + 1)}${\n                '    '.repeat(ctx.nestLevel + 1)}${\n                x[1].typeName ?\n                    formatTypeName(x[1], {...ctx, nestLevel: ctx.nestLevel + 1}, x[1].typeName) :\n                    generateProto3CodeInner(x[1], false, {...ctx, nestLevel: ctx.nestLevel + 1})} ${\n                x[0]} = ${count++}`);\n\n    return (\n        `{\\n${memberLines.join(sep)}${sep}${'    '.repeat(ctx.nestLevel)}}`\n    );\n}\n\n\nfunction generateProto3CodeInner(ty: TypeAssertion, isInterface: boolean, ctx: CodegenContext): string {\n    switch (ty.kind) {\n    case 'never': case 'any': case 'unknown':\n        return 'google.protobuf.Any';\n    case 'primitive':\n        return generateProto3CodePrimitive(ty, ctx);\n    case 'primitive-value':\n        return generateProto3CodePrimitiveValue(ty, ctx);\n    case 'repeated':\n        return generateProto3CodeRepeated(ty, ctx);\n    case 'spread':\n        return generateProto3CodeSpread(ty, ctx);\n    case 'sequence':\n        return generateProto3CodeSequence(ty, ctx);\n    case 'one-of':\n        return generateProto3CodeOneOf(ty, ctx);\n    case 'optional':\n        return generateProto3CodeOptional(ty, ctx);\n    case 'enum':\n        return generateProto3CodeEnum(ty, ctx);\n    case 'object':\n        return generateProto3CodeObject(ty, isInterface, ctx);\n    case 'symlink':\n        return ty.symlinkTargetName;\n    case 'operator':\n        throw new Error(`Unexpected type assertion: ${(ty as any).kind}`);\n    default:\n        throw new Error(`Unknown type assertion: ${(ty as any).kind}`);\n    }\n}\n\n\nexport function generateProto3Code(types: TypeAssertionMap): string {\n    let code =\n`\nsyntax = \"proto3\";\nimport \"google/protobuf/wrappers.proto\";\nimport \"google/protobuf/any.proto\";\n\n`;\n\n    const ctx = {nestLevel: 0};\n    for (const ty of types.entries()) {\n        if (ty[1].ty.noOutput) {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            code += `message ${ty[0]} {\\n${indent1}google.protobuf.Any value = 1;\\n${indent0}}\\n\\n`;\n            continue;\n        }\n        code += formatProto3CodeDocComment(ty[1].ty, ctx.nestLevel);\n        if (ty[1].ty.kind === 'object') {\n            code += `message ${ty[0]} ${\n                generateProto3CodeInner(ty[1].ty, true, ctx)}\\n\\n`;\n        } else if (ty[1].ty.kind === 'enum') {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            if (0 < ty[1].ty.values.filter(x => typeof x[1] !== 'number').length) {      // NOTE: string enum is not allowed\n                code += `message ${ty[0]} {\\n${indent1}google.protobuf.Any value = 1;\\n${indent0}}\\n\\n`;\n            } else {\n                code += `enum ${ty[0]} {\\n${\n                    indent1}option allow_alias = true;\\n${\n                    ty[1].ty.values.filter(x => x[1] === 0).length === 0 ?\n                        `${indent1}${ty[0]}__UNKNOWN__ = 0;\\n` :                        // NOTE: 0 value item is required\n                        ''}${\n                    ty[1].ty.values\n                        .map(x => `${\n                            formatProto3CodeDocComment(x[2] || '', ctx.nestLevel + 1)}${\n                            indent1}${(() => {\n                                if (typeof x[1] === 'number') {\n                                    return `${ty[0]}_${x[0]} = ${x[1]}`;                 // NOTE: label namespace is shared by all top-level enum\n                                } else {\n                                    return `${ty[0]}_${x[0]} = '${escapeString(x[1])}'`; // NOTE: string enum is not allowed\n                                }\n                            })()};\\n`)\n                        .join('')}${indent0}}\\n\\n`;\n            }\n        } else if (ty[1].ty.kind === 'never' && ty[1].ty.passThruCodeBlock) {\n            // nothing to do\n        } else {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            code += `message ${ty[0]} {\\n${indent1}${generateProto3CodeInner(ty[1].ty, false, ctx)} value = 1;\\n${indent0}}\\n\\n`;\n        }\n    }\n    return code;\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         EnumAssertion,\n         ObjectAssertion,\n         TypeAssertionMap,\n         CodegenContext } from '../../types';\n\n\n\nfunction formatTypeName(ty: TypeAssertion, ctx: CodegenContext, typeName: string) {\n    if (typeName.includes('.')) {\n        return generateGraphQlCodeInner(ty, false, ctx, false);\n    }\n    return typeName;\n}\n\n\nfunction formatGraphQlCodeDocComment(ty: TypeAssertion | string, nestLevel: number) {\n    let code = '';\n    const indent = '    '.repeat(nestLevel);\n    const docComment = typeof ty === 'string' ? ty : ty.docComment;\n    if (docComment) {\n        if (0 <= docComment.indexOf('\\n')) {\n            code += `${indent}/**\\n${indent}  ${\n                docComment\n                    .split('\\n')\n                    .map(x => x.trimLeft())\n                    .join(`\\n${indent} `)}\\n${indent} */\\n`;\n        } else {\n            code += `${indent}/** ${docComment} */\\n`;\n        }\n    }\n    return code;\n}\n\n\nfunction isNullableOneOf(ty: OneOfAssertion, ctx: CodegenContext) {\n    const filtered = ty.oneOf.filter(x => !(\n        x.kind === 'primitive' && (x.primitiveName === 'null' || x.primitiveName === 'undefined') ||\n        x.kind === 'primitive-value' && (x.value === null || x.value === void 0)));\n    return (filtered.length === 1 && ty.oneOf.length !== 1 ? filtered[0] : null) ;\n}\n\n\nfunction generateGraphQlCodePrimitive(ty: PrimitiveTypeAssertion, ctx: CodegenContext) {\n    switch (ty.primitiveName) {\n    case 'number':\n        return 'Float';\n    case 'integer':\n        return 'Int';\n    case 'bigint':\n        return 'BigInt';\n    case 'string':\n        return 'String';\n    case 'boolean':\n        return 'Boolean';\n    case 'undefined': case 'null': default:\n        return 'Any'; // TODO: Any is invalid type.\n    }\n    // TODO: Function, DateStr, DateTimeStr\n}\n\n\nfunction generateGraphQlCodePrimitiveValue(ty: PrimitiveValueTypeAssertion, ctx: CodegenContext) {\n    if (ty.value === null) {\n        return 'Any'; // TODO: Any is invalid type.\n    }\n    if (ty.value === void 0) {\n        return 'Any'; // TODO: Any is invalid type.\n    }\n    switch (typeof ty.value) {\n        case 'number':\n            return 'Float';\n        case 'bigint':\n            return 'BigInt';\n        case 'string':\n            return 'String';\n        case 'boolean':\n            return 'Boolean';\n        default:\n            return 'Any'; // TODO: Any is invalid type.\n    }\n}\n\n\nfunction generateGraphQlCodeRepeated(ty: RepeatedAssertion, ctx: CodegenContext) {\n    return (`[${ty.repeated.typeName ?\n            formatTypeName(ty.repeated, ctx, ty.repeated.typeName) :\n            generateGraphQlCodeInner(ty.repeated, false, ctx, false)}${\n                (ty.repeated.kind === 'optional' ||\n                 ty.repeated.kind === 'one-of' && isNullableOneOf(ty.repeated, ctx)) ?\n                    '' : '!'}]`\n    );\n}\n\n\nfunction generateGraphQlCodeSpread(ty: SpreadAssertion, ctx: CodegenContext) {\n    return '';\n}\n\n\nfunction generateGraphQlCodeSequence(ty: SequenceAssertion, ctx: CodegenContext) {\n    return '[Any]'; // TODO: Any is invalid type.\n}\n\n\nfunction generateGraphQlCodeOneOf(ty: OneOfAssertion, ctx: CodegenContext, isUnion: boolean) {\n    const z = isNullableOneOf(ty, ctx);\n    if (z) {\n        return z.typeName ?\n            z.typeName :\n            generateGraphQlCodeInner(z, false, ctx, false);\n    } else {\n        if (isUnion) {\n            return `${ty.oneOf\n                .map(x => x.typeName ?\n                    x.typeName :\n                    generateGraphQlCodeInner(x, false, ctx, false)).join(' | ')}`;\n        } else {\n            return 'Any'; // TODO: Any is invalid type.\n        }\n    }\n}\n\n\nfunction generateGraphQlCodeEnum(ty: EnumAssertion, ctx: CodegenContext) {\n    return (ty.typeName ?\n        formatTypeName(ty, ctx, ty.typeName) :\n        'Any'\n    );\n}\n\n\nfunction generateGraphQlCodeObject(ty: ObjectAssertion, isInterface: boolean, ctx: CodegenContext) {\n    if (ty.members.length === 0) {\n        return '{}';\n    }\n    const sep = '\\n';\n\n    const memberLines =\n        ty.members\n        .map(x =>\n            `${formatGraphQlCodeDocComment(x[3] || '', ctx.nestLevel + 1)}${\n                '    '.repeat(ctx.nestLevel + 1)}${\n                x[0]}: ${\n                x[1].typeName ?\n                    formatTypeName(x[1], {...ctx, nestLevel: ctx.nestLevel + 1}, x[1].typeName) :\n                    generateGraphQlCodeInner(x[1], false, {...ctx, nestLevel: ctx.nestLevel + 1}, false)}${\n                (x[1].kind === 'optional' ||\n                 x[1].kind === 'one-of' && isNullableOneOf(x[1], ctx)) ?\n                    '' : '!'}`);\n\n    return (\n        `{\\n${memberLines.join(sep)}${sep}${'    '.repeat(ctx.nestLevel)}}`\n    );\n}\n\n\nfunction generateGraphQlCodeInner(ty: TypeAssertion, isInterface: boolean, ctx: CodegenContext, isUnion: boolean): string {\n    let ret = '';\n\n    switch (ty.kind) {\n    case 'optional':\n        return generateGraphQlCodeInner(ty.optional, isInterface, ctx, false);\n    case 'one-of':\n        return generateGraphQlCodeOneOf(ty, ctx, isUnion); // TODO: inline union is invalid.\n    case 'spread':\n        return generateGraphQlCodeSpread(ty, ctx);\n    case 'sequence':\n        return generateGraphQlCodeSequence(ty, ctx);\n    case 'never':\n        ret = 'Any'; // TODO: Any is invalid type.\n        break;\n    case 'any':\n        ret = 'Any'; // TODO: Any is invalid type.\n        break;\n    case 'unknown':\n        ret = 'Any'; // TODO: Any is invalid type.\n        break;\n    case 'primitive':\n        ret = generateGraphQlCodePrimitive(ty, ctx);\n        break;\n    case 'primitive-value':\n        ret = generateGraphQlCodePrimitiveValue(ty, ctx);\n        break;\n    case 'repeated':\n        ret = generateGraphQlCodeRepeated(ty, ctx);\n        break;\n    case 'enum':\n        ret = generateGraphQlCodeEnum(ty, ctx);\n        break;\n    case 'object':\n        ret = generateGraphQlCodeObject(ty, isInterface, ctx);\n        break;\n    case 'symlink':\n        ret = ty.symlinkTargetName;\n        break;\n    case 'operator':\n        throw new Error(`Unexpected type assertion: ${(ty as any).kind}`);\n    default:\n        throw new Error(`Unknown type assertion: ${(ty as any).kind}`);\n    }\n    return ret + '';\n}\n\n\nexport function generateGraphQlCode(types: TypeAssertionMap): string {\n    let code = `\\nscalar Any\\nunion BigInt = String | Int\\n\\n`;\n\n    const ctx = {nestLevel: 0};\n    for (const ty of types.entries()) {\n        if (ty[1].ty.noOutput) {\n            code += `scalar ${ty[0]}\\n\\n`;\n            continue;\n        }\n        code += formatGraphQlCodeDocComment(ty[1].ty, ctx.nestLevel);\n        if (ty[1].ty.kind === 'object') {\n            code += `type ${ty[0]} ${\n                generateGraphQlCodeInner(ty[1].ty, true, ctx, false)}\\n\\n`;\n        } else if (ty[1].ty.kind === 'enum') {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            code += `enum ${ty[0]} {\\n${\n                ty[1].ty.values\n                    .map(x => `${\n                        formatGraphQlCodeDocComment(x[2] || '', ctx.nestLevel + 1)}${\n                        indent1}${x[0]}\\n`)\n                    .join('')}${indent0}}\\n\\n`;\n        } else if (ty[1].ty.kind === 'never' && ty[1].ty.passThruCodeBlock) {\n            // nothing to do\n        } else {\n            code += `union ${ty[0]} = ${generateGraphQlCodeInner(ty[1].ty, false, ctx, true)}\\n\\n`;\n        }\n    }\n    return code;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         OptionalAssertion,\n         EnumAssertion,\n         ObjectAssertion,\n         TypeAssertionMap,\n         CodegenContext } from '../../types';\nimport { escapeString }   from '../../lib/escape';\nimport { nvl2 }           from './../util';\n\n\n\nfunction formatTypeName(ty: TypeAssertion, ctx: CodegenContext, typeName: string) {\n    if (typeName.includes('.') || ty.kind === 'symlink' || ty.kind === 'enum') {\n        return generateCSharpCodeInner(ty, false, ctx);\n    }\n    return typeName;\n}\n\n\nfunction formatCSharpCodeDocComment(ty: TypeAssertion | string, nestLevel: number) {\n    let code = '';\n    const indent = '    '.repeat(nestLevel);\n    const docComment = typeof ty === 'string' ? ty : ty.docComment;\n    if (docComment) {\n        if (0 <= docComment.indexOf('\\n')) {\n            code += `${indent}/**\\n${indent}  ${\n                docComment\n                    .split('\\n')\n                    .map(x => x.trimLeft())\n                    .join(`\\n${indent} `)}\\n${indent} */\\n`;\n        } else {\n            code += `${indent}/** ${docComment} */\\n`;\n        }\n    }\n    return code;\n}\n\n\nfunction formatMemberType(ty: TypeAssertion, ctx: CodegenContext): string {\n    if (ty.typeName) {\n        return formatTypeName(ty, ctx, ty.typeName);\n    } else {\n        switch (ty.kind) {\n        case 'primitive':\n            return generateCSharpCodePrimitive(ty, ctx);\n        case 'primitive-value':\n            return generateCSharpCodePrimitiveValue(ty, ctx);\n        case 'repeated':\n            return generateCSharpCodeRepeated(ty, ctx);\n        case 'one-of':\n            return generateCSharpCodeOneOf(ty, ctx);\n        default:\n            return 'object';\n        }\n    }\n}\n\n\nfunction appendOptionalModifier(name: string) {\n    switch (name) {\n    case 'decimal': case 'int': case 'double': case 'bool':\n        return `${name}?`;\n    default:\n        return name;\n    }\n}\n\n\nfunction isNullableOneOf(ty: OneOfAssertion, ctx: CodegenContext) {\n    const filtered = ty.oneOf.filter(x => !(\n        x.kind === 'primitive' && (x.primitiveName === 'null' || x.primitiveName === 'undefined') ||\n        x.kind === 'primitive-value' && (x.value === null || x.value === void 0)));\n    return (filtered.length === 1 && ty.oneOf.length !== 1 ? filtered[0] : null) ;\n}\n\n\nfunction generateCSharpCodePrimitive(ty: PrimitiveTypeAssertion, ctx: CodegenContext) {\n    // TODO: Function, DateStr, DateTimeStr\n    switch (ty.primitiveName) {\n    case 'null': case 'undefined':\n        return 'object';\n    case 'integer':\n        return 'int';\n    case 'bigint':\n        return 'decimal';\n    case 'number':\n        return 'double';\n    case 'boolean':\n        return 'bool';\n    default:\n        return ty.primitiveName;\n    }\n}\n\n\nfunction generateCSharpCodePrimitiveValue(ty: PrimitiveValueTypeAssertion, ctx: CodegenContext) {\n    if (ty.value === null || ty.value === void 0) {\n        return 'object';\n    }\n    switch (typeof ty.primitiveName) {\n    case 'bigint':\n        return 'decimal';\n    default:\n        switch (typeof ty.value) {\n        case 'number':\n            return 'double';\n        case 'string':\n            return 'string';\n        case 'boolean':\n            return 'bool';\n        default:\n            return 'object';\n        }\n    }\n}\n\n\nfunction generateCSharpCodeRepeated(ty: RepeatedAssertion, ctx: CodegenContext): string {\n    return `${formatMemberType(ty.repeated, ctx)}[]`;\n}\n\n\nfunction generateCSharpCodeSpread(ty: SpreadAssertion, ctx: CodegenContext) {\n    return '';\n}\n\n\nfunction generateCSharpCodeSequence(ty: SequenceAssertion, ctx: CodegenContext) {\n    return 'object[]';\n}\n\n\nfunction generateCSharpCodeOneOf(ty: OneOfAssertion, ctx: CodegenContext) {\n    const z = isNullableOneOf(ty, ctx);\n    if (z) {\n        return appendOptionalModifier(formatMemberType(z, ctx));\n    } else {\n        return 'object';\n    }\n}\n\n\nfunction generateCSharpCodeOptional(ty: OptionalAssertion, ctx: CodegenContext) {\n    return appendOptionalModifier(generateCSharpCodeInner(ty.optional, false, ctx));\n}\n\n\nfunction generateCSharpCodeEnum(ty: EnumAssertion, ctx: CodegenContext) {\n    return 'object';\n}\n\n\nfunction addAttributes(ty: TypeAssertion, ctx: CodegenContext, typeName: string) {\n    const attrs: string[] = [];\n    let ty2: TypeAssertion = ty;\n\n    if (ty2.kind !== 'optional') {\n        switch (typeName) {\n        case 'decimal': case 'int': case 'double': case 'bool':\n            break;\n        default:\n            if (ty2.kind === 'one-of') {\n                if (! isNullableOneOf(ty2, ctx)) {\n                    attrs.push('Required');\n                }\n            } else {\n                attrs.push('Required');\n            }\n            break;\n        }\n        ty2 = ty;\n    }\n\n    switch (ty2.kind) {\n    case 'primitive':\n        {\n            if (typeof ty2.minLength === 'number') {\n                attrs.push(`MinLength(${ty2.minLength})`);\n            }\n            if (typeof ty2.maxLength === 'number') {\n                attrs.push(`MaxLength(${ty2.maxLength})`);\n            }\n            if (ty2.minValue !== null && ty2.minValue !== void 0 ||\n                ty2.maxValue !== null && ty2.maxValue !== void 0) {\n                switch (ty2.primitiveName) {\n                case 'string':\n                    attrs.push(`Range(typeof(string), \"${\n                        nvl2(ty2.minValue, x => escapeString(x), '')}\", \"${\n                        nvl2(ty2.maxValue, x => escapeString(x), '\\\\U00010FFFF')}\")`);\n                    break;\n                case 'bigint':\n                    attrs.push(`Range(typeof(decimal), ${\n                        nvl2(ty2.minValue, x => `new decimal(@\"${String(x)}\").ToString()`, 'Decimal.MinValue')}, ${\n                        nvl2(ty2.maxValue, x => `new decimal(@\"${String(x)}\").ToString()`, 'Decimal.MaxValue')})`);\n                    break;\n                case 'integer':\n                    attrs.push(`Range(${\n                        nvl2(ty2.minValue, x => `(int)${String(x)}`, 'Int32.MinValue')}, ${\n                        nvl2(ty2.maxValue, x => `(int)${String(x)}`, 'Int32.MaxValue')})`);\n                    break;\n                case 'number':\n                    attrs.push(`Range(${\n                        nvl2(ty2.minValue, x => `(double)${String(x)}`, 'Double.MinValue')}, ${\n                        nvl2(ty2.maxValue, x => `(double)${String(x)}`, 'Double.MaxValue')})`);\n                    break;\n                }\n            }\n            if (ty2.pattern) {\n                attrs.push(`RegularExpression(@\"${ty2.pattern.source.replace(/\"/g, '\"\"')}\")`);\n            }\n        }\n        break;\n    case 'repeated':\n        {\n            if (typeof ty2.min === 'number') {\n                attrs.push(`MinLength(${ty2.min})`);\n            }\n            if (typeof ty2.max === 'number') {\n                attrs.push(`MaxLength(${ty2.max})`);\n            }\n        }\n        break;\n    }\n\n    if (0 < attrs.length) {\n        return `[${attrs.join(', ')}]\\n${'    '.repeat(ctx.nestLevel + 1)}`;\n    } else{\n        return '';\n    }\n}\n\n\nfunction generateCSharpCodeObject(ty: ObjectAssertion, isInterface: boolean, ctx: CodegenContext) {\n    const sep = '\\n\\n';\n\n    const memberLines =\n        ty.members.filter(x => !(x[2]))\n        .map(x => {\n            const typeName =\n                x[1].typeName ?\n                    formatTypeName(x[1], {...ctx, nestLevel: ctx.nestLevel + 1}, x[1].typeName) :\n                    generateCSharpCodeInner(x[1], false, {...ctx, nestLevel: ctx.nestLevel + 1});\n\n            return (\n                `${formatCSharpCodeDocComment(x[3] || '', ctx.nestLevel + 1)}${\n                    '    '.repeat(ctx.nestLevel + 1)}${addAttributes(x[1], ctx, typeName)}public ${\n                    typeName} ${x[0]} { get; set; }`\n            );\n        });\n\n    if (memberLines.length === 0) {\n        return (`\\n${\n            '    '.repeat(ctx.nestLevel)}{\\n${\n            '    '.repeat(ctx.nestLevel)}}`\n        );\n    }\n    return (`\\n${\n        '    '.repeat(ctx.nestLevel)}{\\n${memberLines.join(sep)}\\n${\n        '    '.repeat(ctx.nestLevel)}}`\n    );\n}\n\n\nfunction generateCSharpCodeInner(ty: TypeAssertion, isInterface: boolean, ctx: CodegenContext): string {\n    switch (ty.kind) {\n    case 'never': case 'any': case 'unknown':\n        return 'object';\n    case 'primitive':\n        return generateCSharpCodePrimitive(ty, ctx);\n    case 'primitive-value':\n        return generateCSharpCodePrimitiveValue(ty, ctx);\n    case 'repeated':\n        return generateCSharpCodeRepeated(ty, ctx);\n    case 'spread':\n        return generateCSharpCodeSpread(ty, ctx);\n    case 'sequence':\n        return generateCSharpCodeSequence(ty, ctx);\n    case 'one-of':\n        return generateCSharpCodeOneOf(ty, ctx);\n    case 'optional':\n        return generateCSharpCodeOptional(ty, ctx);\n    case 'enum':\n        return generateCSharpCodeEnum(ty, ctx);\n    case 'object':\n        return generateCSharpCodeObject(ty, isInterface, ctx);\n    case 'symlink':\n        if (ctx.schema?.has(ty.symlinkTargetName)) {\n            const target = ctx.schema.get(ty.symlinkTargetName);\n            switch (target?.ty.kind) {\n            case 'enum':\n                return 'object';\n            }\n        }\n        return ty.symlinkTargetName;\n    case 'operator':\n        throw new Error(`Unexpected type assertion: ${(ty as any).kind}`);\n    default:\n        throw new Error(`Unknown type assertion: ${(ty as any).kind}`);\n    }\n}\n\n\nexport function generateCSharpCode(schema: TypeAssertionMap): string {\n    let code =\n`using System.ComponentModel.DataAnnotations;\n\nnamespace Tynder.UserSchema\n{\n`;\n\n    const ctx: CodegenContext = {\n        nestLevel: 1,\n        schema,\n    };\n\n    for (const ty of schema.entries()) {\n        const indent0 = '    '.repeat(ctx.nestLevel);\n\n        if (ty[1].ty.kind === 'object') {\n            // nothing to do\n        } else if (ty[1].ty.kind === 'enum') {\n            // nothing to do\n        } else if (ty[1].ty.kind === 'never' && ty[1].ty.passThruCodeBlock) {\n            // nothing to do\n        } else {\n            code += formatCSharpCodeDocComment(ty[1].ty, ctx.nestLevel);\n            let tyName = 'System.Object';\n            switch (ty[1].ty.kind) {\n            case 'primitive':\n                switch (ty[1].ty.primitiveName) {\n                case 'integer':\n                    tyName =  'System.Int32';\n                    break;\n                case 'bigint':\n                    tyName =  'System.Decimal';\n                    break;\n                case 'number':\n                    tyName =  'System.Double';\n                    break;\n                case 'boolean':\n                    tyName =  'System.Boolean';\n                    break;\n                case 'string':\n                    tyName =  'System.String';\n                    break;\n                }\n                break;\n            case 'primitive-value':\n                if (ty[1].ty.value !== null && ty[1].ty.value !== void 0) {\n                    switch (typeof ty[1].ty.primitiveName) {\n                    case 'bigint':\n                        tyName =  'System.Decimal';\n                        break;\n                    default:\n                        switch (typeof ty[1].ty.value) {\n                        case 'number':\n                            tyName =  'System.Double';\n                            break;\n                        case 'boolean':\n                            tyName =  'System.Boolean';\n                            break;\n                        case 'string':\n                            tyName =  'System.String';\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n            code += `${indent0}using ${ty[0]} = ${tyName};\\n\\n`;\n        }\n    }\n\n    let isFirst = true;\n    for (const ty of schema.entries()) {\n        const accessModifier = ty[1].exported ? 'public' : 'public';\n        const indent0 = '    '.repeat(ctx.nestLevel);\n        const indent1 = '    '.repeat(ctx.nestLevel + 1);\n\n        if (ty[1].ty.kind === 'object' || ty[1].ty.kind === 'enum') {\n            if (isFirst) {\n                isFirst = false;\n                code += '\\n';\n            } else {\n                code += '\\n\\n';\n            }\n            code += formatCSharpCodeDocComment(ty[1].ty, ctx.nestLevel);\n        }\n\n        if (ty[1].ty.kind === 'object') {\n            code += `${indent0}${accessModifier} class ${ty[0]}${\n                ty[1].ty.baseTypes && ty[1].ty.baseTypes.length ? ` : ${\n                    ty[1].ty.baseTypes\n                        .filter(x => x.typeName)\n                        .map(x => formatTypeName(x, {...ctx, nestLevel: ctx.nestLevel + 1}, x.typeName as string))\n                        .join(', ')}` : ''} ${\n                generateCSharpCodeInner(ty[1].ty, true, ctx)}\\n`;\n        } else if (ty[1].ty.kind === 'enum') {\n            let value: number | null = 0;\n            code += `${indent0}${accessModifier} static class ${ty[0]}\\n${indent0}{\\n${\n                ty[1].ty.values\n                    .map(x => `${\n                        formatCSharpCodeDocComment(x[2] || '', ctx.nestLevel + 1)}${\n                        indent1}${(() => {\n                            if (value !== null && x[1] === value) {\n                                value++;\n                                return `public static double ${x[0]} { get { return ${x[1]}; } }`;\n                            } else {\n                                if (typeof x[1] === 'number') {\n                                    value = x[1] + 1;\n                                    return `public static double ${x[0]} { get { return ${x[1]}; } }`;\n                                } else {\n                                    return `public static string ${x[0]} { get { return \"${escapeString(x[1])}\"; } }`;\n                                }\n                            }\n                        })()}`)\n                    .join('\\n\\n')}\\n${indent0}}\\n`;\n        } else if (ty[1].ty.kind === 'never' && ty[1].ty.passThruCodeBlock) {\n            // nothing to do\n        } else {\n            // nothing to do\n        }\n    }\n    return code + '}\\n';\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         ObjectAssertion,\n         SerializedSchemaInfo,\n         TypeAssertionSetValue,\n         TypeAssertionMap } from './types';\nimport { escapeString }     from './lib/escape';\nimport { resolveSchema }    from './lib/resolver';\n\n\n\nexport const TynderSchemaVersion = 'tynder/1.0';\n\n\nfunction hasMetaInfo(ty: TypeAssertion) {\n    let hasInfo = false;\n\n    if (ty.messages) {\n        hasInfo = true;\n    }\n    if (ty.message) {\n        hasInfo = true;\n    }\n    if (ty.messageId) {\n        hasInfo = true;\n    }\n\n    switch (ty.kind) {\n    case 'repeated':\n        if (typeof ty.min === 'number') {\n            hasInfo = true;\n        }\n        if (typeof ty.max === 'number') {\n            hasInfo = true;\n        }\n        break;\n    case 'primitive':\n        if (typeof ty.minValue === 'number') {\n            hasInfo = true;\n        }\n        if (typeof ty.maxValue === 'number') {\n            hasInfo = true;\n        }\n        if (typeof ty.greaterThanValue === 'number') {\n            hasInfo = true;\n        }\n        if (typeof ty.lessThanValue === 'number') {\n            hasInfo = true;\n        }\n        if (typeof ty.minLength === 'number') {\n            hasInfo = true;\n        }\n        if (typeof ty.maxLength === 'number') {\n            hasInfo = true;\n        }\n        if (ty.pattern) {\n            hasInfo = true;\n        }\n        break;\n    }\n\n    return hasInfo;\n}\n\n\nfunction serializeInner(ty: TypeAssertion, nestLevel: number): TypeAssertion {\n    if (0 < nestLevel && ty.typeName && !hasMetaInfo(ty)) {\n        switch (ty.kind) {\n        case 'optional':\n            // nothing to do.\n            break;\n        default:\n            return ({\n                ...{\n                    kind: 'symlink',\n                    symlinkTargetName: ty.typeName as string, // NOTE: type inference failed if the switch statement is exists.\n                    typeName: ty.typeName,\n                },\n                ...(ty.name ? {name: ty.name} : {}),\n                ...(ty.docComment ? {docComment: ty.docComment} : {}),\n            });\n        }\n    }\n\n    const ret: TypeAssertion = {...ty};\n    switch (ret.kind) {\n    case 'never': case 'any': case 'unknown': case 'symlink': case 'operator':\n        break;\n    case 'primitive-value':\n        if (typeof ret.value === 'bigint') {\n            ret.value = String(ret.value);\n            ret.primitiveName = 'bigint';\n        }\n        break;\n    case 'primitive':\n        if (ret.pattern) {\n            ret.pattern = `/${ret.pattern.source}/${ret.pattern.flags}` as any;\n        }\n        break;\n    case 'repeated':\n        ret.repeated = serializeInner(ret.repeated, nestLevel + 1);\n        break;\n    case 'spread':\n        ret.spread = serializeInner(ret.spread, nestLevel + 1);\n        break;\n    case 'sequence':\n        ret.sequence = ret.sequence.map(x => serializeInner(x, nestLevel + 1));\n        break;\n    case 'one-of':\n        ret.oneOf = ret.oneOf.map(x => serializeInner(x, nestLevel + 1));\n        break;\n    case 'optional':\n        ret.optional = serializeInner(ret.optional, nestLevel + 1);\n        break;\n    case 'enum':\n        ret.values = ret.values.slice().map(x => x[2] === null || x[2] === void 0 ? x.slice(0, 2) : x) as any;\n        break;\n    case 'object':\n        ret.members = ret.members\n            .map(x => [x[0], serializeInner(x[1], nestLevel + 1), ...x.slice(2)]) as any;\n        if (ret.additionalProps) {\n            ret.additionalProps = ret.additionalProps\n                .map(x => [x[0].map(\n                    p => typeof p === 'string' ?\n                        p : `/${p.source}/${p.flags}`),\n                    serializeInner(x[1], nestLevel + 1), ...x.slice(2)]) as any;\n        }\n        if (ret.baseTypes) {\n            // NOTE: convert 'baseTypes' to 'symlink'.\n            ret.baseTypes = ret.baseTypes.map(x => serializeInner(x, nestLevel + 1)) as ObjectAssertion[];\n        }\n        break;\n    default:\n        throw new Error(`Unknown type assertion: ${(ret as any).kind}`);\n    }\n\n    return ret;\n}\n\n\nexport function serializeToObject(schema: TypeAssertionMap): SerializedSchemaInfo {\n    const ret: SerializedSchemaInfo = {\n        version: TynderSchemaVersion,\n        ns: {},\n    };\n    const current = {};\n\n    for (const ty of schema.entries()) {\n        current[ty[0]] = serializeInner(ty[1].ty, 0);\n    }\n\n    ret.ns['.'] = current;\n\n    return ret;\n}\n\n\nexport function serialize(schema: TypeAssertionMap, asTs?: boolean): string {\n    const ret = serializeToObject(schema);\n\n    if (asTs) {\n        return (\n            `\\n// tslint:disable: object-literal-key-quotes\\n` +\n            `const schema = ${JSON.stringify(ret, null, 2)};\\nexport default schema;\\n\\n` +\n            `export const enum Schema {\\n${Object.keys(ret.ns['.']).filter(x => {\n                return (!\n                    (/^[0-9]/.test(x) ||\n                     /[\\u0000-\\u001f\\u007f]/.test(x) ||\n                     /\\s/.test(x) ||\n                     /[@#$%^&+-=:;.,?!'\"`/|{}()<>[\\]\\*\\\\]/.test(x))\n                );\n            }).map(x => `    ${x} = '${x}',\\n`).join('')}` +\n            `}\\n// tslint:enable: object-literal-key-quotes\\n`\n        );\n    } else {\n        return JSON.stringify(ret, null, 2);\n    }\n}\n\n\nfunction deserializeRegExp(pat: string, errMsg: string) {\n    const m = (/^\\/(.*)\\/([gimsuy]*)$/s).exec(pat);\n    if (m) {\n        return new RegExp(m[1], m[2]);\n    } else {\n        throw new Error(errMsg);\n    }\n}\n\n\nfunction deserializeInner(ty: TypeAssertion) {\n    const ret: TypeAssertion = {...ty};\n    switch (ret.kind) {\n    case 'never': case 'any': case 'unknown':\n    case 'enum': case 'symlink': case 'operator':\n        // NOTE: 'symlink' and 'operator' will resolved by calling 'resolveSymbols()' in 'deserialize()'.\n        break;\n    case 'primitive-value':\n        if (ret.primitiveName === 'bigint') {\n            delete ret.primitiveName;\n            ret.value = BigInt(ret.value);\n        }\n        break;\n    case 'primitive':\n        if (ret.pattern) {\n            ret.pattern = deserializeRegExp(\n                ret.pattern as any,\n                `Unknown pattern match assertion: ${ret.pattern as any}`);\n        }\n        break;\n    case 'repeated':\n        ret.repeated = deserializeInner(ret.repeated);\n        break;\n    case 'spread':\n        ret.spread = deserializeInner(ret.spread);\n        break;\n    case 'sequence':\n        ret.sequence = ret.sequence.map(x => deserializeInner(x));\n        break;\n    case 'one-of':\n        ret.oneOf = ret.oneOf.map(x => deserializeInner(x));\n        break;\n    case 'optional':\n        ret.optional = deserializeInner(ret.optional);\n        break;\n    case 'object':\n        ret.members = ret.members\n            .map(x => [x[0], deserializeInner(x[1]), ...x.slice(2)]) as any;\n        if (ret.additionalProps) {\n            ret.additionalProps = ret.additionalProps\n                .map(x => [x[0].map(\n                    p => String(p).startsWith('/') ?\n                        deserializeRegExp(p as any, `Unknown additional props: ${p}`) : p),\n                    deserializeInner(x[1]), ...x.slice(2)]) as any;\n        }\n        // NOTE: keep 'baseTypes' as 'symlink'.\n        break;\n    default:\n        throw new Error(`Unknown type assertion: ${(ret as any).kind}`);\n    }\n    return ret;\n}\n\n\nexport function deserializeFromObject(obj: any) {\n    if (obj.version !== TynderSchemaVersion) {\n        throw new Error(`Unknown schema version: ${obj.version}`);\n    }\n\n    const schema: TypeAssertionMap = new Map<string, TypeAssertionSetValue>();\n    const current = obj.ns['.'];\n\n    for (const k in current) {\n        if (! Object.prototype.hasOwnProperty.call(current, k)) {\n            continue;\n        }\n        schema.set(k, {\n            ty: deserializeInner(current[k]),\n            exported: false,\n            isDeclare: false,\n            resolved: false,\n        });\n    }\n\n    return resolveSchema(schema, {isDeserialization: true});\n}\n\n\nexport function deserialize(text: string) {\n    const parsed = JSON.parse(text);\n    return deserializeFromObject(parsed);\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { Stereotype,\n         CustomConstraintInfo }             from './types';\nimport { stereotypes as dateStereotypes }   from './stereotypes/date';\nimport { constraints as uniqueConstraints } from './constraints/unique';\n\nexport * from './types';\nexport * from './compiler';\nexport * from './operators';\nexport * from './codegen';\nexport * from './serializer';\nexport * from './validator';\nexport * from './picker';\n\nexport const stereotypes: Array<[string, Stereotype]> = [\n    ...dateStereotypes,\n];\n\nexport const customConstraints: Array<[string, CustomConstraintInfo]> = [\n    ...uniqueConstraints,\n];\n"],"sourceRoot":""}